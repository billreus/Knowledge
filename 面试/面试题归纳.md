<!-- TOC -->

- [操作系统](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
  - [基础](#%E5%9F%BA%E7%A1%80)

<!-- /TOC -->

# 操作系统

记忆：1-5；6-9；10-12

## 基础

一、进程与线程的本质区别、以及各自的使用场景

进程是资源分配的基本单位，是OS分配资源(CPU、RAM、...)的最小单元。线程是独立调度的基本单位，是运行在进程上下文中的逻辑流，是 CPU 使用的最小单元。一个进程中可以有多个线程，它们共享进程资源。

区别：
1. 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

需要频繁创建销毁和需要进行大量计算（耗费cpu，频繁切换）的优先使用线程。常见的浏览器、Web服务(现在写的web是中间件帮你完成了线程的控制)，web处理请求，各种专用服务器(如游戏服务器）

可以设计由多个子应用程序来组合完成目的，Nginx/Redis 都属于多进程模型

二、进程状态

三态：运行态，就绪态，阻塞态

五态：创建，就绪(等待分配到cpu)，执行，阻塞(缺少资源，I/O请求，申请缓存区失败)，终止

三、进程调度算法的特点以及使用场景

1. 批处理系统（保证吞吐量和周转时间）：先来向服务；短作业优先；最短剩余时间优先三种方式
2. 交互式系统（快速响应）：时间片轮转（进程排成队列，每个进程执行一个时间片，用完后放入队尾重新排队）；优先级调度；多级反馈队列（多个时间片的队列，时间短的队列优先级高，进程进入队列未完成放入下一个队列，减少了时间片中超长进程的执行时间）
3. 实时系统：一个请求在一个确定时间内得到响应

四、线程实现的方式

继承Thread，实现Runnable接口，实现Callable接口。

五、协程的作用

协程是一种用户级的轻量级线程，IO密集型应用: 多进程->多线程->事件驱动->协程

六、常见进程同步问题

生产者消费者问题，读者写者问题，哲学家进餐问题

七、进程通信方法的特点以及使用场景

1. 管道：通过pipe函数创建，fd[0] 用于读，fd[1] 用于写。
2. FIFO命名管道：去除了管道只能在父子进程中使用的限制
3. 消息队列：消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁

必要条件：
* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

解决策略：
* 鸵鸟策略：假装没发生。
* 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复
* 死锁预防：破坏互斥条件；破坏占有和等待条件；破坏不可抢占条件；破坏环路
* 死锁避免：安全状态检测；单个资源的银行家算法；多个资源的银行家算法

九、虚拟内存的作用，分页系统实现虚拟内存原理

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法

https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83

十一、比较分页与分段的区别

* 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

* 地址空间的维度：分页是一维地址空间，分段是二维的。

* 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

十二、 分析静态链接的不足，以及动态链接的特点

静态库有以下两个问题：
* 当静态库更新时那么整个程序都要重新进行链接；
* 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

特点：
* 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
* 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。
