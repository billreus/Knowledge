<!-- TOC -->

- [操作系统](#操作系统)
    - [基础](#基础)
        - [一、进程与线程的本质区别、以及各自的使用场景](#一进程与线程的本质区别以及各自的使用场景)
        - [二、进程状态](#二进程状态)
        - [三、进程调度算法的特点以及使用场景](#三进程调度算法的特点以及使用场景)
        - [四、线程实现的方式](#四线程实现的方式)
        - [五、协程的作用](#五协程的作用)
        - [六、常见进程同步问题](#六常见进程同步问题)
        - [七、进程通信方法的特点以及使用场景](#七进程通信方法的特点以及使用场景)
        - [八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁](#八死锁必要条件解决死锁策略能写出和分析死锁的代码能说明在数据库管理系统或者-java-中如何解决死锁)
        - [九、虚拟内存的作用，分页系统实现虚拟内存原理](#九虚拟内存的作用分页系统实现虚拟内存原理)
        - [十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法](#十页面置换算法的原理特别是-lru-的实现原理最好能手写再说明它在-redis-等作为缓存置换算法)
        - [十一、比较分页与分段的区别](#十一比较分页与分段的区别)
        - [十二、 分析静态链接的不足，以及动态链接的特点](#十二-分析静态链接的不足以及动态链接的特点)
- [Java](#java)
    - [基础](#基础-1)
        - [一、一个".java"源文件中是否可以包括多个类?](#一一个java源文件中是否可以包括多个类)
        - [二、switch case中switch后的变量可以是什么？](#二switch-case中switch后的变量可以是什么)
        - [三、 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？](#三-使用final关键字修饰一个变量时是引用不能变还是引用的对象不能变)
        - [四、Overload和Override的区别](#四overload和override的区别)
        - [五、Java中实现多态的机制是什么？](#五java中实现多态的机制是什么)
        - [六、构造器Constructor是否可被override?](#六构造器constructor是否可被override)
        - [七、Java抽象类（abstract class）和类（class）的区别？](#七java抽象类abstract-class和类class的区别)
        - [八、Java接口与抽象类如何合作?区别？](#八java接口与抽象类如何合作区别)
        - [九、Java实现了闭包吗？](#九java实现了闭包吗)
        - [十、String s = new String("xyz")创建了几个String Object?](#十string-s--new-stringxyz创建了几个string-object)
        - [十一、try-catch-finally-return的执行顺序](#十一try-catch-finally-return的执行顺序)
        - [十二、ArrayList和Vector的区别](#十二arraylist和vector的区别)
        - [十三、HashMap和Hashtable的区别](#十三hashmap和hashtable的区别)
        - [十四、List，Set，Map是否继承自Collection接口?](#十四listsetmap是否继承自collection接口)
        - [十五、Collection和 Collections的区别。](#十五collection和-collections的区别)
        - [十六、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？](#十六java中有几种类型的流jdk为每种类型的流提供了一些抽象类以供继承请说出他们分别是哪些类)
        - [十七、Java中反射的作用是什么？](#十七java中反射的作用是什么)
        - [十八、 成员变量、局部变量、静态变量的区别](#十八-成员变量局部变量静态变量的区别)
        - [十九、谈谈你对StrongReference、WeakReference和SoftReference的认识](#十九谈谈你对strongreferenceweakreference和softreference的认识)
        - [二十、==与equals()的区别](#二十与equals的区别)
        - [二十一、equals()与hashCode()的区别](#二十一equals与hashcode的区别)
        - [二十三、Java是值传递还是引用传递？](#二十三java是值传递还是引用传递)
        - [二十四、static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？](#二十四static关键字是什么意思java中是否可以覆盖override一个private或者是static的方法)
        - [二十五、是否可以在static环境中访问非static变量？](#二十五是否可以在static环境中访问非static变量)
        - [二十六、Java支持的数据类型有哪些？什么是自动拆装箱？](#二十六java支持的数据类型有哪些什么是自动拆装箱)
        - [二十七、Java集合框架](#二十七java集合框架)
        - [二十八、什么是迭代器(Iterator)？](#二十八什么是迭代器iterator)
        - [二十九、Iterator和ListIterator的区别是什么？](#二十九iterator和listiterator的区别是什么)
        - [三十、Java中的HashMap的工作原理是什么？](#三十java中的hashmap的工作原理是什么)
        - [三十一、String是最基本的数据类型吗?](#三十一string是最基本的数据类型吗)
        - [三十二、int 和 Integer 有什么区别](#三十二int-和-integer-有什么区别)
        - [三十三、String 和StringBuffer的区别](#三十三string-和stringbuffer的区别)
        - [三十四、说出ArrayList,Vector, LinkedList的存储性能和特性](#三十四说出arraylistvector-linkedlist的存储性能和特性)
        - [三十五、final, finally, finalize的区别。](#三十五final-finally-finalize的区别)
        - [三十六、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错?](#三十六short-s11-s1s11有什么错-short-s11-s11有什么错)
        - [三十七、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?](#三十七mathround115等於多少-mathround-115等於多少)
        - [三十八、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?](#三十八接口是否可继承接口-抽象类是否可实现implements接口-抽象类是否可继承实体类concrete-class)
        - [三十九、List, Set, Map是否继承自Collection接口?](#三十九list-set-map是否继承自collection接口)
        - [四十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?](#四十abstract的method是否可同时是static是否可同时是native是否可同时是synchronized)
        - [四十一、是否可以继承String类?](#四十一是否可以继承string类)
        - [四十二、什么是java序列化，如何实现java序列化？](#四十二什么是java序列化如何实现java序列化)
        - [四十三、请说出作用域public，private，protected，以及不写时的区别](#四十三请说出作用域publicprivateprotected以及不写时的区别)
    - [JVM](#jvm)
        - [一、描述一下JVM加载class文件的原理机制?](#一描述一下jvm加载class文件的原理机制)
        - [二、Java内存模型](#二java内存模型)
        - [三、GC中可回收对象的判定方法](#三gc中可回收对象的判定方法)
        - [四、垃圾收集算法](#四垃圾收集算法)
        - [五、类的生命周期](#五类的生命周期)
        - [六、运行时数据区域](#六运行时数据区域)
        - [七、运行时栈帧结构](#七运行时栈帧结构)
        - [八、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？](#八什么是java虚拟机为什么java被称作是平台无关的编程语言)
        - [九、GC是什么? 为什么要有GC?](#九gc是什么-为什么要有gc)
        - [十、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？](#十垃圾回收器的基本原理是什么垃圾回收器可以马上回收内存吗有什么办法主动通知虚拟机进行垃圾回收)
        - [十一、heap和stack有什么区别。](#十一heap和stack有什么区别)
        - [类与类的加载器，双亲委派模型，自定义加载器](#类与类的加载器双亲委派模型自定义加载器)
    - [异步](#异步)
        - [一、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?](#一当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法)
        - [二、用户线程（User Thread）与守护线程（Daemon Thread）](#二用户线程user-thread与守护线程daemon-thread)
        - [三、Java中的BIO，NIO，AIO分别是什么?](#三java中的bionioaio分别是什么)
        - [四、线程同步的方法](#四线程同步的方法)
        - [五、线程创建方式](#五线程创建方式)
        - [六、线程池原理](#六线程池原理)
        - [七、线程的状态和转换关系](#七线程的状态和转换关系)
        - [八、Java线程安全的实现](#八java线程安全的实现)
        - [九、锁优化](#九锁优化)
        - [十、为什么synchronized修饰的变量推荐定义为final？](#十为什么synchronized修饰的变量推荐定义为final)
        - [十一、sleep()和wait()的区别](#十一sleep和wait的区别)
        - [十二、当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？](#十二当前线程wait后会立即阻塞吗其他线程能够进入同步块吗)
        - [十三、为何调用wait()可能抛出InterruptedException异常？](#十三为何调用wait可能抛出interruptedexception异常)
        - [十四、 调用notify()后等待的线程会被立刻唤醒吗？](#十四-调用notify后等待的线程会被立刻唤醒吗)
        - [十五、notify()和notifyAll()有什么区别？](#十五notify和notifyall有什么区别)
        - [十六、线程的sleep()、yield()和join()有什么区别？](#十六线程的sleepyield和join有什么区别)
        - [十七、什么是死锁(deadlock)？](#十七什么是死锁deadlock)
        - [十八、如何确保N个线程可以访问N个资源同时又不导致死锁？](#十八如何确保n个线程可以访问n个资源同时又不导致死锁)
        - [十九、同步和异步有何异同，在什么情况下分别使用他们？举例说明。](#十九同步和异步有何异同在什么情况下分别使用他们举例说明)
        - [二十、简述synchronized和java.util.concurrent.locks.Lock的异同？](#二十简述synchronized和javautilconcurrentlockslock的异同)
        - [二十一、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。](#二十一设计4个线程其中两个线程每次对j增加1另外两个线程对j每次减少1写出程序)
- [数据库](#数据库)
    - [rdis](#rdis)
        - [基于redis的分布式锁](#基于redis的分布式锁)
    - [原理](#原理)
        - [数据库分布式锁](#数据库分布式锁)
    - [mysql](#mysql)
        - [mysql行锁和表锁](#mysql行锁和表锁)

<!-- /TOC -->

# Java

## 基础

### 一、一个".java"源文件中是否可以包括多个类?

可以，但是只能有一个public类，且与类的名字相同

### 二、switch case中switch后的变量可以是什么？

* 可以转换成int的类型
* String类型
* 枚举类型

### 三、 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

如果final修饰的是基本数据类型变量，那么变量值就不能变了，如果修饰的是一个引用变量，那么该变量的地址不能变了，但是所指对象是可以改变的。

例如`final StringBuffer str = new StringBuffer("abc");`后再`str = new StringBuffer("change");`是不可以的，但是可以`str.append("def");`

即：指引用变量不能变，引用变量所指向的对象中的内容是可以改变的。

补充：final修饰类不可被继承，final修饰方法不可被重写

### 四、Overload和Override的区别

Overload是重载表示同一个类中可以有多个名称相同的方法，但是这些方法的参数列表各不相同（即不同的参数类型，不同的参数个数，不同的参数顺序）。

Override是重写，覆盖的意思。是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写了。

### 五、Java中实现多态的机制是什么？

多态由重载和重写体现。

重载通过静态分配实现，即依赖静态类型来定位方法执行的版本。静态分配发生在编译阶段，确定静态分配的动作实际上不是由虚拟机来执行的。

重写通过动态分配实现，即在运行期根据实际类型确定方法执行版本。Java虚拟机为类载方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口地址是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

### 六、构造器Constructor是否可被override?

构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。

补充：构造器是用来对一个类生成的实例进行初始化的，构造器不是方法

### 七、Java抽象类（abstract class）和类（class）的区别？

* 抽象类不能实例化；
* 抽象类允许有abstract方法；
* 抽象类的非抽象子类必须实现abstract方法。

### 八、Java接口与抽象类如何合作?区别？

abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。

接口可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

区别：
* 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
* 类可以实现很多个接口，但是只能继承一个抽象类 
* 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 
* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 
* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 
* 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 

### 九、Java实现了闭包吗？

Java实现了闭包，但仅实现了值的捕获，没实现引用的捕获

### 十、String s = new String("xyz")创建了几个String Object?

两个，一个是在堆中创建的s一个是在字符串常量池中创建的“xyz”。

### 十一、try-catch-finally-return的执行顺序

* 不管是否出现异常，finally块都会执行；
* 当try或catch中有return时，finally块仍然会执行；
* 若try或catch中执行到return，则finally是在return后的表达式执行完成后才执行的

### 十二、ArrayList和Vector的区别

* ArrayList在容量不够时默认是扩展50% + 1个，Vector是默认扩展1倍。
* Vector提供indexOf(obj, start)方法，ArrayList没有。
* Vector是线程安全的，而ArrayList不是。

### 十三、HashMap和Hashtable的区别

* HashTable是线程安全的，而HashMap不是。
* HashMap继承自AbstractMap，HashTable继承自Dictionary。
* HashMap允许key和value为null，而HashTable不允许。

### 十四、List，Set，Map是否继承自Collection接口?

List，Set是，Map不是

### 十五、Collection和 Collections的区别。

Collection是集合类的上级接口，继承于它的接口主要有Set和List。

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

### 十六、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？

字节流，字符流。字节流继承于InputStream/OutputStream，字符流继承于InputStreamReader/OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。

### 十七、Java中反射的作用是什么？

Java反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。Java反射机制主要提供了以下功能：

在运行时判断任意一个对象所属的类；
在运行时构造任意一个类的对象；
在运行时判断任意一个类所具有的成员变量和方法；
在运行时调用任意一个对象的方法；生成动态代理。

### 十八、 成员变量、局部变量、静态变量的区别

属性 | 成员变量 | 局部变量 | 静态变量
------- | ------- | ------- | -------
定义位置 | 在类中，方法外 | 方法中，或者方法的形式参数 | 在类中，方法外
初始化值 | 有默认初始化值 | 无，先定义，赋值后才能使用 | 有默认初始化值
调用方式 | 对象调用 | --- | 对象调用，类名调用
存储位置 | 堆中 | 栈中 | 方法区
生命周期 | 与对象共存亡 | 与方法共存亡 | 与类共存亡
别名 | 实例变量 | --- | 类变量

### 十九、谈谈你对StrongReference、WeakReference和SoftReference的认识

* 强引用（StrongReference）：就是在代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。
* 软引用（SoftReference）：用来描述一些还有用但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* 弱引用（WeakReference）：也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到了下一次GC发生之前。当GC工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象。
* 虚引用（PhantomReference）：虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC回收是收到一个系统通知。

### 二十、==与equals()的区别

* ==判断两个对象的地址是否相等（对于基本类型判断值是否相等）。
* equals()会寻找自身或最近的父类实现，调用其equals()。
* 若无任何父类实现equals()，则会调用Object的equals()，其与==相同。

### 二十一、equals()与hashCode()的区别

 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，但是并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样。

 效率高的原因是：equals()仅在显示调用equals()时使用，而hashCode()在如散列表中会自动调用，以判断是否为同一对象。

 ### 二十二、Error和Exception的区别

 Error类和Exception类的父类都是throwable类，他们的区别是：

* Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
* Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

### 二十三、Java是值传递还是引用传递？

Java中方法参数传递方式是按值传递。

如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。

### 二十四、static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 

方便在没有创建对象的情况下来进行调用（方法/变量）。

Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

### 二十五、是否可以在static环境中访问非static变量？ 

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

### 二十六、Java支持的数据类型有哪些？什么是自动拆装箱？ 

byte, short, int, long, float, double, boolean, char 
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。

### 二十七、Java集合框架

* Collection：代表一组对象，每一个对象都是它的子元素。 
* Set：不包含重复元素的Collection。 
* List：有顺序的collection，并且可以包含重复元素。 
* Map：可以把键(key)映射到值(value)的对象，键不能重复。

### 二十八、什么是迭代器(Iterator)？ 

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

### 二十九、Iterator和ListIterator的区别是什么？ 
下面列出了他们的区别： 
• Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
• Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
• ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

### 三十、Java中的HashMap的工作原理是什么？ 

Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

### 三十一、String是最基本的数据类型吗? 

基本数据类型包括byte、int、char、long、float、double、boolean和short。 
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

### 三十二、int 和 Integer 有什么区别 

Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。

### 三十三、String 和StringBuffer的区别 

JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。

### 三十四、说出ArrayList,Vector, LinkedList的存储性能和特性 

ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而 Linke dList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

### 三十五、final, finally, finalize的区别。 

final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
finally是异常处理语句结构的一部分，表示总是执行。 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

### 三十六、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错? 

s1+1运算结果是int型，需要强制转换类型；s1 += 1可以正确编译，+=内置运算符运算时可自动变换数据类型。

### 三十七、Math.round(11.5)等於多少? Math.round(-11.5)等於多少? 

Math.round(11.5)==12, Math.round(-11.5)==-11, round方法返回与参数最接近的长整数，参数加1/2后求其floor.

### 三十八、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)? 

接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。

### 三十九、List, Set, Map是否继承自Collection接口? 

List，Set是，Map不是

### 四十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 

都不能，也不能和final，private一起使用。

### 四十一、是否可以继承String类? 

String类是final类故不可以继承。

### 四十二、什么是java序列化，如何实现java序列化？ 

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

### 四十三、请说出作用域public，private，protected，以及不写时的区别 

作用域 | 当前类 | 同一package | 子孙类 | 其他package 
-------|--------|------|------|-----
public | √| √ |√| √ 
protected | √| √| √ |× 
friendly | √ |√| ×| × 
private | √  |×| ×| ×

## JVM

### 一、描述一下JVM加载class文件的原理机制?

JVM中类的装载是由ClassLoader和它的子类来实现的，ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。

### 二、Java内存模型

Java内存模型（Java Memory Model，JMM）用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

详见总结。

### 三、GC中可回收对象的判定方法

引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。其优点是简单，高效；缺点是很难处理循环引用。

可达性分析算法

### 四、垃圾收集算法

标记——清除算法，复制算法，标记——整理算法，分代收集算法

### 五、类的生命周期

加载，连接（验证，准备，解析），初始化，使用，卸载

### 六、运行时数据区域

程序计数器，Java虚拟机栈，本地方法栈， Java堆，方法区，运行时常量池

### 七、运行时栈帧结构

栈帧（Stack Frame）是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟栈数据区的组成元素。每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。

### 八、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

### 九、GC是什么? 为什么要有GC? 

GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

### 十、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 十一、heap和stack有什么区别。 

java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 

堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 

### 类与类的加载器，双亲委派模型，自定义加载器

## 异步

### 一、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

若synchronized修饰的是static方法，则获取到的是类锁，否则是对象锁。若其他线程进入的是非synchronized修饰的方法，则可进入；若修饰的方法需要的锁与当前线程相同，则不可进入。

### 二、用户线程（User Thread）与守护线程（Daemon Thread）

* JVM中存在两种线程：用户线程和守护线程
* 当线程中只剩下守护线程时JVM就会退出，反之还有任意一个用户线程在，JVM都不会退出。
thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出IllegalThreadStateException异常。
* 在守护线程中产生的线程也是守护线程。

### 三、Java中的BIO，NIO，AIO分别是什么?

BIO同步阻塞IO：如Apache，Tomcat。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO同步非阻塞IO：如Nginx，Netty。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。

AIO异步非阻塞IO：服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作

### 四、线程同步的方法

* 同步方法：synchronized关键字修饰的方法。
* 同步代码块：synchronized关键字修饰的语句块。
* volatile关键字。
* 可重入锁：ReentrantLock类是可重入、互斥、实现了Lock接口的锁。
ThreadLoca 

### 五、线程创建方式

Thread类，Runnable接口，Callable和Future创建

### 六、线程池原理

运行流程：

1. 接收到任务。
2. 判断已存在线程数是否大于等于核心线程数，如果不是，则创建新线程执行任务；否则转3。
3. 判断任务队列是否有界，如果不是，将任务加入队列中；否则转4。
4. 判断任务队列是否已满，如果不是，将任务加入队列中；否则转5。
5. 判断已存在线程数是否等于最大线程数，如果不是，则创建新线程执行任务；否则转6。
6. 拒绝该任务。

### 七、线程的状态和转换关系

定义了五种线程状态：

* 新建：创建但未启动
* 运行：包括了操作系统线程中的Running和Ready。可能在等待CPU分配执行时间
* 无限期等待：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会触发该状态：
    * 没有设置Timeout参数的Object.wait()方法。
    * 没有设置Timeout参数的Thread.join()方法。
    * LockSupport.park()方法。
* 处于这种状态的线程也不会被分配CPU执行时间，但系统在一定时间后会自动唤醒它。以下方法会触发该状态：
    * Thread.sleep()方法。
    * 设置Timeout参数的Object.wait()方法。
    * 设置Timeout参数的Thread.join()方法。
    * LockSupport.parkNanos()方法。
    * LockSupport.parkUntil()方法。
* 阻塞（Blocked）：阻塞状态下是在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；在程序等待进入同步区域的时候，线程将进入这个状态。
* 结束：线程结束执行

### 八、Java线程安全的实现

互斥同步，非阻塞同步，无同步方案

### 九、锁优化

适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）

### 十、为什么synchronized修饰的变量推荐定义为final？

因为非final变量的引用常常会改变，一旦锁改变了，那synchronization就失去了意义。同时，也不推荐使用String对象作为synchronized代码块的锁，即使是final String。因为String存放在内存的String变量池中，可能会有其他代码或者第三方的代码使用了同一个String对象为锁，这样容易导致一些无法预测的问题

### 十一、sleep()和wait()的区别

* sleep()是Thread类的方法，wait()是Object类中定义的方法。
* Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep()不会让线程释放锁。
* Thread.sleep()和Object.wait()都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。区别是，调用wait()后，需要别的线程执行notify()/notifyAll()才能够重新获得CPU执行时间。

### 十二、当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？

当调用wait()时，当前线程会放弃已经获得的锁，接着会将自己park住，放弃CPU。而在notify()中会选择一个wait()的线程进行unpark，被unpark的线程还需要竞争锁

### 十三、为何调用wait()可能抛出InterruptedException异常？

当调用线程的interrupt()方法时会抛出InterruptedException，因此即使当前线程因wait()一直被阻塞，当被唤醒时也会去检查其状态，如果其被interrupt了，就会抛出InterruptedException。

### 十四、 调用notify()后等待的线程会被立刻唤醒吗？

有不同的策略。默认策略是调用notify()会将一个等待队列中的线程放到锁池中，等到退出同步块时再释放锁，由锁池中的线程竞争。这里“唤醒”的定义不明确，可以说“线程由等待队列移动到锁池”是唤醒，也可以说“线程得到CPU时间”是唤醒。

### 十五、notify()和notifyAll()有什么区别？

注意：synchronized()会使线程进入锁池，wait()会使线程进入等待队列。只有锁池中的线程会竞争锁，等待队列中的线程不会竞争。

notify()会将一个等待队列中的线程移动到锁池中，notifyAll()则会将所有等待队列中的线程移动到锁池中。

### 十六、线程的sleep()、yield()和join()有什么区别？

* sleep()：线程进入阻塞状态；
* yield()：线程进入就绪状态；
* join()：线程进入阻塞状态

### 十七、什么是死锁(deadlock)？

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。 

### 十八、如何确保N个线程可以访问N个资源同时又不导致死锁？ 

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

### 十九、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

### 二十、简述synchronized和java.util.concurrent.locks.Lock的异同？ 

* 主要相同点：Lock能完成synchronized所实现的所有功能 
* 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock是一个类，synchronized是一个关键字。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 

### 二十一、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。

```java
public class ThreadTest1 
{ 
private int j; 
public static void main(String args[]){ 
   ThreadTest1 tt=new ThreadTest1(); 
   Inc inc=tt.new Inc(); 
   Dec dec=tt.new Dec(); 
   for(int i=0;i<2;i++){ 
       Thread t=new Thread(inc); 
       t.start(); 
           t=new Thread(dec); 
       t.start(); 
       } 
   } 
private synchronized void inc(){ 
   j++; 
   System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
   } 
private synchronized void dec(){ 
   j--; 
   System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
   } 
class Inc implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       inc(); 
       } 
   } 
} 
class Dec implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       dec(); 
       } 
```

# 操作系统

记忆：1-5；6-9；10-12

## 基础

### 一、进程与线程的本质区别、以及各自的使用场景

进程是资源分配的基本单位，是OS分配资源(CPU、RAM、...)的最小单元。线程是独立调度的基本单位，是运行在进程上下文中的逻辑流，是 CPU 使用的最小单元。一个进程中可以有多个线程，它们共享进程资源。

区别：
1. 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

需要频繁创建销毁和需要进行大量计算（耗费cpu，频繁切换）的优先使用线程。常见的浏览器、Web服务(现在写的web是中间件帮你完成了线程的控制)，web处理请求，各种专用服务器(如游戏服务器）

可以设计由多个子应用程序来组合完成目的，Nginx/Redis 都属于多进程模型

### 二、进程状态

三态：运行态，就绪态，阻塞态

五态：创建，就绪(等待分配到cpu)，执行，阻塞(缺少资源，I/O请求，申请缓存区失败)，终止

### 三、进程调度算法的特点以及使用场景

1. 批处理系统（保证吞吐量和周转时间）：先来向服务；短作业优先；最短剩余时间优先三种方式
2. 交互式系统（快速响应）：时间片轮转（进程排成队列，每个进程执行一个时间片，用完后放入队尾重新排队）；优先级调度；多级反馈队列（多个时间片的队列，时间短的队列优先级高，进程进入队列未完成放入下一个队列，减少了时间片中超长进程的执行时间）
3. 实时系统：一个请求在一个确定时间内得到响应

### 四、线程实现的方式

继承Thread，实现Runnable接口，实现Callable接口。

### 五、协程的作用

协程是一种用户级的轻量级线程，IO密集型应用: 多进程->多线程->事件驱动->协程

### 六、常见进程同步问题

生产者消费者问题，读者写者问题，哲学家进餐问题

### 七、进程通信方法的特点以及使用场景

1. 管道：通过pipe函数创建，fd[0] 用于读，fd[1] 用于写。
2. FIFO命名管道：去除了管道只能在父子进程中使用的限制
3. 消息队列：消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁

必要条件：
* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

解决策略：
* 鸵鸟策略：假装没发生。
* 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复
* 死锁预防：破坏互斥条件；破坏占有和等待条件；破坏不可抢占条件；破坏环路
* 死锁避免：安全状态检测；单个资源的银行家算法；多个资源的银行家算法

### 九、虚拟内存的作用，分页系统实现虚拟内存原理

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

### 十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法

https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83

### 十一、比较分页与分段的区别

* 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

* 地址空间的维度：分页是一维地址空间，分段是二维的。

* 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 十二、 分析静态链接的不足，以及动态链接的特点

静态库有以下两个问题：
* 当静态库更新时那么整个程序都要重新进行链接；
* 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

特点：
* 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
* 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

# 网路

## 基础

### 一、各层协议的作用，以及 TCP/IP 协议的特点。

五层协议：
* 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
* 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
* 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
* 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

OSI：多了表示层和会话层

TCP/IP:它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

# 数据库

## rdis

### 基于redis的分布式锁

https://segmentfault.com/a/1190000012919740

## 原理

### 数据库分布式锁

http://www.hollischuang.com/archives/1716

## mysql

### mysql行锁和表锁

https://blog.csdn.net/songwei128/article/details/43418343