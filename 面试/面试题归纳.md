<!-- TOC -->

- [Java](#java)
    - [概念](#概念)
        - [一、类与多态](#一类与多态)
            - [Java抽象类（abstract class）和类（class）的区别？](#java抽象类abstract-class和类class的区别)
            - [Java接口与抽象类如何合作?区别？](#java接口与抽象类如何合作区别)
            - [Overload和Override的区别](#overload和override的区别)
            - [Java中实现多态的机制是什么？](#java中实现多态的机制是什么)
        - [二、equal(),==,hashcode](#二equalhashcode)
            - [==与equals()的区别](#与equals的区别)
            - [equals()与hashCode()的区别](#equals与hashcode的区别)
        - [三、字符](#三字符)
            - [String、StringBuilder和StringBuffer的区别](#stringstringbuilder和stringbuffer的区别)
            - [String是最基本的数据类型吗?](#string是最基本的数据类型吗)
            - [String s = new String("xyz")创建了几个String Object?](#string-s--new-stringxyz创建了几个string-object)
        - [四、异常](#四异常)
            - [try-catch-finally-return的执行顺序,final和finally的区别](#try-catch-finally-return的执行顺序final和finally的区别)
            - [final, finally, finalize的区别。](#final-finally-finalize的区别)
            - [使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？](#使用final关键字修饰一个变量时是引用不能变还是引用的对象不能变)
            - [Error和Exception的区别](#error和exception的区别)
        - [五、数据类型](#五数据类型)
            - [Java数据类型有哪些？什么是自动拆装箱？](#java数据类型有哪些什么是自动拆装箱)
            - [Java参数传递是值传递还是引用传递？](#java参数传递是值传递还是引用传递)
            - [深浅拷贝（复制对象）](#深浅拷贝复制对象)
            - [强引用、弱引用、软引用、虚引用](#强引用弱引用软引用虚引用)
        - [六、静态变量](#六静态变量)
            - [static代码块执行顺序，内存泄露](#static代码块执行顺序内存泄露)
            - [static代码块执行顺序](#static代码块执行顺序)
            - [“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？](#static关键字是什么意思java中是否可以覆盖override一个private或者是static的方法)
            - [是否可以在static环境中访问非static变量？](#是否可以在static环境中访问非static变量)
        - [七、反射](#七反射)
            - [反射的作用是什么？](#反射的作用是什么)
            - [动态代理](#动态代理)
    - [集合](#集合)
        - [一、List](#一list)
            - [ArrayList和LinkedList区别](#arraylist和linkedlist区别)
            - [ArrayList线程安全问题](#arraylist线程安全问题)
            - [ArrayList和Vector的区别](#arraylist和vector的区别)
            - [说出ArrayList,Vector, LinkedList的存储性能和特性](#说出arraylistvector-linkedlist的存储性能和特性)
        - [二、Map](#二map)
            - [HashMap的底层实现](#hashmap的底层实现)
            - [HashMap红黑树，链表环，定位逻辑，线程安全方法](#hashmap红黑树链表环定位逻辑线程安全方法)
            - [HashMap和Hashtable的区别](#hashmap和hashtable的区别)
            - [ConcurrentHashMap和Hashtable](#concurrenthashmap和hashtable)
            - [哈希冲突](#哈希冲突)
            - [Set去重](#set去重)
            - [Collection和map](#collection和map)
            - [Java集合框架](#java集合框架)
            - [Collection和 Collections的区别。](#collection和-collections的区别)
    - [其它](#其它)
        - [一、一个".java"源文件中是否可以包括多个类?](#一一个java源文件中是否可以包括多个类)
        - [二、switch case中switch后的变量可以是什么？](#二switch-case中switch后的变量可以是什么)
        - [三、构造器Constructor是否可被override?](#三构造器constructor是否可被override)
        - [四、Java实现了闭包吗？](#四java实现了闭包吗)
        - [五、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？](#五java中有几种类型的流jdk为每种类型的流提供了一些抽象类以供继承请说出他们分别是哪些类)
        - [六、成员变量、局部变量、静态变量的区别](#六成员变量局部变量静态变量的区别)
        - [七、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错?](#七short-s11-s1s11有什么错-short-s11-s11有什么错)
        - [八、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?](#八mathround115等於多少-mathround-115等於多少)
        - [九、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?](#九接口是否可继承接口-抽象类是否可实现implements接口-抽象类是否可继承实体类concrete-class)
        - [十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?](#十abstract的method是否可同时是static是否可同时是native是否可同时是synchronized)
        - [十一、什么是java序列化，如何实现java序列化？](#十一什么是java序列化如何实现java序列化)
        - [十二、请说出作用域public，private，protected，以及不写时的区别](#十二请说出作用域publicprivateprotected以及不写时的区别)
        - [十三、Java变量名不可以用什么](#十三java变量名不可以用什么)
        - [十四、什么是迭代器(Iterator)？](#十四什么是迭代器iterator)
        - [十五、Iterator和ListIterator的区别是什么？](#十五iterator和listiterator的区别是什么)
    - [JVM](#jvm)
        - [一、内存模型](#一内存模型)
            - [Java内存模型](#java内存模型)
                - [程序计数器](#程序计数器)
                - [虚拟机栈](#虚拟机栈)
                - [本地方法栈](#本地方法栈)
                - [Java堆（GC回收的堆）](#java堆gc回收的堆)
                - [方法区](#方法区)
            - [新生代两个幸存区，新生代与老年代的转换](#新生代两个幸存区新生代与老年代的转换)
            - [Java局部变量表](#java局部变量表)
            - [字节码](#字节码)
        - [二、垃圾回收](#二垃圾回收)
            - [GC是什么? 为什么要有GC?](#gc是什么-为什么要有gc)
            - [GC中可回收对象的判定方法](#gc中可回收对象的判定方法)
            - [垃圾收集算法](#垃圾收集算法)
            - [垃圾回收器cms和G1](#垃圾回收器cms和g1)
            - [垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？](#垃圾回收器的基本原理是什么垃圾回收器可以马上回收内存吗有什么办法主动通知虚拟机进行垃圾回收)
            - [内存分配策略](#内存分配策略)
        - [三、类加载](#三类加载)
            - [类的生命周期（加载过程）](#类的生命周期加载过程)
            - [类与类的加载器](#类与类的加载器)
            - [双亲委派模型](#双亲委派模型)
            - [创建对象过程，自定义加载器](#创建对象过程自定义加载器)
            - [描述一下JVM加载class文件的原理机制?](#描述一下jvm加载class文件的原理机制)
        - [四、其他](#四其他)
            - [什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？](#什么是java虚拟机为什么java被称作是平台无关的编程语言)
            - [heap和stack有什么区别。](#heap和stack有什么区别)
            - [OOM四种情况](#oom四种情况)
            - [JVM调优参数](#jvm调优参数)
            - [查看Java内存使用](#查看java内存使用)
    - [异步](#异步)
        - [进程线程](#进程线程)
            - [用户线程（User Thread）与守护线程（Daemon Thread）](#用户线程user-thread与守护线程daemon-thread)
            - [线程的状态和转换关系](#线程的状态和转换关系)
            - [线程创建方式](#线程创建方式)
            - [sleep()和wait()的区别](#sleep和wait的区别)
            - [当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？](#当前线程wait后会立即阻塞吗其他线程能够进入同步块吗)
            - [为何调用wait()可能抛出InterruptedException异常？](#为何调用wait可能抛出interruptedexception异常)
            - [调用notify()后等待的线程会被立刻唤醒吗？](#调用notify后等待的线程会被立刻唤醒吗)
            - [notify()和notifyAll()有什么区别？](#notify和notifyall有什么区别)
            - [线程的sleep()、yield()和join()有什么区别？](#线程的sleepyield和join有什么区别)
            - [线程同步的方法](#线程同步的方法)
        - [volatitle](#volatitle)
            - [volatile作用与原理](#volatile作用与原理)
            - [volatile使用场景和线程安全](#volatile使用场景和线程安全)
        - [Synchronized](#synchronized)
            - [Synchronized原理和用法](#synchronized原理和用法)
            - [volatile和synchronized](#volatile和synchronized)
            - [当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（类锁与对象锁）](#当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法类锁与对象锁)
            - [为什么synchronized修饰的变量推荐定义为final？](#为什么synchronized修饰的变量推荐定义为final)
            - [synchronized和ReentrantLock的区别](#synchronized和reentrantlock的区别)
            - [synchronized和java.util.concurrent.locks.Lock的异同？](#synchronized和javautilconcurrentlockslock的异同)
        - [线程池](#线程池)
            - [线程池意义](#线程池意义)
            - [线程池阻塞队列](#线程池阻塞队列)
            - [线程池调度](#线程池调度)
            - [四种线程池](#四种线程池)
            - [BlockingQueue](#blockingqueue)
        - [锁](#锁)
            - [锁的种类](#锁的种类)
            - [什么是死锁(deadlock)](#什么是死锁deadlock)
            - [如何确保N个线程可以访问N个资源同时又不导致死锁？](#如何确保n个线程可以访问n个资源同时又不导致死锁)
            - [CAS](#cas)
        - [JUC](#juc)
            - [AQS(队列同步器)](#aqs队列同步器)
        - [其它](#其它-1)
            - [ThreadLocal](#threadlocal)
            - [同步和异步有何异同，在什么情况下分别使用他们？举例说明。](#同步和异步有何异同在什么情况下分别使用他们举例说明)
            - [Java线程安全的实现](#java线程安全的实现)
            - [Java中的BIO，NIO，AIO分别是什么?](#java中的bionioaio分别是什么)
            - [为什么要有interruptedException](#为什么要有interruptedexception)
            - [设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。](#设计4个线程其中两个线程每次对j增加1另外两个线程对j每次减少1写出程序)
            - [锁优化](#锁优化)
- [面向对象](#面向对象)
    - [思想](#思想)
        - [面向对象的三大特性](#面向对象的三大特性)
        - [五大原则](#五大原则)
    - [设计模式](#设计模式)
        - [设计模式的作用。](#设计模式的作用)
        - [单例模式](#单例模式)
        - [单例、工厂、代理](#单例工厂代理)
        - [策略模式](#策略模式)
        - [手写工厂模式。分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。](#手写工厂模式分析-jdk-中常用的设计模式例如装饰者模式适配器模式迭代器模式等)
        - [理解 MVC，结合 SpringMVC 回答。](#理解-mvc结合-springmvc-回答)
        - [理解代理模式，结合 Spring 中的 AOP 回答。](#理解代理模式结合-spring-中的-aop-回答)
- [网路](#网路)
    - [基础](#基础)
        - [一、各层协议的作用，以及 TCP/IP 协议的特点。](#一各层协议的作用以及-tcpip-协议的特点)
        - [二、以太网的特点，以及帧结构。](#二以太网的特点以及帧结构)
        - [三、UDP与TCP比较，分析上层协议应该使用UDP还是TCP。](#三udp与tcp比较分析上层协议应该使用udp还是tcp)
        - [四、理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。](#四理解三次握手以及四次挥手具体过程三次握手的原因四次挥手原因time_wait-的作用)
        - [可靠传输原理，并设计可靠 UDP 协议](#可靠传输原理并设计可靠-udp-协议)
        - [TCP拥塞控制的作用，理解具体原理。](#tcp拥塞控制的作用理解具体原理)
        - [DNS的端口号；TCP还是UDP；作为缓存、负载均衡。](#dns的端口号tcp还是udp作为缓存负载均衡)
        - [集线器、交换机、路由器的作用，以及所属的网络层。](#集线器交换机路由器的作用以及所属的网络层)
        - [IP 数据数据报常见字段的作用。](#ip-数据数据报常见字段的作用)
        - [ARP 协议的作用，以及维护 ARP 缓存的过程。](#arp-协议的作用以及维护-arp-缓存的过程)
        - [ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。](#icmp-报文种类以及作用和-ip-数据报的关系ping-和-traceroute-的具体原理)
    - [HTTP](#http)
        - [一、GET和POST区别](#一get和post区别)
        - [二、HTTP常见状态码](#二http常见状态码)
        - [三、Cookie, Session区别](#三cookie-session区别)
        - [四、Http, Https 区别](#四http-https-区别)
        - [输入一个url到返回页面的过程](#输入一个url到返回页面的过程)
        - [长连接与短连接原理以及使用场景，流水线。](#长连接与短连接原理以及使用场景流水线)
        - [HTTP/1.1 的特性。](#http11-的特性)
        - [HTTP/1.x 的缺陷，以及 HTTP/2 的特点。](#http1x-的缺陷以及-http2-的特点)
        - [HTTP 与 FTP 的比较。](#http-与-ftp-的比较)
        - [缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。](#缓存-的cache-control-字段特别是-expires-和-max-age-的区别etag-验证原理)
- [数据库](#数据库)
    - [SQL语句](#sql语句)
        - [手写SQL语句，特别是连接查询与分组查询。](#手写sql语句特别是连接查询与分组查询)
        - [主键，唯一索引区别](#主键唯一索引区别)
        - [连接查询与子查询的比较。](#连接查询与子查询的比较)
        - [drop、delete、truncate 比较。](#dropdeletetruncate-比较)
        - [视图的作用，以及何时能更新视图。](#视图的作用以及何时能更新视图)
        - [理解存储过程、触发器等作用。](#理解存储过程触发器等作用)
    - [Redis](#redis)
        - [优缺点](#优缺点)
        - [Redis数据结构](#redis数据结构)
        - [使用场景](#使用场景)
        - [集群与分布式](#集群与分布式)
        - [字典和跳跃表原理分析](#字典和跳跃表原理分析)
        - [五种对象类型的底层实现](#五种对象类型的底层实现)
        - [基于redis的分布式锁](#基于redis的分布式锁)
    - [MyBatis](#mybatis)
        - [MyBatis中#{}和${}区别(*)](#mybatis中和区别)
    - [原理](#原理)
        - [范式](#范式)
        - [ER图](#er图)
        - [数据库分布式锁](#数据库分布式锁)
    - [mysql](#mysql)
        - [分页](#分页)
        - [聚合函数](#聚合函数)
        - [COUNT(*)和COUNT(1)](#count和count1)
        - [连接](#连接)
        - [UNION和UNION ALL区别](#union和union-all区别)
        - [查看SQL执行状态](#查看sql执行状态)
        - [主从复制与读写分离](#主从复制与读写分离)
        - [存储过程、触发器](#存储过程触发器)
    - [数据结构](#数据结构)
        - [MySQL优化](#mysql优化)
        - [ACID与事务的概念](#acid与事务的概念)
        - [事务隔离级别](#事务隔离级别)
        - [事务回滚](#事务回滚)
        - [索引概念，创建，类型](#索引概念创建类型)
        - [聚族索引（主索引）和非聚族索引(辅助索引)](#聚族索引主索引和非聚族索引辅助索引)
        - [索引原则](#索引原则)
        - [B树，B+树](#b树b树)
            - [B+树比B树更适合数据库索引](#b树比b树更适合数据库索引)
        - [MySQL使用的索引结构，查找效率](#mysql使用的索引结构查找效率)
        - [底层数据存储原理](#底层数据存储原理)
        - [mysql行锁和表锁](#mysql行锁和表锁)
- [Spring](#spring)
    - [概念](#概念-1)
        - [Thymeleaf](#thymeleaf)
        - [Servlet和JSP](#servlet和jsp)
        - [Servlet生命周期](#servlet生命周期)
        - [依赖循环](#依赖循环)
        - [Bean](#bean)
    - [依赖注入，切面](#依赖注入切面)
        - [IOC\DI概念](#ioc\di概念)
        - [Spring中的IOC](#spring中的ioc)
        - [AOP](#aop)
        - [Spring Aop](#spring-aop)
        - [拦截器和过滤器(Filter)](#拦截器和过滤器filter)
    - [SpringMVC](#springmvc)
        - [概念](#概念-2)
        - [动静分离](#动静分离)
    - [SSM](#ssm)
        - [概念](#概念-3)
    - [SpringBoot](#springboot)
        - [Spring和SpringBoot](#spring和springboot)
        - [SpringBoot启动](#springboot启动)
- [操作系统](#操作系统)
    - [基础](#基础-1)
        - [一、进程与线程的本质区别、以及各自的使用场景](#一进程与线程的本质区别以及各自的使用场景)
        - [二、进程状态](#二进程状态)
        - [五、协程的作用](#五协程的作用)
        - [七、进程通信方法的特点以及使用场景](#七进程通信方法的特点以及使用场景)
        - [八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁](#八死锁必要条件解决死锁策略能写出和分析死锁的代码能说明在数据库管理系统或者-java-中如何解决死锁)
        - [九、虚拟内存的作用，分页系统实现虚拟内存原理](#九虚拟内存的作用分页系统实现虚拟内存原理)
        - [十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法](#十页面置换算法的原理特别是-lru-的实现原理最好能手写再说明它在-redis-等作为缓存置换算法)
        - [十一、比较分页与分段的区别](#十一比较分页与分段的区别)
        - [十二、 分析静态链接的不足，以及动态链接的特点](#十二-分析静态链接的不足以及动态链接的特点)
        - [常见进程同步问题](#常见进程同步问题)
        - [进程调度算法的特点以及使用场景](#进程调度算法的特点以及使用场景)
- [Linux](#linux)
    - [cd 打开文件](#cd-打开文件)
    - [ls](#ls)
    - [grep](#grep)
    - [find 寻找](#find-寻找)
    - [cp 复制](#cp-复制)
    - [mv 移动](#mv-移动)
    - [rm 删除](#rm-删除)
    - [ps 查看进程](#ps-查看进程)
    - [kill](#kill)
    - [file](#file)
    - [tar](#tar)
    - [cat](#cat)
- [Git](#git)

<!-- /TOC -->

# Java

## 概念

### 一、类与多态

#### Java抽象类（abstract class）和类（class）的区别？

* 抽象类不能实例化；
* 含有抽象方法的类必须申明为抽象类；
* 抽象类的子类必须实现所有抽象方法，否则其也是抽象类。

#### Java接口与抽象类如何合作?区别？

区别：
* 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
* 类可以实现很多个接口，但是只能继承一个抽象类 
* Java接口中声明的变量默认都是final static的。抽象类可以包含非final的变量。 
* Java接口中的成员函数默认是public static的。抽象类的成员函数可以是private，protected或者是public。 
* 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 
* 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 

抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

#### Overload和Override的区别

Overload是重载表示同一个类中可以有多个名称相同的方法，但是这些方法的参数列表各不相同（即不同的参数类型，不同的参数个数，不同的参数顺序）。

Override是重写，覆盖的意思。是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写了。

#### Java中实现多态的机制是什么？

多态由重载和重写体现。

重载通过静态分配实现，即依赖静态类型来定位方法执行的版本。静态分配发生在编译阶段，确定静态分配的动作实际上不是由虚拟机来执行的。

重写通过动态分配实现，即在运行期根据实际类型确定方法执行版本。Java虚拟机为类载方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口地址是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

### 二、equal(),==,hashcode

#### ==与equals()的区别

* ==判断两个对象的地址是否相等（对于基本类型判断值是否相等）。
* equals()会寻找自身或最近的父类实现，调用其equals()。
* 若无任何父类实现equals()，则会调用Object的equals()，其与==相同。

#### equals()与hashCode()的区别

 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，但是并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样。

 * new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。
 * 重写equals时需要重写hashCode()，否则会出现equals相同的对象hashcode不同导致混淆。

### 三、字符

#### String、StringBuilder和StringBuffer的区别 

* 可变性：String不变，StringBuilder和StringBuffer可变
* 线程安全：String和StringBuffer安全，StringBuilder不安全
* 使用总结：操作少量数据使用String，单线程下大量数据使用StringBuilder，多线程下大量数据使用StringBuffer。

#### String是最基本的数据类型吗? 

String是个对象，是引用类型，所以不能作为基本数据类型。基本数据类型只表示简单的字符或数字包括byte、int、double、float、char、long、short和boolean。 

* char是2个字节16个bit，java用Unicode表示字符，unicode同样也是16位。Unicode字符集包含中文。
* java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

#### String s = new String("xyz")创建了几个String Object?

两个，一个是在堆中创建的s一个是在字符串常量池中创建的“xyz”。

### 四、异常

#### try-catch-finally-return的执行顺序,final和finally的区别

* 不管是否出现异常，finally块都会执行；
* 当try或catch中有return时，finally块仍然会执行；
* 若try或catch中执行到return，则finally是在return后的表达式执行完成后才执行的

final于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。

#### final, finally, finalize的区别。 

* final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
* finally是异常处理语句结构的一部分，表示总是执行。 
* finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

final可以保证线程安全，当你创建一个对象时，使用final关键字能够使得另一个线程不会访问到处于“部分创建”的对象，否则是会可能发生的。

#### 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

如果final修饰的是基本数据类型变量，那么变量值就不能变了，如果修饰的是一个引用变量，那么该变量的地址不能变了，但是所指对象是可以改变的。

例如`final StringBuffer str = new StringBuffer("abc");`后再`str = new StringBuffer("change");`是不可以的，但是可以`str.append("def");`

即引用变量不能变，引用变量所指向的对象中的内容是可以改变的。

补充：final修饰类不可被继承，final修饰方法不可被重写

#### Error和Exception的区别

 Error类和Exception类的父类都是throwable类，他们的区别是：

* Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
* Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

### 五、数据类型

#### Java数据类型有哪些？什么是自动拆装箱？ 

byte, short, int, long, float, double, boolean, char 
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱

引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。

#### Java参数传递是值传递还是引用传递？

值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

Java中是值传递的，只不过对于对象参数，值的内容是对象的引用。（保证传递安全， 房子出现空指针）

当我们在方法中声明一个 int i = 0，或者Object obj = null时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。

https://www.zhihu.com/question/31203609

#### 深浅拷贝（复制对象）

Java中数据类型分为基本数据类型和引用数据类型，前者值传递后者引用传递。

浅拷贝：Object的clone方法，对于基本数据类型会进行值传递，即将该属性值复制一份给新的对象，因为是两份不同数据，所以其中一个对象的成员变量修改不会影响另一个对象的数据。对于引用数据类型例如某个数组，某个类，会进行引用传递，也就是只将该成员变量的引用值（内存地址）复制给新的对象，实际两个对象的成员变量都指向一个实例。在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。

深拷贝：利用对象流,将对象序列化,再反序列化得出新的对象。对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。

区别就在于深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。

浅拷贝速度快效率高，但是在对象引用较深时此方法比较繁琐。序列化可以简便的实现深度copy。

#### 强引用、弱引用、软引用、虚引用

* 强引用（StrongReference）：就是在代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。
* 软引用（SoftReference）：用来描述一些还有用但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* 弱引用（WeakReference）：也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到了下一次GC发生之前。当GC工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象。
* 虚引用（PhantomReference）：虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC回收是收到一个系统通知。

### 六、静态变量

#### static代码块执行顺序，内存泄露

静态代码块随着类加载而加载，有多个静态代码块的，按代码块前后顺序加载。

内存泄露就是程序在向系统申请使用内存后，在使用完以后并没有释放内存，而导致该内存一直被占用。static会使得变量周期延长，耗费过多资源，最后导致泄露。

#### static代码块执行顺序

1、父类静态变量和静态代码块（先声明的先执行）；

2、子类静态变量和静态代码块（先声明的先执行）；

3、父类的变量和代码块（先声明的先执行）；

4、父类的构造函数；

5、子类的变量和代码块（先声明的先执行）；

6、子类的构造函数。

#### “static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 

方便在没有创建对象的情况下来进行调用（方法/变量）。

Java中static方法不能被覆盖（重写），因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

#### 是否可以在static环境中访问非static变量？ 

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

### 七、反射

#### 反射的作用是什么？

可以不在编译时知道某个对象的类型，而在运行时通过提供完整的”包名+类名.class”得到

反射用途：使用IDE输入一个类的属性或方法时一按"."就自动列出属性，方法即是反射。框架都是配置化的（通过XML文件配置JavaBean等）为了保证框架通用性，可能要加载不同的对象或者类，调用不同的方法此时需要用到反射——运行时动态加载需要加载的对象。

* 在运行时构造任意一个类的对象；
* 在运行时判断任意一个对象所属的类；
* 在运行时判断任意一个类所具有的成员变量和方法；
* 在运行时调用任意一个对象的方法；生成动态代理。

通过反射获取私有属性及方法，修改属性方法值：https://blog.csdn.net/gretchen_grundler/article/details/79550530，https://www.jianshu.com/p/4d57ad5f8950

#### 动态代理

为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在两者之间起到中介的作用（可类比房屋中介，房东委托中
介销售房屋、签订合同等）。

所谓动态代理，就是实现阶段不用关心代理谁，而是在运行阶段才指定代理哪个一个对象（不确定性）。如果是自己写代理类的方式就是静态代理（确定性）。

动态代理：https://www.cnblogs.com/gonjan-blog/p/6685611.html

## 集合

### 一、List

#### ArrayList和LinkedList区别

* 数据结构：ArrayList基于动态数组，LinkedList基于链表
* 随机访问：LinkedList效率低
* 空间容量：ArrayList的结尾会预留一定的空间容量，LinkedList每个元素需要消耗相当的空间

#### ArrayList线程安全问题

当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常。

可以使用CopyOnWriteArrayList去避免。

* CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

#### ArrayList和Vector的区别

* ArrayList在容量不够时默认是扩展1.5倍，Vector是默认扩展2倍。
* Vector提供indexOf(obj, start)方法，ArrayList没有。
* Vector是线程安全的（所有方法都都是同步Synchronized），而ArrayList不是。

ArrayList数组扩容过程：minCapacity - elementData.length > 0即需要扩容

#### 说出ArrayList,Vector, LinkedList的存储性能和特性 

ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢

Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差

LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

### 二、Map

#### HashMap的底层实现

HashMap底层是一个数组+多条链表，以键值对(key-value)的形式存储元素实现的（想用key通过时间复杂度O（1）内拿到对应的Value）使用hashCode()和equals()方法来向集合/从集合添加和检索元素，由于有hash冲突，从而设计链表（链表变长是不是就对时间复杂度O（1）相违背），于是链表长度达到8之后会进行转红黑树

HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

扩容：加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度（加载因子越大，填满的元素越多，空间利用率高但是冲突机会加大，链表长度加长，查找效率降低；加载因子越小，填满元素越少，冲突机会少，但是空间浪费多）。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。默认加载因子0.75，默认数组大小16。

为什么使用数组：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难

为什么使用链表：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：寻址困难，插入和删除容易

#### HashMap红黑树，链表环，定位逻辑，线程安全方法

当链表长度超过8以后转化成红黑树；

定位：1.计算key的hash值 2.根据hash确定在table数组中的位置 3.判断数组的Node对象中key是否等同与传入的key 4.若不是，则一次扫描next节点的key，直到找到为止。O(1)的时间复杂度。

在多个线程并发扩容时，存在线程A未完成扩容线程B又进行扩容，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环。

Java7/8中的HashMap和ConcurrentHashMap：http://www.importnew.com/28263.html

线程安全方法：

* 使用 java.util.Hashtable 类，此类是线程安全的。
* 使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。
* 使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。
* 自己在程序的关键方法或者代码段加锁，保证安全性，当然这是严重的不推荐。

#### HashMap和Hashtable的区别

* HashTable是线程安全的，而HashMap不是。
* HashMap继承自AbstractMap，HashTable继承自Dictionary。
* HashMap允许key和value为null，而HashTable不允许。

#### ConcurrentHashMap和Hashtable

底层采用分段的数组+链表实现，线程安全,通过把整个Map分为N个Segment（默认16个），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术.

锁分段首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 

Concurrenthashmap变量是volatile的，所以get，put不需要加锁。

#### 哈希冲突

开放地址法：从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。

拉链法：将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

再哈希：同时构造多个hash

#### Set去重

被传进来的对象当作Map的Key，因为Map键重复了会覆盖旧的键值，从而达到去重的目的。

#### Collection和map

Collection:List,Set,Queue,LinkedList,ArrayList,Vector,HashSet,TreeSet

Map:HashMap,Hashtable

#### Java集合框架

* Collection：代表一组对象，每一个对象都是它的子元素。 
* Set：不包含重复元素的Collection。 
* List：有顺序的collection，并且可以包含重复元素。 
* Map：可以把键(key)映射到值(value)的对象，键不能重复。

#### Collection和 Collections的区别。

Collection是集合类的上级接口，继承于它的接口主要有Set和List。

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

## 其它

### 一、一个".java"源文件中是否可以包括多个类?

可以，但是只能有一个public类，并且类名与文件名相同

### 二、switch case中switch后的变量可以是什么？

* 可以转换成int的类型
* String类型
* 枚举类型

### 三、构造器Constructor是否可被override?

构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。

补充：构造器是用来对一个类生成的实例进行初始化的，构造器不是方法

### 四、Java实现了闭包吗？

Java实现了闭包，但仅实现了值的捕获，没实现引用的捕获

### 五、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？

字节流，字符流。字节流继承于InputStream/OutputStream，字符流继承于InputStreamReader/OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。

### 六、成员变量、局部变量、静态变量的区别

属性 | 成员变量 | 局部变量 | 静态变量
------- | ------- | ------- | -------
定义位置 | 在类中，方法外 | 方法中，或者方法的形式参数 | 在类中，方法外
初始化值 | 有默认初始化值 | 无，先定义，赋值后才能使用 | 有默认初始化值
调用方式 | 对象调用 | --- | 对象调用，类名调用
存储位置 | 堆中 | 栈中 | 方法区
生命周期 | 与对象共存亡 | 与方法共存亡 | 与类共存亡
别名 | 实例变量 | --- | 类变量

### 七、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错? 

s1+1运算结果是int型，需要强制转换类型；s1 += 1可以正确编译，+=内置运算符运算时可自动变换数据类型。

### 八、Math.round(11.5)等於多少? Math.round(-11.5)等於多少? 

Math.round(11.5)==12, Math.round(-11.5)==-11, round方法返回与参数最接近的长整数，参数加1/2后求其floor.

### 九、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)? 

接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承实体类（但前提是实体类必须有明确的构造函数）

### 十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 

都不能，也不能和final，private一起使用。

（声明static说明可以直接用类名调用该方法；声明abstract说明需要子类重写该方法；如果同时声明static和abstract，用类名调用一个抽象方法肯定不行。）

### 十一、什么是java序列化，如何实现java序列化？ 

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

### 十二、请说出作用域public，private，protected，以及不写时的区别 

作用域 | 当前类 | 同一package | 子孙类 | 其他package 
-------|--------|------|------|-----
public | √| √ |√| √ 
protected | √| √| √ |× 
friendly | √ |√| ×| × 
private | √  |×| ×| ×

protected可以接受外包子孙类的访问，default拒绝一切包外的访问。

### 十三、Java变量名不可以用什么

* $, _, 字母开头
* 不能是数字开头
* 不能使关键字private, final...

### 十四、什么是迭代器(Iterator)？ 

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

### 十五、Iterator和ListIterator的区别是什么？ 
下面列出了他们的区别： 
* Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
* Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
* ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

## JVM

### 一、内存模型

#### Java内存模型

线程私有的数据区包括程序计数器、虚拟机栈和本地方法栈

线程共享的数据区具体包括Java堆和方法区

##### 程序计数器

记录正在执行的虚拟机字节码指令的地址。

* 在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据时间片轮询抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。

##### 虚拟机栈

每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。

##### 本地方法栈

本地方法栈与Java虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行本地方法服务。（Java调用非Java代码）

##### Java堆（GC回收的堆）

Java堆的唯一目的就是存放对象实例，所有对象都在这里分配内存。（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。

堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor的from中，to中的会被放到旧生代，from和to互换。（新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。）

##### 方法区

方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用.如文本字符串、被声明为final的常量值. 

方法区的回收主要是针对常量池的回收（判断引用）和对类型的卸载

回收类: 
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例加载
2. 该类的ClassLoader已经被回收
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

#### 新生代两个幸存区，新生代与老年代的转换

JVM把年轻代分成了三个部分：1个Eden区和两个Survivor区（from和to），默认比例8:1。新创建的对象都会分配到Eden区，这些对象第一次GC后如果存活，会被移到Survivor区，在Survivor区每经历一次GC年龄就好增加一岁，当年龄到达一定程度，就会移动到老年代中。

因为年轻代对象基本都是朝生夕死，所以年轻代的垃圾回收算法使用的是复制算法。当GC开始时，对象只会存在与Eden区和From的Survivor区，To区是空的。然后Eden区中所有存活对象会复制到To区，而在From去中仍存活的对象会根据年龄，当年龄到达一定值会被送到老年代，而没有达到阀值的对象会被复制到To区域。经过此次GC，Eden区和From区被清空，此时From和To会进行交换，保证To在下次GC前是空的。

#### Java局部变量表

在虚拟机栈中存储局部变量、函数调用时传递参数，很多字节码指令都是对局部变量表和操作数栈进行操作的。

#### 字节码

https://blog.csdn.net/u011810352/article/details/80316870

### 二、垃圾回收

#### GC是什么? 为什么要有GC? 

GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

#### GC中可回收对象的判定方法

引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。其优点是简单，高效；缺点是很难处理循环引用。

可达性分析算法：通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，在Java中GC Roots一般包含以下内容：
* 虚拟机栈中局部变量表中引用的对象
* 本地方法栈中 JNI 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象

#### 垃圾收集算法

标记——清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。（CMS收集器）

复制算法：用内存按容量划分两个大小相等的两块，每次只用一块，当一块内存用完了就把还活着的对象复制到另一块上面，把已使用过的内存空间一次清理掉。

标记——整理算法：与复制相似，不过不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（G1收集器）

分代收集算法：新生代使用复制算法，老年代使用标记 - 清除或者标记 - 整理算法

#### 垃圾回收器cms和G1

CMS主要使用标记-清除算法。缺点：CPU利用率不高，无法处理浮动（并发清除阶段用户线程继续运行产生的垃圾），标记清除导致空间碎片，往往出现老年代空间剩余，但是无法找到足够大的连续空间分配对象。

G1可以直接对新生代老年代一起回收，G1把堆划分成多个大小相等的独立区域，新生代和老年代不再物理隔离，每个小空间单独进行垃圾回收。整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

#### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

#### 内存分配策略

对象优先在新生代Eden分配，当Eden空间不足时，发起Minor GC

大对象（很长的字符串数组等）直接进入老年代，避免在Eden和Survivor之间大量内存复制

长期存活对象进入老年代，虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

* Full GC触发条件：调用System.gc();老年代空间不足；Minor GC需要老年代内存大于新生代所有对象空间；

### 三、类加载

#### 类的生命周期（加载过程）

加载，连接（验证，准备，解析），初始化，使用，卸载

#### 类与类的加载器

类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象，主要是下面两种：
* 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；
* 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

#### 双亲委派模型

双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

好处：保证java类库中的类不受用户类影响，防止用户自定义一个类库中的同名类，引起问题

例如：黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。

#### 创建对象过程，自定义加载器

1. JVM根据new参数在方法区常量池中寻找类的符号引用，如果找不到对应的符号引用，那么这个类没有被加载，JVM会进行类加载过程（加载，解析，初始化）
2. 符号引用解析完毕后，JVM会为对象在堆中分配内存
3. 将分配的内存初始化为零
4. 初始化对象头，包括、对象的哈希码、对象的GC分代年龄等信息
5. 调用对象的<init>方法

* loadClass(String, boolean)函数实现了双亲委派模型
* loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.
* defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/quejvm.png)

在类的加载过程中，如果A加载成功，该类会缓存在当前类加载器实例对象C中，key是（A,C）其中A是类的全类名，C是加载A的类加载器对象实例），value是对应的java.lang.Class对象。进行缓存的目的是为了同一个类不被加载两次

#### 描述一下JVM加载class文件的原理机制?

JVM中类的装载是由ClassLoader和它的子类来实现的，把.class文件加载到内存。

### 四、其他

#### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

#### heap和stack有什么区别。 

java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 

堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 

#### OOM四种情况

1. 堆溢出：存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。
2. 栈溢出：栈用来存储线程的局部变量表、操作数栈、动态链接、方法出口等信息，如果线程请求栈的深度大于最大深度。
3. 运行时常量溢出：运行时常量保存在方法区，存放的主要是编译器生成的各种字面量和符号引用，但是运行期间也可能将新的常量放入池中，比如String类的intern方法。
4. 方法区溢出：方法区主要存储被虚拟机加载的类信息，如类名、访问修饰符、常量池、字段描述、方法描述等。理论上在JVM启动后该区域大小应该比较稳定，但是目前很多框架，比如Spring和Hibernate等在运行过程中都会动态生成类，因此也存在OOM的风险。

#### JVM调优参数

* -XX:NewRatio=n，年轻代和年老代的比例
* -Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；
* -Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
* -Xmn Java Heap Young区大小，不熟悉最好保留默认值；
* -Xss 每个线程的Stack大小，不熟悉最好保留默认值；
* -XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1/64
* -XX:MaxPermSize：设置持久代最大值，默认为物理内存的1/4

#### 查看Java内存使用

* jconsole：Java监视GUI
* jmap：打印某个进程内存类所有对象情况
* jps:显示本地Java进程
* jstack：查看该线程当前的堆栈状态

## 异步

### 进程线程

#### 用户线程（User Thread）与守护线程（Daemon Thread）

JVM中存在两种线程：用户线程和守护线程。当线程中只剩下守护线程时JVM就会退出，反之还有任意一个用户线程在，JVM都不会退出。守护线程的作用就是为其他线程提供服务。
* 在守护线程中产生的线程也是守护线程。

#### 线程的状态和转换关系

定义了五种线程状态：

1. 新建：创建但未启动
2. 可运行：可能在等待CPU分配执行时间，可能在运行。包括了操作系统线程中的Running和Ready。
3. 无限期等待：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。
    * 没有设置Timeout参数的Object.wait()/Object.notify()
    * 没有设置Timeout参数的Thread.join()/被调用的线程执行完毕
    * LockSupport.park()/LockSupport.unpark(Thread)
4. 限期等待：处于这种状态的线程也不会被分配CPU执行时间，但系统在一定时间后会自动唤醒它。以下方法会触发该状态：
    * Thread.sleep()方法。
    * 设置Timeout参数的Object.wait()方法。
    * 设置Timeout参数的Thread.join()方法。
    * LockSupport.parkNanos()方法。
    * LockSupport.parkUntil()方法。
5. 阻塞（Blocked）：阻塞状态是指线程因为某种原因放弃了cpu使用权，暂时停止运行。直到线程进入可运行状态，才有机会再次转到运行(running)状态。
6. 结束/死亡(Terminated)：线程结束执行

#### 线程创建方式

继承Thread类，实现Runnable接口，实现Callable接口

```java
//继承Thread
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}

//实现Runnable接口
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}

//等价于
public static void mian(String[] args){
    new Thread(new Runnable(){
        @Override
        public void run(){
            //...
        }
    }).start();
}

//实现Callable接口（Callable 可以有返回值，返回值通过 FutureTask 进行封装）
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

* 调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用run()方法。

#### sleep()和wait()的区别

* sleep()是Thread类的方法，wait()是Object类中定义的方法。
* Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep()不会让线程释放锁。
* Thread.sleep()和Object.wait()都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。区别是，调用wait()后，需要别的线程执行notify()/notifyAll()才能够重新获得CPU执行时间。

#### 当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？

当调用wait()时，当前线程会放弃已经获得的锁，接着会将自己阻塞住，放弃CPU，其他线程进入同步块，而被notify()后还需要与其他线程竞争锁

#### 为何调用wait()可能抛出InterruptedException异常？

当一个线程调用wait后，未被唤醒前，调用interrupt方法，会抛异常InterruptedException，同时释放对象锁，线程终止。

#### 调用notify()后等待的线程会被立刻唤醒吗？

有不同的策略。默认策略是调用notify()会将一个等待队列中的线程放到锁池中，等到退出同步块时再释放锁，由锁池中的线程竞争。这里“唤醒”的定义不明确，可以说“线程由等待队列移动到锁池”是唤醒，也可以说“线程得到CPU时间”是唤醒。

* synchronized()会使线程进入锁池，wait()会使线程进入等待队列。只有锁池中的线程会竞争锁，等待队列中的线程不会竞争。

#### notify()和notifyAll()有什么区别？

notify()会将一个等待队列中的线程移动到锁池中，notifyAll()则会将所有等待队列中的线程移动到锁池中。

#### 线程的sleep()、yield()和join()有什么区别？

* sleep()：线程进入阻塞状态；
* yield()：线程进入就绪状态，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行
* join()：线程进入阻塞状态，等待join线程完成后再继续运行

#### 线程同步的方法

* 同步方法：synchronized关键字修饰的方法。
* 同步代码块：synchronized关键字修饰的语句块。
* volatile关键字（保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。禁止进行指令重排序。）
* 可重入锁：ReentrantLock类是可重入、互斥、实现了Lock接口的锁。

### volatitle

#### volatile作用与原理

作用：
1. 禁止重排序：实例化对象可分为三个步骤：1.分配内存空间，2.初始化对象，3.将内存空间的地址赋值给对应引用。重排序有可能先3后2，在多线程中会出现问题。
2. 实现可见性：指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。
* 原子性：只能保证对单次读写的原子性。原子性保证需要synchronized

原理：
* volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
* 修改volatile变量时会强制将修改后的值刷新的主内存中。修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。
* 例如++操作不是一个原子操作，它包含了读取、加、赋值，如果A线程读取了值后其它线程自增，A的值自然是过期的。所以原子性需要保证只有一个线程修改变量的值，即写操作先行发生于后面对这个变量的读操作

#### volatile使用场景和线程安全

使用场景：可能产生指令重排序问题的地方

volatile保证变量的线程安全需要满足：
1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他状态变量共同参与不变约束。

### Synchronized

#### Synchronized原理和用法

作用：
1. 确保线程互斥访问同步代码
2. 保证共享变量修改及时可见
3. 禁止重排序

用法：
1. 修饰普通方法
2. 修饰静态方法
3. 修饰代码块

#### volatile和synchronized

volatile本质是告诉JVM当前变量不确定需要从主内存读取；synchronized是锁定当前变量，只有当前线程可以访问。

volatile只在变量使用，synchronized可在变量、方法、类使用

volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

#### 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（类锁与对象锁）

若synchronized修饰的是static方法，则获取到的是类锁，否则是对象锁。对象锁只会在多个线程执行该对象时产生互斥，类锁只要是这个类产生的对象，在调用该静态方法时都会互斥。

#### 为什么synchronized修饰的变量推荐定义为final？

因为非final变量的引用常常会改变，一旦锁改变了，那synchronization就失去了意义。同时，也不推荐使用String对象作为synchronized代码块的锁，即使是final String。因为String存放在内存的String变量池中，可能会有其他代码或者第三方的代码使用了同一个String对象为锁，这样容易导致一些无法预测的问题

#### synchronized和ReentrantLock的区别

1. 锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
2. 性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
3. 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。
4. 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
5. 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。

可重入性：ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

#### synchronized和java.util.concurrent.locks.Lock的异同？ 

* 主要相同点：Lock能完成synchronized所实现的所有功能 
* 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock是一个类，synchronized是一个关键字。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 

### 线程池

#### 线程池意义

为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。

#### 线程池阻塞队列

把任务用 Runable（其实也可以是Callable）表示，放在一个阻塞队列里。阻塞队列是一个链表，每次取元素或者放元素就对数组操作。没有元素而要取元素时，阻塞，满了而要放元素时，阻塞。一般阻塞队列满了会采用拒绝策略。

拒绝策略默认是队列满了丢弃任务抛出异常；此外还有三种：丢任务不异常；将最早的任务删除再尝试加入队列；添加失败主线程自己去执行。

#### 线程池调度

运行流程：

1. 接收到任务。
2. 判断已存在线程数是否大于等于核心线程数，如果不是，则创建新线程执行任务；否则转3。
3. 判断任务队列是否有界，如果不是，将任务加入队列中；否则转4。
4. 判断任务队列是否已满，如果不是，将任务加入队列中；否则转5。
5. 判断已存在线程数是否等于最大工作线程数，如果不是，则创建新线程执行任务；否则转6。
6. 拒绝该任务。

* 无界队列即除非系统资源耗尽，否则不存在任务入队失败即会一直放入队列中，不考虑最大工作线程。有界队列中当线程数小于核心工作线程时会立马执行，当超过核心工作线程时会放入有界队列中，当队列满了如果线程数小于最大工作线程会尝试new一个线程救急。

#### 四种线程池

Executors 提供了四种静态方法来创建线程池,四种线程池都是直接或间接配置ThreadPoolExecutor的参数实现.

1. 可缓存线程池CachedThreadPool():没有核心线程，线程数量没有限制，没有工作的线程60s后会销毁。
2. FixedThreadPool 定长线程池：最大线程数等于核心线程数，当前线程数小于核心线程数时，即使有空闲的线程也会新建线程。
3. SingleThreadPool：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中
4. ScheduledThreadPool：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行。用于任务调度

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
```

#### BlockingQueue

java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：
* FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
* 优先级队列 ：PriorityBlockingQueue
* 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。

### 锁

#### 锁的种类

公平锁/非公平锁：Synchronized非公平，ReentrantLock默认非公平可以设置为公平。

乐观锁/悲观锁：悲观锁认为同一个数据并发操作一定会发生修改，需要加锁；乐观锁认为同一个数据并发操作不会发生修改，常采用CAS算法。

独享锁/共享锁：独享指该锁一次只能被一个线程所持有(Synchronized/ReentrantLock)，共享锁指该锁可以被多个线程持有。ReentrantReadWriteLock其读锁是共享锁，其写锁是独享锁。

可重入锁：同一个线程在外层方法获取锁的时候，进入内层会自动获取锁。Synchronized/ReentrantLock都是可重入。

锁的优化中：

自旋锁/自适应自旋锁：尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。

偏向锁/轻量级锁/重量级锁：这三种锁是指Synchronized锁的状态。

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### 什么是死锁(deadlock)

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。 

#### 如何确保N个线程可以访问N个资源同时又不导致死锁？ 

指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

#### CAS

线程安全的保证：不可变性（final，String，枚举等），使用锁：互斥同步（Synchronized和ReentrantLock）,使用线程安全类：非互斥同步（CAS,Atomiclnteger）

CAS(Compare And Swap)，即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。

### JUC

#### AQS(队列同步器)

用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架

### 其它

#### ThreadLocal

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

一个线程对应一块工作内存，线程可以存储多个ThreadLocal。那么假设，开启1万个线程，每个线程创建1万个ThreadLocal，也就是每个线程维护1万个ThreadLocal小内存空间，而且当线程执行结束以后，假设这些ThreadLocal里的Entry还不会被回收，那么将很容易导致堆内存溢出。所以应该尽量每次使用ThreadLocal后手动调用remove()。

总结：
1. JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。
2. JVM利用调用remove、get、set方法的时候，回收弱引用。
3. 当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。
4. 当使用static ThreadLocal的时候，延长ThreadLocal的生命周期，那也可能导致内存泄漏。因为，static变量在类未加载的时候，它就已经加载，当线程结束的时候，static变量不一定会回收。那么，比起普通成员变量使用的时候才加载，static的生命周期加长将更容易导致内存泄漏危机。

#### 同步和异步有何异同，在什么情况下分别使用他们？举例说明。 

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

#### Java线程安全的实现

互斥同步，非阻塞同步，无同步方案

#### Java中的BIO，NIO，AIO分别是什么?

BIO同步阻塞IO：如Apache，Tomcat。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。

NIO同步非阻塞IO：如Nginx，Netty。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。

AIO异步非阻塞IO：服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作。

#### 为什么要有interruptedException

https://www.jianshu.com/p/9811a1089783

#### 设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。

```java
public class ThreadTest1 
{ 
private int j; 
public static void main(String args[]){ 
   ThreadTest1 tt=new ThreadTest1(); 
   Inc inc=tt.new Inc(); 
   Dec dec=tt.new Dec(); 
   for(int i=0;i<2;i++){ 
       Thread t=new Thread(inc); 
       t.start(); 
           t=new Thread(dec); 
       t.start(); 
       } 
   } 
private synchronized void inc(){ 
   j++; 
   System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
   } 
private synchronized void dec(){ 
   j--; 
   System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
   } 
class Inc implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       inc(); 
       } 
   } 
} 
class Dec implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       dec(); 
       } 
```

#### 锁优化

适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）

# 面向对象

## 思想

### 面向对象的三大特性

封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。（get/set）

继承：让某个类型的对象获得另一个类型的对象的属性的方法

多态：一个类实例的相同方法在不同情形有不同表现形式（覆盖重载）

### 五大原则

* 单一职责原则：一个类的功能要单一，不能包罗万象
* 开放封闭原则：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的
* 里式替换原则：子类应当可以替换父类并出现在父类能够出现的任何地方
* 依赖倒置原则：具体依赖抽象，上层依赖下层
* 接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

## 设计模式

### 设计模式的作用。

设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。

拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。

### 单例模式

线程安全的双重校验锁，只实例化一次的静态内部类

### 单例、工厂、代理

https://blog.csdn.net/sun8112133/article/details/80058200

### 策略模式

定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。

###手写工厂模式。分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。

https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F?id=examples

### 理解 MVC，结合 SpringMVC 回答。

### 理解代理模式，结合 Spring 中的 AOP 回答。

# 网路

## 基础

### 一、各层协议的作用，以及 TCP/IP 协议的特点。

五层协议：
* 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
* 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
* 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
* 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

OSI：在应用层和传输层直接多了表示层和会话层

TCP/IP:它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

特点是不依赖任何特定计算机，不依赖特定网络传输硬件

### 二、以太网的特点，以及帧结构。

帧结构将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。

以太网是一种星型拓扑结构局域网。

以太网帧格式：

* 类型 ：标记上层使用的协议；
* 数据 ：长度在 46-1500 之间，如果太小则需要填充；
* FCS ：帧检验序列，使用的是 CRC 检验方法；

### 三、UDP与TCP比较，分析上层协议应该使用UDP还是TCP。

用户数据报协议UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

TCP: HTTP, FTP, Telnet, SMTP, POP3

UDP: DNS, SNMP, TFTP

区别：
* TCP是面向连接的，UDP是无连接的；
* TCP是可靠的，UDP是不可靠的；
* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
* TCP是面向字节流的，UDP是面向报文的；
* TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

### 四、理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。

TCP需要三次握手才能建立,而断开连接则需要四次握手

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.png)

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
5. B 收到 A 的确认后，连接建立。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

* A 发送连接释放报文，FIN=1。
* B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
* 当 B 不再需要连接时，发送连接释放报文，FIN=1。
* A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
* B 收到 A 的确认后释放连接。

四次挥手原因： 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT: 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。

这么做有两个理由：

1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 可靠传输原理，并设计可靠 UDP 协议

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

### TCP拥塞控制的作用，理解具体原理。

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四个算法来进行拥塞控制：慢开始（发送网络包的大小是逐渐增长的）、拥塞避免（逐渐增长后续也会很快，设置门限到达限度后增长降低）、快重传（当接收方收到的数据包是不正常的序列号，那么接收方会重复把应该收到的那一条ACK重复发送，这个时候，如果发送方收到连续3条的同一个序列号的ACK，那么就会启动快速重传机制，把这个ACK对应的发送包重新发送一次。）、快恢复（快速恢复到正常报文速度）。

### DNS的端口号；TCP还是UDP；作为缓存、负载均衡。

### 集线器、交换机、路由器的作用，以及所属的网络层。

### IP 数据数据报常见字段的作用。

### ARP 协议的作用，以及维护 ARP 缓存的过程。

### ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。

## HTTP

### 一、GET和POST区别

* 作用：GET用于获取资源，而POST用于传输实体主体。
* 参数：GET方式提交的数据最多只能有1024字节，而POST则没有此限制。GET参数中如果存在中文字符由于URL只支持ASCII码所以需要先进行编码。
* 安全性：Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。GET对数据进行查询，POST主要对数据进行增删改所以安全性GET更高。
* 幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。
* 可缓存：GET可以，POST不可以。

### 二、HTTP常见状态码

* 1×× : 请求处理中，请求已被接受，正在处理
* 2×× : 请求成功，请求被成功处理
* 200 OK
* 3×× : 重定向，要完成请求必须进行进一步处理
* 301 : 永久性转移
* 302 ：暂时性转移
* 304 ： 已缓存
* 4×× : 客户端错误，请求不合法
* 400：Bad Request,请求有语法问题
* 403：拒绝请求
* 404：客户端所访问的页面不存在
* 5×× : 服务器端错误，服务器不能处理合法请求
* 500 ：服务器内部错误
* 503 ： 服务不可用，稍等

### 三、Cookie, Session区别

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

Session：
1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

区别：
* 数据存放位置：cookie数据存放在客户的浏览器上，session数据放在服务器上
* 安全性：cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session
* 性能session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE
* 大小：单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。

### 四、Http, Https 区别 

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。

二者之间存在如下不同：

* 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
* 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
* 开销：Https通信需要证书，而证书一般需要向认证机构购买；
* HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

TCP是传输层协议，主要解决数据如何在网络中传输。HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。RPC(Remote Procedure Call)是远程过程调用，提供了一种轻量无感知的跨进程通信的方式，在分布式机器上调用其他方法与本地调用无异。

### 输入一个url到返回页面的过程

https://blog.csdn.net/qiuchaoxi/article/details/79415400

### 长连接与短连接原理以及使用场景，流水线。

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

* 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；
* 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。

流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。

### HTTP/1.1 的特性。

* 默认是长连接
* 支持流水线
* 支持同时打开多个 TCP 连接
* 支持虚拟主机
* 新增状态码 100
* 支持分块传输编码
* 新增缓存处理指令 max-age

### HTTP/1.x 的缺陷，以及 HTTP/2 的特点。

缺陷：

* 客户端需要使用多个连接才能实现并发和缩短延迟；
* 不会压缩请求和响应首部，从而导致不必要的网络流量；
* 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

### HTTP 与 FTP 的比较。

### 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。

# 数据库

## SQL语句

### 手写SQL语句，特别是连接查询与分组查询。

数据库创建与使用，创建表，修改表名，添加列，删除列，删除表；插入，插入检索数据，一个表插入另一个表；更新替换；删除；查询列（相同只出现一次，限制返回行数，分页查询）；排序；过滤；计算；分组，组内连接；内连接，自连接，自然连接，外连接，子查询，组合查询，交集；

### 主键，唯一索引区别

* 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
* 主键不允许为空值，唯一索引列允许空值；
* 一个表只能有一个主键，但是可以有多个唯一索引；
* 主键可以被其他表引用为外键，唯一索引列不可以；
* 主键本质是约束，值不为空，一个表只能建一个，其目的是检查数据的正确性；唯一索引本质是索引，值可为空，一个表能建一多个，其目的是实现数据查询的优化；

### 连接查询与子查询的比较。

### drop、delete、truncate 比较。

### 视图的作用，以及何时能更新视图。

### 理解存储过程、触发器等作用。

## Redis

### 优缺点

读写相应速度快；大规模并发请求数据库容易异常，redis可以作为缓冲

优点：纯内存操作，单线程操作，非阻塞I/O多路复用
缺点：双写一致性(先更新数据库再删缓存，删除失败提供补偿如消息队列），并发竞争key可以使用分布式锁，大家去抢锁。

### Redis数据结构

String：(String, String),可以是字符串，整数，浮点数，set/get

List：(listkey, list),一个key可以存放一个列表
* 存放一个值：rpush key value；遍历一个范围：lrange key 0-10；取一个index的值：lindex key 1；弹出一个值:lpop key

Hash:(hashkey, subkey, value),包含键值对的无序散列表
* 添加：hset hashkey subkey value; 	取：hgetall hashkey, hget hashkey subkey; 删除:hdel hashkey subkey; 

Set（setkey, item）, 无序集合不会在同一key下存储重复item
* 添加：sadd setkey item；取key下的所有值：smember setkey；是否存在：sismember setkey item；删除：srem setkey item；

ZSet（zseykey, score, member）,有序集合, score用来从小大大实现有序，member不可重负但是score可重复
* 添加：zadd zsetkey score member;

* Hash底层结构：redis的哈希对象的底层存储可以使用ziplist（压缩列表）和hashtable

### 使用场景

计数器:可以对 String 进行自增自减运算，从而实现计数器功能。

缓存:将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

查找表:例如 DNS 记录就很适合使用 Redis 进行存储。

* 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

消息队列:List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。

会话队列:可以使用 Redis 来统一存储多台应用服务器的会话信息。

* 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

分布式锁:在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

* 可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 集群与分布式

分区方法：
1. 范围分区：将不同范围的对象映射到不同Redis实例。比如说，用户ID从0到10000的都被存储到R0,用户ID从10001到20000被存储到R1
2. 哈希：使用hash函数把key转换成一个num。例如，我使用crc32哈希函数，对于key_name foobar: -> crc32(foobar)将输入类似于93024922的值。2.我对这个计算出来的number进行取模运算得到[0, 3]的值，这样我就可以将这个number映射到4个redis_node之一了。（有几个redis_node就%几）

### 字典和跳跃表原理分析

字典：dictht 是一个散列表结构，使用拉链法保存哈希冲突。

跳跃表：是有序集合的底层实现之一。

### 五种对象类型的底层实现

https://blog.csdn.net/caishenfans/article/details/44784131

### 基于redis的分布式锁

https://segmentfault.com/a/1190000012919740

## MyBatis

### MyBatis中#{}和${}区别(*)

''#{}''是经过预编译的,是安全的,而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在sql注入。
只能''＄{}''的情况,order by、like 语句只能用＄{}了,用#{}会多个' '导致sql语句失效.此外动态拼接sql也要用''${}''
''#{}'' 这种取值是编译好SQL语句再取值, ${} 这种是取值以后再去编译SQL语句
重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的sql注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。

## 原理

### 范式

第一范式：属性不可分。

* 每个字段都只能存放单一值，每笔记录都要能利用一个惟一的主键来加以识别

第二范式：每个非主属性完全函数依赖于键码。

* 例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。 

第三范式：非主属性不传递函数依赖于键码

* 例如存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。

第四范式：不允许主键的一部分被另一部分或其它部分决定

* 例如学生张三，老师李（只教一门），课程数据库。那么学生+老师可以确定课程，学生+课程可以确定老师符合三，但是老师可以直接确定课程即主键部分被另一部分决定。

参考：https://www.cnblogs.com/ktao/p/7775100.html

### ER图

https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86?id=%E5%85%AB%E3%80%81er-%E5%9B%BE

### 数据库分布式锁

http://www.hollischuang.com/archives/1716

## mysql

### 分页

限制返回参数使用LIMIT,第一个为起始行，第二个参数为返回总行数

```sql
SELECT *
FROM TABLE
LIMIT 2, 3;
```

### 聚合函数

1.COUNT()函数：用来统计记录的条数；

2.SUM()函数:是求和函数； 

3.AVG()函数:是求平均值的函数 ;

4.MAX()函数是求最大值的函数 

5.MIN()函数是求最小值的函数 

### COUNT(*)和COUNT(1)

一般情况下，Select Count (*)和Select Count(1)两者返回结果是一样的

假如表沒有主键(Primary key), 那么count(1)比count(*)快，如果有主键的話，那主键作为count的条件时候count(主键)最快,如果你的表只有一个字段的话那count(*)就是最快的

### 连接

连接使用JOIN关键字，条件语句使用ON代替WHERE。

连接分为四类：
1. 内连接：INNER JOIN 可以将等值的连接起来
2. 自连接：可看作内连接的一种，只是连接的表是自身
3. 自然连接：NATURAL JOIN 自动连接所有同名的列
4. 外连接: 保留没有关联的行，左外连接LEFT OUTER JOIN保留左表没有关联的，RIGHT OUTER JOIN右外连接，OUTER JOIN全外连接

### UNION和UNION ALL区别

union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。

UNION组合查询，如果第一个查询返回M行，第二个查询返回N行，组合查询即返回M+N行。但是查询必须包含相同列、表达式、函数

```sql
SELECT col
FROM mytable
WHERE col = 1
UNION
SELECT col
FROM mytable
WHERE col =2;
```

### 查看SQL执行状态

explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。使用方法，在select语句前加上explain就可以了

### 主从复制与读写分离

主从复制来同步数据，读写分离提升数据库并发负载能力。一般由于读的请求比写多很多，写操作且比较耗时所以在主库完成，读操作都在分库，让读操作能并发，提高效率。

### 存储过程、触发器

存储过程可以看成是对一系列SQL操作的批处理，代码封装，保证了一定的安全性；代码复用；由于是预先编译，因此具有很高的性能。

```sql
delimiter //

create procedure myprocedure( out ret int )
    begin
        declare y int;
        select sum(col1)
        from mytable
        into y;
        select y*y into ret;
    end //

delimiter ;
```

触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。

区别：存储过程必须有用户、应用程序或者触发器来显示的调用并执行，而触发器是当特定时间出现的时候，自动执行或者激活的，与连接用数据库中的用户、或者应用程序无关。

## 数据结构

### MySQL优化

(https://www.cnblogs.com/wangning528/p/6388538.html)

开启慢查询，分析查询语句。https://blog.csdn.net/qq_35571554/article/details/82800463

不要使用in 和not in，因为会走全表扫描，接着就问了还有什么和in和not in类似的

### ACID与事务的概念

一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性（四个特性的首字母）：
1. 原子性Atomicity：要么事务的所有操作全部提交成功，要么全部失败回滚
2. 一致性Consistency：数据库在事务执行前后保持一致性状态，即所有事务对数据读取结果相同
3. 隔离性Isolation：一个事务所做的修改在提交前对其他事务不可见
4. 持久性Durability：事务一旦提交，其所做的修改会永远保存到数据库

### 事务隔离级别

1. 未提交读：事务中的修改没提交对其它事务也是可见
2. 提交读：一个事务只能读取提交以后的事务所做的修改（大多数数据库默认）
3. 可重复读：保证事务多次读取结果一致（mysql默认级别）
4. 可串行化：强制事务串行执行（加锁读）

脏读：级别1出现，某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

不可重复读:级别2出现，在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读:级别3出现，在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

* MySQL的InnoDB引擎在可重复读的情况下是没法保证不出现幻读的，可通过加悲观锁，即读取时即加锁。或者通过MVCC(多版本并发控制)，会给每个事务一个版本号，事务只能读取<=当前版本号的数据。
* 不可重复读针对的是update或delete，幻读针对的insert。

### 事务回滚

InnoDB的auto_increament的计数器记录的当前值是保存在存内 存中的，并不是存在于磁盘上，当mysql server处于运行的时候，这个计数值只会随着insert改增长，不会随着delete而减少。

事务的回滚时出现并发问题再插入记录时id可能会变小，不符合增长特性。

### 索引概念，创建，类型

索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。

1. 主键索引:`PRIMARY KEY(id)`
2. 唯一索引，即索引列值必须唯一。`UNIQUE INDEX UniqIdx(id)`对id字段使用了索引，并且索引名字为UniqIdx。
3. 单值索引，一个索引包含一列
4. 复合索引，一个索引可以包含多个列
5. 全文索引:`FULLTEXT INDEX FullTxtIdx(info)`

### 聚族索引（主索引）和非聚族索引(辅助索引)

聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引。

非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

* 数据库如果在数据很少时，全盘扫描优于索引，会放弃索引
* 聚簇索引只能建立一个，因为表建立聚集索引之后数据表的数据是根据聚集索引列的顺序排列的，因为任一序列在物理上存储只能有一个顺序，所以聚集索引只能有一个。非聚集索引可以有多个。

https://www.cnblogs.com/xiangyangzhu/p/index.html

### 索引原则

https://www.jianshu.com/p/a0692ff77911

选区分度比较大的，选数据类型比较小的比如整数而不要选长字符串，选where子句中出现的，覆盖索引

最左前缀匹配原则：当多个索引时，mysql查找会向右匹配遇到（<、>、between、like）就会停止，=和in是可以乱序的。因为复合索引的规则是首先会对复合索引的最左边，也就是索引中的第一个字段进行排序，在第一个字段排序的基础上，在对索引上第二个字段进行排序，其实第二个排序已经是无序的了。

### B树，B+树

https://www.cnblogs.com/dreamworlds/p/5398535.html

https://blog.csdn.net/xlgen157387/article/details/79450295
在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。
为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。
总的来说，B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。
B+树的插入删除

https://www.cnblogs.com/nullzx/p/8729425.html

#### B+树比B树更适合数据库索引

B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

### MySQL使用的索引结构，查找效率

底层的话是用b+树实现的，它的优点是能够定位到数据点和范围查询。修改key与子树的组织逻辑，将索引访问都落到叶子节点并 按顺序将叶子节点串起来（方便范围查询）

### 底层数据存储原理

如果直接线性存储的话，每次查找数据都要整个遍历一遍，那么复杂度就是log(n)，于是可以用二叉树来存储，把复杂度降低到约log(n)，但是二叉树有个特点就是，它有可能因为插入顺序的问题，变得不平衡，最坏情况就是都在节点一边，又变成了log(n)，所有就通过改进插入和删除等操作，保证每次操作完后树都是平衡的，就有了B树……

### mysql行锁和表锁

https://blog.csdn.net/songwei128/article/details/43418343

# Spring

## 概念

### Thymeleaf

Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。

### Servlet和JSP

1. jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)
2. jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.
3. Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.
4. Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。

* jsp就是在html里面写java代码，servlet就是在java里面写html代码。

### Servlet生命周期

加载实例化，初始化，请求服务，终止服务（init、service、doGet、doPost、destroy）

https://www.cnblogs.com/lgk8023/p/6427977.html

### 依赖循环

2个或以上bean互相持有对方，最终形成闭环

[https://blog.csdn.net/qq_36381855/article/details/79752689](https://www.jianshu.com/p/8bb67ca11831)

### Bean

https://www.cnblogs.com/bossen/p/5824067.html

http://www.cnblogs.com/zhanglei93/p/6231882.html

## 依赖注入，切面

### IOC\DI概念

依赖倒置原则（DIP）：一种软件架构设计的原则（抽象概念）。
* 依赖无倒置（低层模块定义接口，高层模块负责实现），依赖倒置（高层模块定义接口，低层模块负责实现）。有点在于修改一部分代码不影响其他模块，不会让系统崩溃，松耦合可复用

IOC理论背景：在面向对象的软件系统中，底层都是由N个对象构成，每个对象之间相互合作最终实现业务逻辑。当应用规模变的庞大，对象之间会出现多重依赖，耦合度过高。

控制反转（IoC）：一种反转流、依赖和接口的方式（DIP的具体实现方式）。
* 它为相互依赖的组件提供抽象，将依赖（低层模块）对象的获得交给第三方（系统）来控制，即依赖对象不在被依赖模块的类中直接通过new来获取。

依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。
* 将依赖对象的创建和绑定转移到被依赖对象类的外部来实现

IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）

依赖反转的状况在于：没有IOC时，对象A依赖对象B需要手动创建B，此时控制权在A手中。当IOC时，控制器交给了IOC,即获取以来对象从自身变成了IOC容器主动注入。

总结：DIP是软件设计的一种思想，IoC则是基于DIP衍生出的一种软件设计模式。DI是IoC的具体实现方式之一，使用最为广泛。IoC容器是DI构造函注入的框架，它管理着依赖项的生命周期以及映射关系。

参考：http://blog.jobbole.com/101666/

### Spring中的IOC

Spring启动的时候读取应用程序提供的Bean配置信息,并且在Spring容器中生成一份相应的Bean配置注册表,然后根据这个张注册表实例化Bean,装配好Bean之间的依赖关系,为上层应用提供准备就绪的运行环境.

具体：https://www.cnblogs.com/wuchanming/p/5426746.html

XML配置中：
1. 准备配置文件：配置文件中声明 Bean 定义也就是Bean配置元数据。
2. 通过应用上下文将配置加载到IOC容器
3. 由IoC容器进行解析元数据：IoC 容器的 Bean Reader 读取并解析配置文件，根据定义生成 BeanDefintion 配置元数据对象，IoC 容器根据 BeanDefintion 进行实例化、配置及组装 Bean。
4. 实例化 IoC 容器：由客户端实例化容器，获取需要的 Bean

### AOP

面向切面编程，可以横切多个类型的对象和事务管理，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

AOP剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。

AOP底层机制是动态代理，动态代理有JDK和CGLIB动态代理，JDK是Java内部反射机制，基于统一接口,使用 JDK 生成的动态代理的前提是目标类必须有实现的接口。CGLIB是第三方库，可应用于没有接口的目标对象。

* 横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
* 切面：类是对物体特征的抽象，切面就是对横切关注点的抽象
* 连接点：被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
* 切入点：对连接点进行拦截的定义
* 通知：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
* 目标对象：代理的目标对象
* 织入：将切面应用到目标对象并导致代理对象创建的过程
* 引入：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段

### Spring Aop

1. 创建容器对象的时候，根据切入点表达式拦截的类，生成代理对象。
2. 如果目标对象有实现接口，使用 JDK 代理。如果目标对象没有实现接口，则使用 CGLIB 代理。然后从容器获取代理后的对象，在运行期植入“切面”类的方法。

参考：http://www.importnew.com/31318.html#comment-765192

### 拦截器和过滤器(Filter)

都是AOP编程实现，web服务器经过Filter过滤器到达Servlet和Jsp等资源。

1. Filter是Servlet规范规定的只能用于web程序，拦截器是Spring容器内的，是Spring框架支持的。
2. 拦截器可以对Spring任何对象和资源进行使用，Filter则不能只能在Servlet前后使用

## SpringMVC

### 概念

JSP在Html中加入了大量的、复杂的业务逻辑，如果后期业务逻辑发生改变，修改jsp 就会捉襟见肘；Servlet虽然解决了业务逻辑的问题，但是通过字符串拼接的方式生成动态的Html页面，也会导致代码臃肿，难以维护； 

MVC(Model-View-Controller)模式就扬长避短，将两者完美结合在一起，它把把软件系统分为三个层次：模型（Model）、视图（View）和控制器（Controller）；

运行过程如下：
1. Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） 
2. Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 
3. Controller(Servlet)将逻辑处理结果交给View（JSP），动态生成的HTML内容并返回到浏览器显示

总开关DispatcherServlet；请求处理映射器(Handler Mapping)和处理适配器（Handler Adapter），视图解析器(View Resolver)进行视图管理；动作处理器Controller接口（包含ModelAndView，以及处理请求响应对象request和response），配置灵活，支持文件上传，数据简单转化等强大功能。

### 动静分离

动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。

## SSM

### 概念

Spring+SpringMVC+MyBaits

MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。

SSM即将三个框架整合在一起，配置xml文件（mapper/mybatis/springmvc-servlet/web.xml），配置数据源、SpringMVC

## SpringBoot

### Spring和SpringBoot

 Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置.
1. Spring Boot可以建立独立的Spring应用程序；
2. 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了；
3. 无需再像Spring那样搞一堆繁琐的xml文件的配置；
4. 可以自动配置Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。

### SpringBoot启动

https://blog.csdn.net/u010811939/article/details/80592461

# 操作系统

## 基础

### 一、进程与线程的本质区别、以及各自的使用场景

1. 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

需要频繁创建销毁和需要进行大量计算（耗费cpu，频繁切换）的优先使用线程。常见的浏览器、Web服务(现在写的web是中间件帮你完成了线程的控制)，web处理请求，各种专用服务器(如游戏服务器）

可以设计由多个子应用程序来组合完成目的，Nginx/Redis 都属于多进程模型

### 二、进程状态

三态：运行态，就绪态，阻塞态

五态：创建，就绪(等待分配到cpu)，执行，阻塞(缺少资源，I/O请求，申请缓存区失败)，终止

### 五、协程的作用

协程是一种用户级的轻量级线程，IO密集型应用: 多进程->多线程->事件驱动->协程

### 七、进程通信方法的特点以及使用场景

1. 管道：通过pipe函数创建，fd[0] 用于读，fd[1] 用于写。
2. FIFO命名管道：去除了管道只能在父子进程中使用的限制
3. 消息队列：消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁

必要条件：
* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

解决策略：
* 鸵鸟策略：假装没发生。
* 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复
* 死锁预防：破坏互斥条件；破坏占有和等待条件；破坏不可抢占条件；破坏环路
* 死锁避免：安全状态检测；单个资源的银行家算法；多个资源的银行家算法

### 九、虚拟内存的作用，分页系统实现虚拟内存原理

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

### 十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法

https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83

### 十一、比较分页与分段的区别

* 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

* 地址空间的维度：分页是一维地址空间，分段是二维的。

* 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 十二、 分析静态链接的不足，以及动态链接的特点

静态库有以下两个问题：
* 当静态库更新时那么整个程序都要重新进行链接；
* 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

特点：
* 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
* 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

### 常见进程同步问题

生产者消费者问题，读者写者问题，哲学家进餐问题

### 进程调度算法的特点以及使用场景

1. 批处理系统（保证吞吐量和周转时间）：先来向服务；短作业优先；最短剩余时间优先三种方式
2. 交互式系统（快速响应）：时间片轮转（进程排成队列，每个进程执行一个时间片，用完后放入队尾重新排队）；优先级调度；多级反馈队列（多个时间片的队列，时间短的队列优先级高，进程进入队列未完成放入下一个队列，减少了时间片中超长进程的执行时间）
3. 实时系统：一个请求在一个确定时间内得到响应

# Linux

## cd 打开文件

* cd /root/Docements # 切换到目录/root/Docements
* cd ./path # 切换到当前目录下的path目录中，“.”表示当前目录
* cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录

## ls

* -l ：列出长数据串，包含文件的属性与权限数据等
* -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）
* -d ：仅列出目录本身，而不是列出目录的文件数据
* -h ：将文件容量以较易读的方式（GB，kB等）列出来
* -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来

## grep

命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等

* grep [-acinv] [--color=auto] '查找字符串' filename
* -a ：将binary文件以text文件的方式查找数据
* -c ：计算找到‘查找字符串’的次数
* -i ：忽略大小写的区别，即把大小写视为相同
* -v ：反向选择，即显示出没有‘查找字符串’内容的那一行

## find 寻找

find [PATH] [option] [action]

与时间有关的参数：

* -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
* -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
* -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
* -newer file : 列出比file还要新的文件名

## cp 复制

-a ：将文件的特性一起复制
-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行
-r ：递归持续复制，用于目录的复制行为
-u ：目标文件与源文件有差异时才会复制

## mv 移动

-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件已经存在，就会询问是否覆盖
-u ：若目标文件已经存在，且比目标文件新，才会更新

## rm 删除

-f ：就是force的意思，忽略不存在的文件，不会出现警告消息
-i ：互动模式，在删除前会询问用户是否操作
-r ：递归删除，最常用于目录删除，它是一个非常危险的参数

## ps 查看进程

-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出
ps aux # 查看系统所有的进程数据
ps ax # 查看不与terminal有关的所有进程
ps -lA # 查看系统所有的进程数据
ps axjf # 查看连同一部分进程树状态

## kill

该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID

1：SIGHUP，启动被终止的进程
2：SIGINT，相当于输入ctrl+c，中断一个程序的进行
9：SIGKILL，强制中断一个进程的进行
15：SIGTERM，以正常的结束进程方式来终止进程
17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行
killall

-i ：交互式的意思，若需要删除时，会询问用户
-e ：表示后面接的command name要一致，但command name不能超过15个字符
-I ：命令名称忽略大小写

例如：

killall -SIGHUP syslogd # 重新启动syslogd

## file

用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的

file filename
例如：
file ./test

## tar

-c ：新建打包文件
-t ：查看打包文件的内容含有哪些文件名
-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中
-j ：通过bzip2的支持进行压缩/解压缩
-z ：通过gzip的支持进行压缩/解压缩
-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来
-f filename ：filename为要处理的文件
-C dir ：指定压缩/解压缩的目录dir

常用tar命令
压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录

## cat

用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据

cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替
chgrp 改变文件所属所属用户组

chgrp [-R] dirname/filename
-R ：进行递归的持续对所有文件和子目录更改
例如：

chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users
chown 改变文件所有者

chmod 改变文件权限

chmod [-R] xyz 文件或目录
-R：进行递归的持续更改，即连同子目录下的所有文件都会更改

# Git

Git属于分布式版本控制系统，SVN是集中式版本控制系统。

工作流：
* git add files 把文件的修改添加到暂存区
* git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
* git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
* git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改

分支：
* git merge：分支合并

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/git.jpg)

