<!-- TOC -->

- [Java](#java)
    - [基础](#基础)
        - [一、一个".java"源文件中是否可以包括多个类?](#一一个java源文件中是否可以包括多个类)
        - [二、switch case中switch后的变量可以是什么？](#二switch-case中switch后的变量可以是什么)
        - [三、 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？](#三-使用final关键字修饰一个变量时是引用不能变还是引用的对象不能变)
        - [四、Overload和Override的区别](#四overload和override的区别)
        - [五、Java中实现多态的机制是什么？](#五java中实现多态的机制是什么)
        - [六、构造器Constructor是否可被override?](#六构造器constructor是否可被override)
        - [七、Java抽象类（abstract class）和类（class）的区别？](#七java抽象类abstract-class和类class的区别)
        - [八、Java接口与抽象类如何合作?区别？](#八java接口与抽象类如何合作区别)
        - [九、Java实现了闭包吗？](#九java实现了闭包吗)
        - [十、String s = new String("xyz")创建了几个String Object?](#十string-s--new-stringxyz创建了几个string-object)
        - [十一、try-catch-finally-return的执行顺序,final和finally的区别](#十一try-catch-finally-return的执行顺序final和finally的区别)
        - [十二、ArrayList和Vector的区别](#十二arraylist和vector的区别)
        - [十三、HashMap和Hashtable的区别](#十三hashmap和hashtable的区别)
        - [十四、List，Set，Map是否继承自Collection接口?](#十四listsetmap是否继承自collection接口)
        - [十五、Collection和 Collections的区别。](#十五collection和-collections的区别)
        - [十六、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？](#十六java中有几种类型的流jdk为每种类型的流提供了一些抽象类以供继承请说出他们分别是哪些类)
        - [十七、Java中反射的作用是什么？](#十七java中反射的作用是什么)
        - [十八、 成员变量、局部变量、静态变量的区别](#十八-成员变量局部变量静态变量的区别)
        - [十九、谈谈你对StrongReference、WeakReference和SoftReference的认识](#十九谈谈你对strongreferenceweakreference和softreference的认识)
        - [二十、==与equals()的区别](#二十与equals的区别)
        - [二十一、equals()与hashCode()的区别](#二十一equals与hashcode的区别)
        - [二十三、Java是值传递还是引用传递？](#二十三java是值传递还是引用传递)
        - [二十四、“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？](#二十四static关键字是什么意思java中是否可以覆盖override一个private或者是static的方法)
        - [二十五、是否可以在static环境中访问非static变量？](#二十五是否可以在static环境中访问非static变量)
        - [二十六、Java支持的数据类型有哪些？什么是自动拆装箱？](#二十六java支持的数据类型有哪些什么是自动拆装箱)
        - [二十七、Java集合框架](#二十七java集合框架)
        - [二十八、什么是迭代器(Iterator)？](#二十八什么是迭代器iterator)
        - [二十九、Iterator和ListIterator的区别是什么？](#二十九iterator和listiterator的区别是什么)
        - [三十、Java中的HashMap的工作原理是什么？](#三十java中的hashmap的工作原理是什么)
        - [三十一、String是最基本的数据类型吗?](#三十一string是最基本的数据类型吗)
        - [三十二、int 和 Integer 有什么区别](#三十二int-和-integer-有什么区别)
        - [三十三、String 和StringBuffer的区别](#三十三string-和stringbuffer的区别)
        - [三十四、说出ArrayList,Vector, LinkedList的存储性能和特性](#三十四说出arraylistvector-linkedlist的存储性能和特性)
        - [三十五、final, finally, finalize的区别。](#三十五final-finally-finalize的区别)
        - [三十六、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错?](#三十六short-s11-s1s11有什么错-short-s11-s11有什么错)
        - [三十七、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?](#三十七mathround115等於多少-mathround-115等於多少)
        - [三十八、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?](#三十八接口是否可继承接口-抽象类是否可实现implements接口-抽象类是否可继承实体类concrete-class)
        - [三十九、List, Set, Map是否继承自Collection接口?](#三十九list-set-map是否继承自collection接口)
        - [四十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?](#四十abstract的method是否可同时是static是否可同时是native是否可同时是synchronized)
        - [四十一、是否可以继承String类?](#四十一是否可以继承string类)
        - [四十二、什么是java序列化，如何实现java序列化？](#四十二什么是java序列化如何实现java序列化)
        - [四十三、请说出作用域public，private，protected，以及不写时的区别](#四十三请说出作用域publicprivateprotected以及不写时的区别)
        - [四十四、Java变量名不可以用什么](#四十四java变量名不可以用什么)
        - [四十五、static代码块执行顺序](#四十五static代码块执行顺序)
    - [JVM](#jvm)
        - [一、描述一下JVM加载class文件的原理机制?](#一描述一下jvm加载class文件的原理机制)
        - [二、Java内存模型](#二java内存模型)
        - [三、GC中可回收对象的判定方法](#三gc中可回收对象的判定方法)
        - [四、垃圾收集算法](#四垃圾收集算法)
        - [五、类的生命周期](#五类的生命周期)
        - [六、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？](#六什么是java虚拟机为什么java被称作是平台无关的编程语言)
        - [七、GC是什么? 为什么要有GC?](#七gc是什么-为什么要有gc)
        - [八、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？](#八垃圾回收器的基本原理是什么垃圾回收器可以马上回收内存吗有什么办法主动通知虚拟机进行垃圾回收)
        - [九、heap和stack有什么区别。](#九heap和stack有什么区别)
        - [类与类的加载器，双亲委派模型，自定义加载器](#类与类的加载器双亲委派模型自定义加载器)
        - [JVM调优参数](#jvm调优参数)
    - [异步](#异步)
        - [一、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?](#一当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法)
        - [二、用户线程（User Thread）与守护线程（Daemon Thread）](#二用户线程user-thread与守护线程daemon-thread)
        - [三、线程同步的方法](#三线程同步的方法)
        - [四、synchronized 和 ReentrantLock的区别](#四synchronized-和-reentrantlock的区别)
        - [五、线程创建方式](#五线程创建方式)
        - [六、线程池原理](#六线程池原理)
        - [七、线程的状态和转换关系](#七线程的状态和转换关系)
        - [十、为什么synchronized修饰的变量推荐定义为final？](#十为什么synchronized修饰的变量推荐定义为final)
        - [十一、sleep()和wait()的区别](#十一sleep和wait的区别)
        - [十二、当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？](#十二当前线程wait后会立即阻塞吗其他线程能够进入同步块吗)
        - [十三、为何调用wait()可能抛出InterruptedException异常？](#十三为何调用wait可能抛出interruptedexception异常)
        - [十四、 调用notify()后等待的线程会被立刻唤醒吗？](#十四-调用notify后等待的线程会被立刻唤醒吗)
        - [十五、notify()和notifyAll()有什么区别？](#十五notify和notifyall有什么区别)
        - [十六、线程的sleep()、yield()和join()有什么区别？](#十六线程的sleepyield和join有什么区别)
        - [十七、什么是死锁(deadlock)？](#十七什么是死锁deadlock)
        - [十八、如何确保N个线程可以访问N个资源同时又不导致死锁？](#十八如何确保n个线程可以访问n个资源同时又不导致死锁)
        - [十九、同步和异步有何异同，在什么情况下分别使用他们？举例说明。](#十九同步和异步有何异同在什么情况下分别使用他们举例说明)
        - [二十、简述synchronized和java.util.concurrent.locks.Lock的异同？](#二十简述synchronized和javautilconcurrentlockslock的异同)
        - [二十一、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。](#二十一设计4个线程其中两个线程每次对j增加1另外两个线程对j每次减少1写出程序)
        - [八、Java线程安全的实现](#八java线程安全的实现)
        - [二十二、乐观锁、悲观锁、公平锁、非公平锁](#二十二乐观锁悲观锁公平锁非公平锁)
        - [Java中的BIO，NIO，AIO分别是什么?](#java中的bionioaio分别是什么)
        - [九、锁优化](#九锁优化)
- [面向对象](#面向对象)
    - [思想](#思想)
        - [面向对象的三大特性](#面向对象的三大特性)
        - [五大原则](#五大原则)
    - [设计模式](#设计模式)
        - [设计模式的作用。](#设计模式的作用)
        - [手写单例模式，特别是双重检验锁以及静态内部类。手写工厂模式。分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。](#手写单例模式特别是双重检验锁以及静态内部类手写工厂模式分析-jdk-中常用的设计模式例如装饰者模式适配器模式迭代器模式等)
        - [理解 MVC，结合 SpringMVC 回答。](#理解-mvc结合-springmvc-回答)
        - [理解代理模式，结合 Spring 中的 AOP 回答。](#理解代理模式结合-spring-中的-aop-回答)
- [操作系统](#操作系统)
    - [基础](#基础-1)
        - [一、进程与线程的本质区别、以及各自的使用场景](#一进程与线程的本质区别以及各自的使用场景)
        - [二、进程状态](#二进程状态)
        - [五、协程的作用](#五协程的作用)
        - [七、进程通信方法的特点以及使用场景](#七进程通信方法的特点以及使用场景)
        - [八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁](#八死锁必要条件解决死锁策略能写出和分析死锁的代码能说明在数据库管理系统或者-java-中如何解决死锁)
        - [九、虚拟内存的作用，分页系统实现虚拟内存原理](#九虚拟内存的作用分页系统实现虚拟内存原理)
        - [十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法](#十页面置换算法的原理特别是-lru-的实现原理最好能手写再说明它在-redis-等作为缓存置换算法)
        - [十一、比较分页与分段的区别](#十一比较分页与分段的区别)
        - [十二、 分析静态链接的不足，以及动态链接的特点](#十二-分析静态链接的不足以及动态链接的特点)
        - [常见进程同步问题](#常见进程同步问题)
        - [进程调度算法的特点以及使用场景](#进程调度算法的特点以及使用场景)
- [网路](#网路)
    - [基础](#基础-2)
        - [一、各层协议的作用，以及 TCP/IP 协议的特点。](#一各层协议的作用以及-tcpip-协议的特点)
        - [二、以太网的特点，以及帧结构。](#二以太网的特点以及帧结构)
        - [三、UDP与TCP比较，分析上层协议应该使用UDP还是TCP。](#三udp与tcp比较分析上层协议应该使用udp还是tcp)
        - [四、 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。](#四-理解三次握手以及四次挥手具体过程三次握手的原因四次挥手原因time_wait-的作用)
        - [可靠传输原理，并设计可靠 UDP 协议](#可靠传输原理并设计可靠-udp-协议)
        - [TCP拥塞控制的作用，理解具体原理。](#tcp拥塞控制的作用理解具体原理)
        - [DNS的端口号；TCP还是UDP；作为缓存、负载均衡。](#dns的端口号tcp还是udp作为缓存负载均衡)
        - [集线器、交换机、路由器的作用，以及所属的网络层。](#集线器交换机路由器的作用以及所属的网络层)
        - [IP 数据数据报常见字段的作用。](#ip-数据数据报常见字段的作用)
        - [ARP 协议的作用，以及维护 ARP 缓存的过程。](#arp-协议的作用以及维护-arp-缓存的过程)
        - [ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。](#icmp-报文种类以及作用和-ip-数据报的关系ping-和-traceroute-的具体原理)
    - [HTTP](#http)
        - [一、GET和POST区别](#一get和post区别)
        - [二、HTTP常见状态码](#二http常见状态码)
        - [三、Cookie, Session区别](#三cookie-session区别)
        - [Http, Https 区别 (HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。)](#http-https-区别-http-存在的安全性问题以及-https-的加密认证和完整性保护作用)
        - [长连接与短连接原理以及使用场景，流水线。](#长连接与短连接原理以及使用场景流水线)
        - [HTTP/1.1 的特性。](#http11-的特性)
        - [HTTP/1.x 的缺陷，以及 HTTP/2 的特点。](#http1x-的缺陷以及-http2-的特点)
        - [HTTP 与 FTP 的比较。](#http-与-ftp-的比较)
        - [缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。](#缓存-的cache-control-字段特别是-expires-和-max-age-的区别etag-验证原理)
- [数据库](#数据库)
    - [SQL](#sql)
        - [手写 SQL 语句，特别是连接查询与分组查询。](#手写-sql-语句特别是连接查询与分组查询)
        - [主键，唯一索引区别](#主键唯一索引区别)
        - [连接查询与子查询的比较。](#连接查询与子查询的比较)
        - [drop、delete、truncate 比较。](#dropdeletetruncate-比较)
        - [视图的作用，以及何时能更新视图。](#视图的作用以及何时能更新视图)
        - [理解存储过程、触发器等作用。](#理解存储过程触发器等作用)
    - [Redis](#redis)
        - [Redis数据结构](#redis数据结构)
        - [使用场景](#使用场景)
        - [集群与分布式](#集群与分布式)
        - [线程安全问题](#线程安全问题)
        - [字典和跳跃表原理分析](#字典和跳跃表原理分析)
        - [与 Memchached 的比较](#与-memchached-的比较)
        - [事件驱动模型](#事件驱动模型)
        - [事务原理](#事务原理)
        - [基于redis的分布式锁](#基于redis的分布式锁)
    - [MyBatis](#mybatis)
        - [MyBatis中#{}和${}区别(*)](#mybatis中和区别)
    - [原理](#原理)
        - [数据库分布式锁](#数据库分布式锁)
    - [mysql](#mysql)
        - [MySQL索引实现原理+几种索引](#mysql索引实现原理几种索引)
        - [mysql行锁和表锁](#mysql行锁和表锁)
- [Linux](#linux)
    - [cd 打开文件](#cd-打开文件)
    - [ls](#ls)
    - [grep](#grep)
    - [find 寻找](#find-寻找)
    - [cp 复制](#cp-复制)
    - [mv 移动](#mv-移动)
    - [rm 删除](#rm-删除)
    - [ps 查看进程](#ps-查看进程)
    - [kill](#kill)
    - [file](#file)
    - [tar](#tar)
    - [cat](#cat)
- [Git](#git)
- [Java集合](#java集合)

<!-- /TOC -->

# Java

## 基础

### 一、一个".java"源文件中是否可以包括多个类?

可以，但是只能有一个public类，且与类的名字相同

### 二、switch case中switch后的变量可以是什么？

* 可以转换成int的类型
* String类型
* 枚举类型

### 三、 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

如果final修饰的是基本数据类型变量，那么变量值就不能变了，如果修饰的是一个引用变量，那么该变量的地址不能变了，但是所指对象是可以改变的。

例如`final StringBuffer str = new StringBuffer("abc");`后再`str = new StringBuffer("change");`是不可以的，但是可以`str.append("def");`

即：指引用变量不能变，引用变量所指向的对象中的内容是可以改变的。

补充：final修饰类不可被继承，final修饰方法不可被重写

### 四、Overload和Override的区别

Overload是重载表示同一个类中可以有多个名称相同的方法，但是这些方法的参数列表各不相同（即不同的参数类型，不同的参数个数，不同的参数顺序）。

Override是重写，覆盖的意思。是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写了。

### 五、Java中实现多态的机制是什么？

多态由重载和重写体现。

重载通过静态分配实现，即依赖静态类型来定位方法执行的版本。静态分配发生在编译阶段，确定静态分配的动作实际上不是由虚拟机来执行的。

重写通过动态分配实现，即在运行期根据实际类型确定方法执行版本。Java虚拟机为类载方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口地址是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

### 六、构造器Constructor是否可被override?

构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。

补充：构造器是用来对一个类生成的实例进行初始化的，构造器不是方法

### 七、Java抽象类（abstract class）和类（class）的区别？

* 抽象类不能实例化；
* 含有抽象方法的类必须申明为抽象类；
* 抽象类的非抽象子类必须实现所有抽象方法，否则其也是抽象类。

### 八、Java接口与抽象类如何合作?区别？

abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。

接口可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

区别：
* 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
* 类可以实现很多个接口，但是只能继承一个抽象类 
* 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 
* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 
* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 
* 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 

### 九、Java实现了闭包吗？

Java实现了闭包，但仅实现了值的捕获，没实现引用的捕获

### 十、String s = new String("xyz")创建了几个String Object?

两个，一个是在堆中创建的s一个是在字符串常量池中创建的“xyz”。

### 十一、try-catch-finally-return的执行顺序,final和finally的区别

* 不管是否出现异常，finally块都会执行；
* 当try或catch中有return时，finally块仍然会执行；
* 若try或catch中执行到return，则finally是在return后的表达式执行完成后才执行的

final于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。

### 十二、ArrayList和Vector的区别

* ArrayList在容量不够时默认是扩展50% + 1个，Vector是默认扩展1倍。
* Vector提供indexOf(obj, start)方法，ArrayList没有。
* Vector是线程安全的，而ArrayList不是。

### 十三、HashMap和Hashtable的区别

* HashTable是线程安全的，而HashMap不是。
* HashMap继承自AbstractMap，HashTable继承自Dictionary。
* HashMap允许key和value为null，而HashTable不允许。

### 十四、List，Set，Map是否继承自Collection接口?

List，Set是，Map不是

### 十五、Collection和 Collections的区别。

Collection是集合类的上级接口，继承于它的接口主要有Set和List。

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

### 十六、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？

字节流，字符流。字节流继承于InputStream/OutputStream，字符流继承于InputStreamReader/OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。

### 十七、Java中反射的作用是什么？

* 在运行时判断任意一个对象所属的类；
* 在运行时构造任意一个类的对象；
* 在运行时判断任意一个类所具有的成员变量和方法；
* 在运行时调用任意一个对象的方法；生成动态代理。

### 十八、 成员变量、局部变量、静态变量的区别

属性 | 成员变量 | 局部变量 | 静态变量
------- | ------- | ------- | -------
定义位置 | 在类中，方法外 | 方法中，或者方法的形式参数 | 在类中，方法外
初始化值 | 有默认初始化值 | 无，先定义，赋值后才能使用 | 有默认初始化值
调用方式 | 对象调用 | --- | 对象调用，类名调用
存储位置 | 堆中 | 栈中 | 方法区
生命周期 | 与对象共存亡 | 与方法共存亡 | 与类共存亡
别名 | 实例变量 | --- | 类变量

### 十九、谈谈你对StrongReference、WeakReference和SoftReference的认识

* 强引用（StrongReference）：就是在代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。
* 软引用（SoftReference）：用来描述一些还有用但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* 弱引用（WeakReference）：也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到了下一次GC发生之前。当GC工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象。
* 虚引用（PhantomReference）：虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC回收是收到一个系统通知。

### 二十、==与equals()的区别

* ==判断两个对象的地址是否相等（对于基本类型判断值是否相等）。
* equals()会寻找自身或最近的父类实现，调用其equals()。
* 若无任何父类实现equals()，则会调用Object的equals()，其与==相同。

### 二十一、equals()与hashCode()的区别

 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，但是并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样。

 效率高的原因是：equals()仅在显示调用equals()时使用，而hashCode()在如散列表中会自动调用，以判断是否为同一对象。

 ### 二十二、Error和Exception的区别

 Error类和Exception类的父类都是throwable类，他们的区别是：

* Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
* Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

### 二十三、Java是值传递还是引用传递？

Java中方法参数传递方式是按值传递。

如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。

### 二十四、“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 

方便在没有创建对象的情况下来进行调用（方法/变量）。

Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

### 二十五、是否可以在static环境中访问非static变量？ 

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

### 二十六、Java支持的数据类型有哪些？什么是自动拆装箱？ 

byte, short, int, long, float, double, boolean, char 
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。

### 二十七、Java集合框架

* Collection：代表一组对象，每一个对象都是它的子元素。 
* Set：不包含重复元素的Collection。 
* List：有顺序的collection，并且可以包含重复元素。 
* Map：可以把键(key)映射到值(value)的对象，键不能重复。

### 二十八、什么是迭代器(Iterator)？ 

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

### 二十九、Iterator和ListIterator的区别是什么？ 
下面列出了他们的区别： 
* Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
* Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
* ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

### 三十、Java中的HashMap的工作原理是什么？ 

Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

### 三十一、String是最基本的数据类型吗? 

基本数据类型包括byte、int、double、float、char、long、short和boolean。 
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

### 三十二、int 和 Integer 有什么区别 

Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。

### 三十三、String 和StringBuffer的区别 

JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。

### 三十四、说出ArrayList,Vector, LinkedList的存储性能和特性 

ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而 Linke dList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

### 三十五、final, finally, finalize的区别。 

final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
finally是异常处理语句结构的一部分，表示总是执行。 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

### 三十六、short s1=1; s1=s1+1;有什么错? short s1=1; s1+=1;有什么错? 

s1+1运算结果是int型，需要强制转换类型；s1 += 1可以正确编译，+=内置运算符运算时可自动变换数据类型。

### 三十七、Math.round(11.5)等於多少? Math.round(-11.5)等於多少? 

Math.round(11.5)==12, Math.round(-11.5)==-11, round方法返回与参数最接近的长整数，参数加1/2后求其floor.

### 三十八、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)? 

接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承实体类（但前提是实体类必须有明确的构造函数）

### 三十九、List, Set, Map是否继承自Collection接口? 

List，Set是，Map不是

### 四十、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 

都不能，也不能和final，private一起使用。

（声明static说明可以直接用类名调用该方法；声明abstract说明需要子类重写该方法；如果同时声明static和abstract，用类名调用一个抽象方法肯定不行。）

### 四十一、是否可以继承String类? 

String类是final类故不可以继承。

### 四十二、什么是java序列化，如何实现java序列化？ 

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

### 四十三、请说出作用域public，private，protected，以及不写时的区别 

作用域 | 当前类 | 同一package | 子孙类 | 其他package 
-------|--------|------|------|-----
public | √| √ |√| √ 
protected | √| √| √ |× 
friendly | √ |√| ×| × 
private | √  |×| ×| ×

### 四十四、Java变量名不可以用什么

* $, _, 字母开头
* 不能是数字开头
* 不能使关键字private, final...

### 四十五、static代码块执行顺序

1、父类静态变量和静态代码块（先声明的先执行）；

2、子类静态变量和静态代码块（先声明的先执行）；

3、父类的变量和代码块（先声明的先执行）；

4、父类的构造函数；

5、子类的变量和代码块（先声明的先执行）；

6、子类的构造函数。

## JVM

### 一、描述一下JVM加载class文件的原理机制?

JVM中类的装载是由ClassLoader和它的子类来实现的，把.class文件加载到内存。

### 二、Java内存模型

* 线程私有的数据区包括程序计数器、虚拟机栈和本地方法栈
* 线程共享的数据区具体包括Java堆和方法区

程序计数器：

记录正在执行的虚拟机字节码指令的地址。

* 在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据时间片轮询抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。

虚拟机栈：

* 每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

本地方法栈：

* 本地方法栈与Java虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行本地方法服务。

Java堆（GC回收的堆）

* Java堆的唯一目的就是存放对象实例，所有对象都在这里分配内存。（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。
* 堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor的from中，to中的会被放到旧生代，from和to互换。（新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。）

方法区

* 方法区用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据
* 运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用.如文本字符串、被声明为final的常量值. 

方法区的回收主要是针对常量池的回收（判断引用）和对类型的卸载

回收类: 
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例加载
2. 该类的ClassLoader已经被回收
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 三、GC中可回收对象的判定方法

引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。其优点是简单，高效；缺点是很难处理循环引用。

可达性分析算法：通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：
* 虚拟机栈中局部变量表中引用的对象
* 本地方法栈中 JNI 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象

### 四、垃圾收集算法

标记——清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。（CMS收集器）

复制算法：用内存按容量划分两个大小相等的两块，每次只用一块，当一块内存用完了就把还活着的对象复制到另一块上面，把已使用过的内存空间一次清理掉。

标记——整理算法：与复制相似，不过不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（G1收集器）

分代收集算法：新生代使用复制算法，老年代使用标记 - 清除或者标记 - 整理算法

### 五、类的生命周期

加载，连接（验证，准备，解析），初始化，使用，卸载

### 六、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

### 七、GC是什么? 为什么要有GC? 

GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

### 八、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 九、heap和stack有什么区别。 

java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 

堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 

### 类与类的加载器，双亲委派模型，自定义加载器

类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象，主要是下面两种：
* 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；
* 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

好处：黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。

自定义加载器：

* loadClass(String, boolean)函数实现了双亲委派模型
* loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.
* defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/quejvm.png)

### JVM调优参数

* -XX:NewRatio=n，年轻代和年老代的比例
* -Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；
* -Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
* -Xmn Java Heap Young区大小，不熟悉最好保留默认值；
* -Xss 每个线程的Stack大小，不熟悉最好保留默认值；

https://www.jianshu.com/p/a2a6a0995fee

## 异步

### 一、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

若synchronized修饰的是static方法，则获取到的是类锁，否则是对象锁。若其他线程进入的是非synchronized修饰的方法，则可进入；若修饰的方法需要的锁与当前线程相同，则不可进入。

### 二、用户线程（User Thread）与守护线程（Daemon Thread）

* JVM中存在两种线程：用户线程和守护线程
* 当线程中只剩下守护线程时JVM就会退出，反之还有任意一个用户线程在，JVM都不会退出。
* 在守护线程中产生的线程也是守护线程。

### 三、线程同步的方法

* 同步方法：synchronized关键字修饰的方法。
* 同步代码块：synchronized关键字修饰的语句块。
* volatile关键字（保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。禁止进行指令重排序。）
* 可重入锁：ReentrantLock类是可重入、互斥、实现了Lock接口的锁。

### 四、synchronized 和 ReentrantLock的区别

1. 锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
2. 性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
3. 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。
4. 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
5. 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。

### 五、线程创建方式

继承Thread类，实现Runnable接口，实现Callable接口

```java
//继承Thread
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}

//实现Runnable接口
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}

//实现Callable接口（Callable 可以有返回值，返回值通过 FutureTask 进行封装）
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

### 六、线程池原理

为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。

```JAVA
new Thread(new Runnable(){
    @Override
    public void run(){
        // do sth
    }
}).start();
```

运行流程：

1. 接收到任务。
2. 判断已存在线程数是否大于等于核心线程数，如果不是，则创建新线程执行任务；否则转3。
3. 判断任务队列是否有界，如果不是，将任务加入队列中；否则转4。
4. 判断任务队列是否已满，如果不是，将任务加入队列中；否则转5。
5. 判断已存在线程数是否等于最大线程数，如果不是，则创建新线程执行任务；否则转6。
6. 拒绝该任务。

### 七、线程的状态和转换关系

定义了五种线程状态：

* 新建：创建但未启动
* 运行：包括了操作系统线程中的Running和Ready。可能在等待CPU分配执行时间
* 无限期等待：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会触发该状态：
    * 没有设置Timeout参数的Object.wait()方法。
    * 没有设置Timeout参数的Thread.join()方法。
    * LockSupport.park()方法。
* 处于这种状态的线程也不会被分配CPU执行时间，但系统在一定时间后会自动唤醒它。以下方法会触发该状态：
    * Thread.sleep()方法。
    * 设置Timeout参数的Object.wait()方法。
    * 设置Timeout参数的Thread.join()方法。
    * LockSupport.parkNanos()方法。
    * LockSupport.parkUntil()方法。
* 阻塞（Blocked）：阻塞状态下是在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；在程序等待进入同步区域的时候，线程将进入这个状态。
* 结束：线程结束执行

### 十、为什么synchronized修饰的变量推荐定义为final？

因为非final变量的引用常常会改变，一旦锁改变了，那synchronization就失去了意义。同时，也不推荐使用String对象作为synchronized代码块的锁，即使是final String。因为String存放在内存的String变量池中，可能会有其他代码或者第三方的代码使用了同一个String对象为锁，这样容易导致一些无法预测的问题

### 十一、sleep()和wait()的区别

* sleep()是Thread类的方法，wait()是Object类中定义的方法。
* Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep()不会让线程释放锁。
* Thread.sleep()和Object.wait()都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。区别是，调用wait()后，需要别的线程执行notify()/notifyAll()才能够重新获得CPU执行时间。

### 十二、当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？

当调用wait()时，当前线程会放弃已经获得的锁，接着会将自己阻塞住，放弃CPU，其他线程进入同步块，而被notify()后还需要与其他线程竞争锁

### 十三、为何调用wait()可能抛出InterruptedException异常？

当一个线程调用wait后，未被唤醒前，调用interrupt方法，会抛异常InterruptedException，同时释放对象锁，线程终止。

### 十四、 调用notify()后等待的线程会被立刻唤醒吗？

有不同的策略。默认策略是调用notify()会将一个等待队列中的线程放到锁池中，等到退出同步块时再释放锁，由锁池中的线程竞争。这里“唤醒”的定义不明确，可以说“线程由等待队列移动到锁池”是唤醒，也可以说“线程得到CPU时间”是唤醒。

### 十五、notify()和notifyAll()有什么区别？

注意：synchronized()会使线程进入锁池，wait()会使线程进入等待队列。只有锁池中的线程会竞争锁，等待队列中的线程不会竞争。

notify()会将一个等待队列中的线程移动到锁池中，notifyAll()则会将所有等待队列中的线程移动到锁池中。

### 十六、线程的sleep()、yield()和join()有什么区别？

* sleep()：线程进入阻塞状态；
* yield()：线程进入就绪状态，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行
* join()：线程进入阻塞状态，等待join线程完成后再继续运行

### 十七、什么是死锁(deadlock)？

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。 

### 十八、如何确保N个线程可以访问N个资源同时又不导致死锁？ 

指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

### 十九、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

### 二十、简述synchronized和java.util.concurrent.locks.Lock的异同？ 

* 主要相同点：Lock能完成synchronized所实现的所有功能 
* 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock是一个类，synchronized是一个关键字。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 

### 二十一、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。

```java
public class ThreadTest1 
{ 
private int j; 
public static void main(String args[]){ 
   ThreadTest1 tt=new ThreadTest1(); 
   Inc inc=tt.new Inc(); 
   Dec dec=tt.new Dec(); 
   for(int i=0;i<2;i++){ 
       Thread t=new Thread(inc); 
       t.start(); 
           t=new Thread(dec); 
       t.start(); 
       } 
   } 
private synchronized void inc(){ 
   j++; 
   System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
   } 
private synchronized void dec(){ 
   j--; 
   System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
   } 
class Inc implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       inc(); 
       } 
   } 
} 
class Dec implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       dec(); 
       } 
```


### 八、Java线程安全的实现

互斥同步，非阻塞同步，无同步方案

### 二十二、乐观锁、悲观锁、公平锁、非公平锁

### Java中的BIO，NIO，AIO分别是什么?

BIO同步阻塞IO：如Apache，Tomcat。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。

NIO同步非阻塞IO：如Nginx，Netty。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。

AIO异步非阻塞IO：服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作。

### 九、锁优化

适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）

# 面向对象

## 思想

### 面向对象的三大特性

封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。（get/set）

继承：让某个类型的对象获得另一个类型的对象的属性的方法

多态：一个类实例的相同方法在不同情形有不同表现形式（覆盖重载）

### 五大原则

* 单一职责原则：一个类的功能要单一，不能包罗万象
* 开放封闭原则：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的
* 里式替换原则：子类应当可以替换父类并出现在父类能够出现的任何地方
* 依赖倒置原则：具体依赖抽象，上层依赖下层
* 接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

## 设计模式

### 设计模式的作用。

设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。

拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。

### 手写单例模式，特别是双重检验锁以及静态内部类。手写工厂模式。分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。


https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F?id=examples

### 理解 MVC，结合 SpringMVC 回答。
### 理解代理模式，结合 Spring 中的 AOP 回答。

# 操作系统

## 基础

### 一、进程与线程的本质区别、以及各自的使用场景


1. 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

需要频繁创建销毁和需要进行大量计算（耗费cpu，频繁切换）的优先使用线程。常见的浏览器、Web服务(现在写的web是中间件帮你完成了线程的控制)，web处理请求，各种专用服务器(如游戏服务器）

可以设计由多个子应用程序来组合完成目的，Nginx/Redis 都属于多进程模型

### 二、进程状态

三态：运行态，就绪态，阻塞态

五态：创建，就绪(等待分配到cpu)，执行，阻塞(缺少资源，I/O请求，申请缓存区失败)，终止

### 五、协程的作用

协程是一种用户级的轻量级线程，IO密集型应用: 多进程->多线程->事件驱动->协程

### 七、进程通信方法的特点以及使用场景

1. 管道：通过pipe函数创建，fd[0] 用于读，fd[1] 用于写。
2. FIFO命名管道：去除了管道只能在父子进程中使用的限制
3. 消息队列：消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 八、死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁

必要条件：
* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

解决策略：
* 鸵鸟策略：假装没发生。
* 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复
* 死锁预防：破坏互斥条件；破坏占有和等待条件；破坏不可抢占条件；破坏环路
* 死锁避免：安全状态检测；单个资源的银行家算法；多个资源的银行家算法

### 九、虚拟内存的作用，分页系统实现虚拟内存原理

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

### 十、页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法

https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83

### 十一、比较分页与分段的区别

* 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

* 地址空间的维度：分页是一维地址空间，分段是二维的。

* 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 十二、 分析静态链接的不足，以及动态链接的特点

静态库有以下两个问题：
* 当静态库更新时那么整个程序都要重新进行链接；
* 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

特点：
* 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
* 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

### 常见进程同步问题

生产者消费者问题，读者写者问题，哲学家进餐问题

### 进程调度算法的特点以及使用场景

1. 批处理系统（保证吞吐量和周转时间）：先来向服务；短作业优先；最短剩余时间优先三种方式
2. 交互式系统（快速响应）：时间片轮转（进程排成队列，每个进程执行一个时间片，用完后放入队尾重新排队）；优先级调度；多级反馈队列（多个时间片的队列，时间短的队列优先级高，进程进入队列未完成放入下一个队列，减少了时间片中超长进程的执行时间）
3. 实时系统：一个请求在一个确定时间内得到响应

# 网路

## 基础

### 一、各层协议的作用，以及 TCP/IP 协议的特点。

五层协议：
* 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
* 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
* 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
* 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

OSI：在应用层和传输层直接多了表示层和会话层

TCP/IP:它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

特点是不依赖任何特定计算机，不依赖特定网络传输硬件

### 二、以太网的特点，以及帧结构。

帧结构将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。

以太网是一种星型拓扑结构局域网。

以太网帧格式：

* 类型 ：标记上层使用的协议；
* 数据 ：长度在 46-1500 之间，如果太小则需要填充；
* FCS ：帧检验序列，使用的是 CRC 检验方法；

### 三、UDP与TCP比较，分析上层协议应该使用UDP还是TCP。

用户数据报协议UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

TCP: HTTP, FTP, Telnet, SMTP, POP3

UDP: DNS, SNMP, TFTP

区别：
* TCP是面向连接的，UDP是无连接的；
* TCP是可靠的，UDP是不可靠的；
* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
* TCP是面向字节流的，UDP是面向报文的；
* TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

### 四、 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。

TCP需要三次握手才能建立,而断开连接则需要四次握手

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.png)

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
5. B 收到 A 的确认后，连接建立。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

* A 发送连接释放报文，FIN=1。
* B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
* 当 B 不再需要连接时，发送连接释放报文，FIN=1。
* A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
* B 收到 A 的确认后释放连接。

四次挥手原因： 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT: 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。

这么做有两个理由：

1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 可靠传输原理，并设计可靠 UDP 协议

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

### TCP拥塞控制的作用，理解具体原理。

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

### DNS的端口号；TCP还是UDP；作为缓存、负载均衡。

### 集线器、交换机、路由器的作用，以及所属的网络层。

### IP 数据数据报常见字段的作用。

### ARP 协议的作用，以及维护 ARP 缓存的过程。

### ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。

## HTTP

### 一、GET和POST区别

* 作用：GET用于获取资源，而POST用于传输实体主体。
* 参数：GET方式提交的数据最多只能有1024字节，而POST则没有此限制。GET参数中如果存在中文字符由于URL只支持ASCII码所以需要先进行编码。
* 安全性：Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。所以，如果这些数据是中文数据而且是非敏感数据，那么使用get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用post为好。GET对数据进行查询，POST主要对数据进行增删改所以安全性GET更高。
* 幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。
* 可缓存：GET可以，POST不可以。

### 二、HTTP常见状态码

* 1×× : 请求处理中，请求已被接受，正在处理
* 2×× : 请求成功，请求被成功处理
* 200 OK
* 3×× : 重定向，要完成请求必须进行进一步处理
* 301 : 永久性转移
* 302 ：暂时性转移
* 304 ： 已缓存
* 4×× : 客户端错误，请求不合法
* 400：Bad Request,请求有语法问题
* 403：拒绝请求
* 404：客户端所访问的页面不存在
* 5×× : 服务器端错误，服务器不能处理合法请求
* 500 ：服务器内部错误
* 503 ： 服务不可用，稍等

### 三、Cookie, Session区别

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

Session：
1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

区别：
* 数据存放位置：cookie数据存放在客户的浏览器上，session数据放在服务器上
* 安全性：cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session
* 性能session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE
* 大小：单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。

### 四、Http, Https 区别 

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。

二者之间存在如下不同：

* 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
* 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
* 开销：Https通信需要证书，而证书一般需要向认证机构购买；
* HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

### 长连接与短连接原理以及使用场景，流水线。

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

* 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；
* 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。

流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。

### HTTP/1.1 的特性。

* 默认是长连接
* 支持流水线
* 支持同时打开多个 TCP 连接
* 支持虚拟主机
* 新增状态码 100
* 支持分块传输编码
* 新增缓存处理指令 max-age

### HTTP/1.x 的缺陷，以及 HTTP/2 的特点。

缺陷：

* 客户端需要使用多个连接才能实现并发和缩短延迟；
* 不会压缩请求和响应首部，从而导致不必要的网络流量；
* 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

### HTTP 与 FTP 的比较。

### 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。

# 数据库

## SQL

### 手写 SQL 语句，特别是连接查询与分组查询。

数据库创建与使用，创建表，修改表名，添加列，删除列，删除表；插入，插入检索数据，一个表插入另一个表；更新替换；删除；查询列（相同只出现一次，限制返回行数，分页查询）；排序；过滤；计算；分组，组内连接；内连接，自连接，自然连接，外连接，子查询，组合查询，交集；

### 主键，唯一索引区别

* 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
* 主键不允许为空值，唯一索引列允许空值；
* 一个表只能有一个主键，但是可以有多个唯一索引；
* 主键可以被其他表引用为外键，唯一索引列不可以；
* 主键本质是约束，值不为空，一个表只能建一个，其目的是检查数据的正确性；唯一索引本质是索引，值可为空，一个表能建一多个，其目的是实现数据查询的优化；

### 连接查询与子查询的比较。

### drop、delete、truncate 比较。

### 视图的作用，以及何时能更新视图。

### 理解存储过程、触发器等作用。

## Redis

### Redis数据结构

String(word, word), Hash, List（num, word）, Set（无序集合:word, num）, ZSet（有序集合）

* Hash底层结构：redis的哈希对象的底层存储可以使用ziplist（压缩列表）和hashtable

### 使用场景

计数器:可以对 String 进行自增自减运算，从而实现计数器功能。

缓存:将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

查找表:例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

消息队列:List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。

不过最好使用 Kafka、RabbitMQ 等消息中间件。

会话队列:可以使用 Redis 来统一存储多台应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

分布式锁:在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 集群与分布式

### 线程安全问题

### 字典和跳跃表原理分析

字典：dictht 是一个散列表结构，使用拉链法保存哈希冲突。

跳跃表：是有序集合的底层实现之一。

### 与 Memchached 的比较

### 事件驱动模型

### 事务原理

### 基于redis的分布式锁

https://segmentfault.com/a/1190000012919740

## MyBatis

### MyBatis中#{}和${}区别(*)

''#{}''是经过预编译的,是安全的,而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在sql注入。
只能''＄{}''的情况,order by、like 语句只能用＄{}了,用#{}会多个' '导致sql语句失效.此外动态拼接sql也要用''${}''
''#{}'' 这种取值是编译好SQL语句再取值, ${} 这种是取值以后再去编译SQL语句
重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的sql注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。


## 原理

### 数据库分布式锁

http://www.hollischuang.com/archives/1716

## mysql

### MySQL索引实现原理+几种索引

普通索引

B+ree
MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引.
InnoDB

InnoDB 的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。
因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以 唯一 标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引（普通索引）搜索需要 检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录.
几种索引

主键索引；
唯一索引；
普通索引；
联合索引；
全文索引。
辅助索引

https://www.cnblogs.com/xiangyangzhu/p/index.html
为什么用B+树

https://blog.csdn.net/xlgen157387/article/details/79450295
在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。
为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。
总的来说，B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。
B+树的插入删除

https://www.cnblogs.com/nullzx/p/8729425.html
为什么说B+树比B树更适合数据库索引

B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

### mysql行锁和表锁

https://blog.csdn.net/songwei128/article/details/43418343

# Linux

## cd 打开文件

* cd /root/Docements # 切换到目录/root/Docements
* cd ./path # 切换到当前目录下的path目录中，“.”表示当前目录
* cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录

## ls

* -l ：列出长数据串，包含文件的属性与权限数据等
* -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）
* -d ：仅列出目录本身，而不是列出目录的文件数据
* -h ：将文件容量以较易读的方式（GB，kB等）列出来
* -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来

## grep

命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等

* grep [-acinv] [--color=auto] '查找字符串' filename
* -a ：将binary文件以text文件的方式查找数据
* -c ：计算找到‘查找字符串’的次数
* -i ：忽略大小写的区别，即把大小写视为相同
* -v ：反向选择，即显示出没有‘查找字符串’内容的那一行

## find 寻找

find [PATH] [option] [action]

与时间有关的参数：

* -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
* -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
* -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
* -newer file : 列出比file还要新的文件名

## cp 复制

-a ：将文件的特性一起复制
-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行
-r ：递归持续复制，用于目录的复制行为
-u ：目标文件与源文件有差异时才会复制

## mv 移动

-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件已经存在，就会询问是否覆盖
-u ：若目标文件已经存在，且比目标文件新，才会更新

## rm 删除

-f ：就是force的意思，忽略不存在的文件，不会出现警告消息
-i ：互动模式，在删除前会询问用户是否操作
-r ：递归删除，最常用于目录删除，它是一个非常危险的参数

## ps 查看进程

-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出
ps aux # 查看系统所有的进程数据
ps ax # 查看不与terminal有关的所有进程
ps -lA # 查看系统所有的进程数据
ps axjf # 查看连同一部分进程树状态

## kill

该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID

1：SIGHUP，启动被终止的进程
2：SIGINT，相当于输入ctrl+c，中断一个程序的进行
9：SIGKILL，强制中断一个进程的进行
15：SIGTERM，以正常的结束进程方式来终止进程
17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行
killall

-i ：交互式的意思，若需要删除时，会询问用户
-e ：表示后面接的command name要一致，但command name不能超过15个字符
-I ：命令名称忽略大小写

例如：

killall -SIGHUP syslogd # 重新启动syslogd

## file

用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的

file filename
例如：
file ./test

## tar

-c ：新建打包文件
-t ：查看打包文件的内容含有哪些文件名
-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中
-j ：通过bzip2的支持进行压缩/解压缩
-z ：通过gzip的支持进行压缩/解压缩
-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来
-f filename ：filename为要处理的文件
-C dir ：指定压缩/解压缩的目录dir

常用tar命令
压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录

## cat

用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据

cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替
chgrp 改变文件所属所属用户组

chgrp [-R] dirname/filename
-R ：进行递归的持续对所有文件和子目录更改
例如：

chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users
chown 改变文件所有者

chmod 改变文件权限

chmod [-R] xyz 文件或目录
-R：进行递归的持续更改，即连同子目录下的所有文件都会更改

# Git

Git属于分布式版本控制系统，SVN是集中式版本控制系统。

工作流：
* git add files 把文件的修改添加到暂存区
* git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
* git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
* git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改

分支：
* git merge：分支合并

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/git.jpg)

# Java集合

HashMap的运行原理了，你肯定知道底层是一个数组+很多条链表实现的，那人家为什么要这样设计呢？想一想HashMap设计的初衷，想用key通过时间复杂度O（1）内拿到对应的Value，对吧，那现实中是会有hash冲突的，那有冲突咱们必须解决啊，所以链表就形成了，对吧？为什么要设计链表，知道了吧？因为要解决冲突，那链表的出现带来了一个问题，HashMap设计的初衷，想用key通过时间复杂度O（1）内拿到对应的Value，但是链表变长是不是就对时间复杂度O（1）相违背了呢（因为定位到一个数组之后，还需要遍历一下链表才能通过key拿到value）？于是乎有了链表长度达到8之后 会进行转红黑树，对吧？所以转红黑树这个事情其实 服务于HashMap设计初衷：用key通过时间复杂度O（1）内拿到对应的Value。这些东西可能需要看一下源码，你才能理解得更清楚。比如java的锁，synchronized 为什么反编译后 只有一个moniter enter，但是却有两个moiter exit？