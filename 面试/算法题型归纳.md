# 命令

## 字符串

### 查找

查找字符串str中第x位置的字符：`char s = str.charAt(x);`

查找字符串str中第a到b-1位置的字符串：`String s = str.substring(a, b);`

### 替换

替换字符串str中第x位置的字符为b：`str.setcharAt(x, 'b');`

字符串整体转换成char数组：`str.toCharArray();`

### 转换

字符串转换成标准的string：`str.toString();`

字符串转换成Integer：`Integer.valueOf(str)`

### 注意事项

字符串由于不是基本数据类型所以返回长度是方法：length();

字符串中单引号和双引号的区别在于，单引号内部内容是一个char，只能是一个字符，双引号内部是字符串可以是多个字符。

字符串在转成int时会直接变成数，字符在转成int时会ascii码换算。

## List，Stack

### 添加

添加都使用add()方法

### 弹出

栈弹出使用pop()方法

### 栈顶

读取栈顶数使用peek()方法

## Map

### 添加

添加使用put(key, value);

### 提取

提取value使用get(key);

## Queue

### 添加

add()/offer():调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false

### 移除

poll()/remove():poll() 方法在用空集合调用时只是返回 null

### 队头

element()/peek()：element() 抛出一个异常，而 peek() 返回 null。

# 算法

## 搜索

### 查重

#### 3.数组中重复的数字

[Nowcode](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

###### 题目

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
```
Input:
{2, 3, 1, 0, 2, 5}

Output:
true, 2
```
###### 思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：
```java
public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null || length < 0) return false;
        for(int i=0; i<length; i++){
            while(numbers[i] != i){
                if(numbers[i] == numbers[numbers[i]]){
                    duplication[0] = numbers[i];
                    return true;
                }
                swap(numbers, i, numbers[i]);
            }
        }
        return false;
    }
    public void swap(int num[], int i, int j){
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
}
```

#### 4.二维数组中的查找

[Nowcode](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

##### 思路

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```

### 查找

#### 11.旋转数组的最小数字

[NowCode](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 

##### 思路

基本思路：其实当数组中后者比前者小的时候即最小数字，但是遍历数组复杂度为O(n)

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len<=1)return array[0];
        for(int i=0; i<len-1; i++){
            if(array[i] > array[i+1]){
                return array[i+1];
            }
        }
        return array[len-1];
    }
}
```

二分查找：将数组对半分可以得到一个非递减的数组和一个包含最小元素的数组。由于非递减数组第一个元素肯定小于最后一个元素，所以当a[m]<=a[h]则[m,h]区间是非递减数组，否则[m+1,h]是旋转数组，以此重复复杂度为O(logN)

```java
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len == 0)return 0;
        int l = 0, h = len - 1;
        while(l < h){
            int mid = l + (h - l) / 2;
            if(array[m] <= array[h]])//[m,h]非递减数组
                h = m;
            else
                l = m + 1;
        }
        return array[l];
    }
}
```

#### 29.顺时针打印矩阵

[NowCode](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

##### 思路

回字行打印，注意起始位置和是否存在下和左即可

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> list = new ArrayList<>();
        int left = 0, up = 0;
        int right = matrix[0].length - 1;
        int down = matrix.length-1;
        while(left <= right && up <= down){
            for(int i=left; i<=right; i++){
                list.add(matrix[up][i]);
            }
            //打印了一整行所以up要+1
            for(int j=up+1; j<=down; j++){
                list.add(matrix[j][right]);
            }
            //判断下和左是否还有行，列
            if(up != down){
                for(int i=right-1; i>=left; i--){
                    list.add(matrix[down][i]);
                }
            }
            //排除上打印过的一行所以j>up不用等号
            if(left != right){
                for(int j=down-1; j>up; j--){
                    list.add(matrix[j][left]);
                }
            }
            left++; right--; up++; down--;
        }
        return list;
    }
}
```

#### 39. 数组中出现次数超过一半的数字

[NowCode](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163)

##### 题目

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

##### 思路

用cnt来统计一个元素出现的次数，当遍历到的元素和统计元素相等就cnt++，不同就cnt--，当cnt==0说明前i个元素没有超过当前一半的元素。

由于奇数个数有可能最后一个数留下来，所以最后需要遍历数组一遍去验证。

```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int cnt = 1;
        int tmp = array[0];
        for(int i=1; i<array.length; i++){
            if(cnt == 0){
                //cnt = 0;
                tmp = array[i];
            }
            if(array[i] == tmp)
                cnt++;
            else
                cnt--;
        }
        for(int num : array){
            if(num == tmp)
                cnt++;
        }
        return cnt > array.length/2 ? tmp : 0;
    }
}
```

#### 40.最小的K个数

[NowCode](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

##### 思路

快排

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (k > nums.length || k <= 0)
        return ret;
    findKthSmallest(nums, k - 1);
    /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */
    for (int i = 0; i < k; i++)
        ret.add(nums[i]);
    return ret;
}

public void findKthSmallest(int[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j == k)
            break;
        if (j > k)
            h = j - 1;
        else
            l = j + 1;
    }
}

private int partition(int[] nums, int l, int h) {
    int p = nums[l];     /* 切分元素 */
    int i = l, j = h + 1;
    while (true) {
        while (i != h && nums[++i] < p) ;
        while (j != l && nums[--j] > p) ;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

#### 41.2. 字符流中第一个不重复的字符

[NowCode](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

##### 思路

用一个数组记录每个进入队列的字符的次数，每次判断队列头是否大于1，如果大于1则移除。

```java
private int[] cnts = new int[256];
private Queue<Character> queue = new LinkedList<>();

public void Insert(char ch) {
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() && cnts[queue.peek()] > 1)
        queue.poll();
}

public char FirstAppearingOnce() {
    return queue.isEmpty() ? '#' : queue.peek();
}

```

#### 42.连续子数组的最大和

[NowCode](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。

##### 思路

从左往右累加，当为负值即代表可以重新开始，每次累加比较最大值，存储出最大的和。

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        int sum = 0;
        int res = Integer.MIN_VALUE;
        for(int i=0; i<array.length; i++){
            sum = sum >= 0 ? sum+array[i] : array[i];
            res = Math.max(res, sum);
        }
        return res;
    }
}
```

#### 43. 从1到n整数中1出现的次数

[NowCode](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

求出任意非负整数区间中1出现的次数

##### 思路

设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析 

根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i 

当i表示百位，且百位对应的数>=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1 

当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1 

当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30） 

综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1 

之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1)

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m <= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}

```

#### 45. 把数组排成最小的数

[NowCode](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

##### 思路

两个数a和b比较时，就是ab和ba连接在一起比较，如果ab>ba着ab交换位置。

a依次和所有数比较，比较完后b再依次。

```java
public class Solution {
    public String PrintMinNumber(int [] numbers) {
        String str = "";
        for (int i=0; i<numbers.length; i++){
            for (int j=i+1; j<numbers.length; j++){
                int a = Integer.valueOf(numbers[i]+""+numbers[j]);
                int b = Integer.valueOf(numbers[j]+""+numbers[i]);
                if (a > b){
                    int t = numbers[i];
                    numbers[i] = numbers[j];
                    numbers[j] = t;
                }
                 
            }
        }
        for (int i = 0; i < numbers.length; i++) {
            str += String.valueOf(numbers[i]);
        }
        return str;
    }
}
```

#### 53. 数字在排序组中出现的次数

[NowCode](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3
Output:
4

##### 思路

```java
public int GetNumberOfK(int[] nums, int K) {
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return (first == nums.length || nums[first] != K) ? 0 : last - first;
}

private int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= K)
            h = m;
        else
            l = m + 1;
    }
    return l;
}
```

#### 57.1. 和为S的两个数字

[NowCode](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。

##### 思路

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> res = new ArrayList<>();
        int i = 0, j = array.length-1;
        while(i < j){
            if(array[i] + array[j] == sum){
                res.add(array[i]);
                res.add(array[j]);
                return res;
            }else if(array[i] + array[j] >= sum){
                j--;
            }else if(array[i] + array[j] <= sum){
                i++;
            }
        }
        return res;
    }
}
```

#### 57.2. 和为s的连续正数序列

[NowCode](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输出所有和为 S 的连续正数序列。

例如和为 100 的连续序列有：

```
[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
```

##### 思路

双循环累加，当和等于时就把该list加入到结果list中，否则进行下一轮循环。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
       ArrayList<ArrayList<Integer> > res = new ArrayList<>();
        for(int i=1; i<=sum/2; i++){
            int num = 0;
            ArrayList<Integer> list = new ArrayList<>();
            for(int j=i; j<sum; j++){
               num +=j;
               list.add(j);
               if(num == sum){
                   res.add(list);
                   break;
               }
                if(num > sum){
                    break;
                }
           }
       }
        return res;
    }
}
```

避免双重for循环可以使用while，当和大于sum时sum减去start并加1，当小于时end加1并加到和中，相等时把start到end的数放入列表的同时sum减去start并加1，end加1。

```java
public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    int start = 1, end = 2;
    int curSum = 3;
    while (end < sum) {
        if (curSum > sum) {
            curSum -= start;
            start++;
        } else if (curSum < sum) {
            end++;
            curSum += end;
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i = start; i <= end; i++)
                list.add(i);
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        }
    }
    return ret;
}

```

#### 59.滑动窗口的最大值

[NowCode](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。

##### 思路

左右值范围循环

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        int left = 0, right = size;
        int len = num.length;
        ArrayList<Integer> res = new ArrayList<>();
        if(len < size || size < 1)
            return res;
        for(int i = 0; i < len - size + 1; i++){
            int max = num[i];
            for(int j = i; j < i + size; j++){
                
                if(num[j] > max){
                    max = num[j];
                }
            }
            res.add(max);
        }
        return res;
    }
}
```

最大顶堆

```java
public ArrayList<Integer> maxInWindows(int[] num, int size) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (size > num.length || size < 1)
        return ret;
    PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> o2 - o1);  /* 大顶堆 */
    for (int i = 0; i < size; i++)
        heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 0, j = i + size; j < num.length; i++, j++) {            /* 维护一个大小为 size 的大顶堆 */
        heap.remove(num[i]);
        heap.add(num[j]);
        ret.add(heap.peek());
    }
    return ret;
}
```

#### 61. 扑克牌顺子

[NowCode](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。

##### 思路

```java
import java.util.*;
public class Solution {
    public boolean isContinuous(int [] numbers) {
        int len = numbers.length;
        if(len <1)
            return false;
        Arrays.sort(numbers);
        int cnt = 0, zero = 0;
        //记录0的个数
        for(int i = 0; i< len; i++){
            if(numbers[i] == 0){
                zero++;
            }else{
                break;
            }
        }
        for(int i = zero; i < len - 1; i++){
            //记录前后数差值
            cnt += numbers[i+1] - numbers[i] - 1;
            //如果前后相等即fasle
            if(numbers[i] == numbers[i+1]){
                return false;
            }
        }
        if(cnt <= zero){
            return true;
        }else{
            return false;
        }
    }
}
```



### 交换

#### 21.调整数组顺序使奇数位于偶数前面

[NowCode](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

##### 思路

1.创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。

```java
public void reOrderArray(int[] nums) {
    // 奇数个数
    int oddCnt = 0;
    for (int x : nums)
        if (!isEven(x))
            oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1)
            nums[i++] = num;
        else
            nums[j++] = num;
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}
```

2.使用冒泡思想，每次找到偶数且右边是奇数就交换。时间复杂度 O(N2)，空间复杂度 O(1)，时间换空间。

```java
public void reOrderArray(int[] nums) {
    int N = nums.length;
    for (int i = N - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (isEven(nums[j]) && !isEven(nums[j + 1])) {
                swap(nums, j, j + 1);
            }
        }
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```



### 位运算

#### 15.二进制个数

[NowCode](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个整数，输出该数二进制表示中 1 的个数。

##### 思路

n&(n-1):用于去除二进制数最后一位1。

```java
public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &= (n - 1);
    }
    return cnt;
}
```

#### 56. 数组中只出现一次的数字

[NowCode](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

##### 思路

位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。

diff &= -diff得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

通过位与把和不同那位相同的放在num1中，不同的放在num2中，即两个数组里面各有一个单独的数，再通过异或抵消，只剩下两个单独的数。

```java
public void FindNumsAppearOnce(int[] nums, int num1[], int num2[]) {
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    diff &= -diff;
    for (int num : nums) {
        if ((num & diff) == 0)
            num1[0] ^= num;
        else
            num2[0] ^= num;
    }
}
```

#### 65.不用加减乘除做加法

[NowCode](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。

##### 思路

a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。

递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```java
public int Add(int a, int b) {
    return b == 0 ? a : Add(a ^ b, (a & b) << 1);
}
```

## 字符串

### 替换

#### 5.替换空格

[Nowcode](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

将一个字符串中的空格替换成 "%20"。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

##### 思路

首先，需要遍历整个字符串每个空格就在字符串末尾添加两个空格。

其次，设置两个指针P1, P2，P1指向原字符串末尾，P2指向添加完空格以后的字符串末尾。

最后，P1指针从右往左查找空格，发现空格就P2添加字符，没发现空格就把当前的字符移到P2位置。

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	int p1 = str.length() - 1;
        for(int i=0; i<=p1; i++){
            if(str.charAt(i) == ' '){
                str.append("  ");
            }
        }
        int p2 = str.length() - 1;
        while(p1>=0 && p2 > p1){
            char s = str.charAt(p1--);
            if(s == ' '){
                str.setCharAt(p2--, '0');
                str.setCharAt(p2--, '2');
                str.setCharAt(p2--, '%');
            }else{
                str.setCharAt(p2--, s);
            }
        }
        return str.toString();
    }
}
```

#### 58.1. 翻转单词顺序列

[NowCode](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

```
Input:
"I am a student."
Output:
"student. a am I"
```

##### 思路

题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。

正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。

```java
public class Solution {
    public String ReverseSentence(String str) {
        int len = str.length();
        char[] ch = str.toCharArray();
        int left = 0, right = 0;
        while(right <= len){
            if(right == len || ch[right] == ' '){
                reverse(ch, left, right-1);
                left = right + 1;
            }
            right++;
        }
        reverse(ch, 0, len-1);
        return new String(ch);
    }
    public void reverse(char[] ch, int left, int right){
        while(left < right){
            swap(ch, left++, right--);
        }
    }
    public void swap(char[] ch, int i, int j){
        char tmp = ch[i];
        ch[i] = ch[j];
        ch[j] = tmp;
    }
}
```

#### 58.2.左旋转字符串

[NowCode](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

```java
Input:
S="abcXYZdef"
K=3

Output:
"XYZdefabc"
```

##### 思路

先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。

```java
public class Solution {
    public String LeftRotateString(String str,int n) {
        int len = str.length();
        if(len == 0){
            return "";
        }
        char[] ch = str.toCharArray();
        reverse(ch, 0, n-1);
        reverse(ch, n, len-1);
        reverse(ch, 0, len-1);
        return new String(ch);
    }
    public void reverse(char[] ch, int l, int r){
        while(l < r){
            swap(ch, l++, r--);
        }
    }
    public void swap(char[] ch, int l, int r){
        char tmp = ch[l];
        ch[l] = ch[r];
        ch[r] = tmp;
    }
}
```



### 对比

#### 19.正则表达式匹配

[NowCode](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab/*ac/*a"匹配，但是与"aa.a"和"ab*a"均不匹配

##### 思路

```java
public class Solution {
    public boolean match(char[] str, char[] pattern) {
    if (str == null || pattern == null) {
        return false;
    }
    int strIndex = 0;
    int patternIndex = 0;
    return matchCore(str, strIndex, pattern, patternIndex);
}
  
public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
    //有效性检验：str到尾，pattern到尾，匹配成功
    if (strIndex == str.length && patternIndex == pattern.length) {
        return true;
    }
    //pattern先到尾，匹配失败
    if (strIndex != str.length && patternIndex == pattern.length) {
        return false;
    }
    //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
    if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
            return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
        } else {
            return matchCore(str, strIndex, pattern, patternIndex + 2);
        }
    }
    //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
    if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
        return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
    }
    return false;
    }
```
#### 20.表示数值的字符串

[NowCode](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

##### 思路

使用正则表达式进行匹配

[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1 次
+   ： 重复 1 ~ n 次
*   ： 重复 0 ~ n 次
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
```

​```java
public boolean isNumeric(char[] str) {
    if (str == null || str.length == 0)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

### 排列

#### 38.字符串的排列

[NowCode](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7)

##### 题目

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

##### 思路         

    1. 第一次进到这里是ch=['a','b','c'],list=[],i=0，我称为状态A ，即初始状态。那么j=0，swap(ch,0,0)，就是['a','b','c']，进入递归，自己调自己，只是i为1，交换(0,0)位置之后的状态我称为状态B。i不等于2，来到这里，j=1，执行第一个swap(ch,1,1)，这个状态我称为 状态C1 ,再进入fun函数，此时标记为T1，i为2，那么这时就进入上一个if，将"abc"放进list中此时结果集为["abc"]
    
    2.执行完list.add之后，遇到return，回退到T1处，接下来执行第二个swap(ch,1,1)，状态C1又恢复为状态B
            ``//恢复完之后，继续执行for循环，此时j=2,那么swap(ch,1,2),得到"acb"，这个状态我称为C2,然后执行fun，此时标记为T2,发现i+1=2,所以也被添加进结果集，此时return回退到T2处往下执行
            ``/////////////-------》此时结果集为["abc","acb"]
            ``//然后执行第二个swap(ch,1,2)，状态C2回归状态B,然后状态B的for循环退出回到状态A
            
            ``//             a|b|c(状态A)
            ``//               |
            ``//               |swap(0,0)
            ``//               |
            ``//             a|b|c(状态B)
            ``//             /  \
            ``//   swap(1,1)/    \swap(1,2)  (状态C1和状态C2)
            ``//           /      \
            ``//         a|b|c   a|c|b
            
            ``//3.回到状态A之后，继续for循环，j=1,即swap(ch,0,1)，即"bac",这个状态可以再次叫做状态A,下面的步骤同上
            ``/////////////-------》此时结果集为["abc","acb","bac","bca"]
            
            ``//             a|b|c(状态A)
            ``//               |
            ``//               |swap(0,1)
            ``//               |
            ``//             b|a|c(状态B)
            ``//             /  \
            ``//   swap(1,1)/    \swap(1,2)  (状态C1和状态C2)
            ``//           /      \
            ``//         b|a|c   b|c|a
            
            ``//4.再继续for循环，j=2,即swap(ch,0,2)，即"cab",这个状态可以再次叫做状态A，下面的步骤同上
            ``/////////////-------》此时结果集为["abc","acb","bac","bca","cab","cba"]
            
            ``//             a|b|c(状态A)
            ``//               |
            ``//               |swap(0,2)
            ``//               |
            ``//             c|b|a(状态B)
            ``//             /  \
            ``//   swap(1,1)/    \swap(1,2)  (状态C1和状态C2)
            ``//           /      \
            ``//         c|b|a   c|a|b
            
            ``//5.最后退出for循环，结束。
```java
import java.util.List;
import java.util.Collections;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        List<String> resultList = new ArrayList<>();
        if(str.length() == 0)
            return (ArrayList)resultList;
        //递归的初始值为（str数组，空的list，初始下标0）
        fun(str.toCharArray(),resultList,0);
        Collections.sort(resultList);
        return (ArrayList)resultList;
    }
    
    private void fun(char[] ch,List<String> list,int i){
        //这是递归的终止条件，就是i下标已经移到char数组的末尾的时候，考虑添加这一组字符串进入结果集中
        if(i == ch.length-1){
            //判断一下是否重复
            if(!list.contains(new String(ch))){
                list.add(new String(ch));
                return;
            }
        }else{
            
            for(int j=i;j<ch.length;j++){
                swap(ch,i,j);
                fun(ch,list,i+1);
                swap(ch,i,j);
            }
        }
    }
    
    //交换数组的两个下标的元素
    private void swap(char[] str, int i, int j) {
            if (i != j) {
                char t = str[i];
                str[i] = str[j];
                str[j] = t;
            }
        }
    }
```

### 查找

#### 50.第一个只出现一次的字符位置

[NowCode](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。

##### 思路

使用map记录每个字母的次数，再遍历数组输出第一个为1的数

```java
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        int[] cnt = new int[256];
        for(int i=0; i<str.length(); i++){
            cnt[str.charAt(i)]++;
        }
        for(int i=0; i<str.length(); i++){
            if(cnt[str.charAt(i)] == 1){
                return i;
            }
        }
        return -1;
    }
}
```



## 动态规划

### 斐波那契

#### 10.1.斐波那契数列 

[NowCode](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

求斐波那契数列的第 n 项，n <= 39。

##### 思路

基本思路：按照递归思考，即f(n)=f(n+1)+f(n+2)

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

动态规划：由于递归会频繁重复调用导致栈溢出，动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        int[] res = new int[n+1];
        res[0] = 0;
        res[1] = 1;
        for(int i=2; i<=n; i++){
            res[i] = res[i-1] + res[i-2];
        }
        return res[n];
    }
}
```

动态规划改良：考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```

#### 10.2.矩形覆盖

[NowCode](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？

##### 思路

当n为1时只有一种方法，当n为2时，有两种方法，要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形。即f(n)=f(n-1)+f(n-2)当n>=2时。

```java
public class Solution {
    public int RectCover(int target) {//递归版
        if(target <= 2)
            return target;
        return RectCover(target-1)+RectCover(target-2);
    }
}

public int RectCover(int n) {//动态规划版
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i <= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

#### 10.3.跳台阶

[NowCode](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

##### 思路

与斐波那契数列和矩形覆盖类似。

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target <= 2)
            return target;
        int pre1 = 1, pre2 = 2;
        int res = 0;
        for(int i=3; i <= target; i++){
            res = pre1 + pre2;
            pre1 = pre2;
            pre2 = res;
        }
        return res;
    }
}
```

#### 10.4.变态跳台阶

[NowCode](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

##### 思路

动态规划：

当target<2，f(0)=0, f(1)=1

当target>=2, f(0)=1, f(1)=1, f(2)=f(0)+f(1), f(3)=f(0)+f(1)+f(2)......

```java
public class Solution {
    public int JumpFloorII(int target) {
        int[] f = new int[target+1];
        if(target == 0) return 0;
        f[0] = 1;
        f[1] = 1;
        for(int i=2; i<=target; i++){
            for(int j=0; j<i; j++){
                f[i] += f[j];
            }
        }
        return f[target];
    }
}
```

#### 46.把数字翻译成字符串

[LeetCode](https://leetcode-cn.com/problems/decode-ways/submissions/)

##### 题目

给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

##### 思路

f(n)=f(n-1)+f(n-2)

其中n-1的数不能等于0，n-2需要符合大于等于10小于等于26

```java
class Solution {
    public int numDecodings(String s) {
        int len = s.length();
        if(len == 0){
            return 0;
        }
        int[] res = new int[len+1];
        res[0] = 1;
        res[1] = s.charAt(0) == '0' ? 0 : 1;
        for(int i=2; i<=len; i++){
            int one = Integer.valueOf(s.substring(i-1, i));
            if(one != 0){
                res[i] += res[i-1];
            }
            int two = Integer.valueOf(s.substring(i-2, i));
            if(two <= 26 && two >= 10){
                res[i] += res[i-2];
            }
        }
        return res[len];
    }
}
```

#### 47.礼物的最大价值

[NowCode](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

##### 题目

在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

##### 思路

由于当前值只和上左有关联，所以只需要建立一个和棋盘一样的矩阵，取左和上中最大值与当前值相加即可。

```java
import java.util.*;

public class Bonus {
    public int getMost(int[][] board) {
        int row = board.length;
        int col = board[0].length;
        int[][] res = new int[row][col];
        res[0][0] = board[0][0];
        for(int i=1; i<col; i++){
            res[0][i] += res[0][i-1] + board[0][i];
        }
        for(int i=1; i<row; i++){
            res[i][0] += res[i-1][0] + board[i][0];
        }
        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                res[i][j] = Math.max(res[i-1][j], res[i][j-1])+board[i][j];
            }
        }
        return res[row-1][col-1];
    }
```

#### 49.丑数

[NowCode](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

##### 思路

```java
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index <= 6){
            return index;
        }
        int[] res = new int[index];
        res[0] = 1;
        int i2 = 0, i3 = 0, i5 =  0;
        for(int i = 1; i < index; i++){
            int next2 = res[i2] * 2, next3 = res[i3] * 3, next5 = res[i5] * 5;
            res[i] = Math.min(next2, Math.min(next3, next5));
            if(res[i] == next2){
                i2++;
            }
            if(res[i] == next3){
                i3++;
            }
            if(res[i] == next5){
                i5++;
            }
        }
        return res[index-1];
    }
}
```

#### 62. 圆圈中最后剩下的数

[NowCode](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。

##### 思路

使用数组模拟标记

```java
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n<1 || m<1) return -1;
        int[] array = new int[n];
        int count = n, step=0, i=-1;
        while(count>0){
            i++;
            if(i == n) i = 0;//走到最后归0从头开始
            if(array[i] == -1)continue;
            step++;
            if(step == m){
                step = 0;//重新记步
                array[i] = -1;//对应下标-1
                count--;//找到一个总数减一
            }
        }
        return i;
    }
}
```

约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。

```java
public int LastRemaining_Solution(int n, int m) {
    if (n == 0)     /* 特殊输入的处理 */
        return -1;
    if (n == 1)     /* 递归返回条件 */
        return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}

```



### 回朔

#### 12.矩阵中的路径

[NowCode](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

##### 思路

回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。

```java
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        boolean[] walked = new boolean[matrix.length];
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                if(judge(matrix, i, j, rows, cols, str, walked, 0))
                    return true;
            }
        }
        return false;
    }
    private boolean judge(char[] matrix, int i, int j, int rows, int cols, char[] str, boolean[] walked, int k){
        //寻找失败条件
        int index = i*cols+j;
        if(i<0 || j<0 || i>=rows || j>=cols || matrix[index] != str[k] || walked[index])
            return false;
        if(k == str.length-1)
            return true;
        walked[index] = true;
        if(judge(matrix, i-1, j, rows, cols, str, walked, k+1)||
            judge(matrix, i+1, j, rows, cols, str, walked, k+1)||
            judge(matrix, i, j+1, rows, cols, str, walked, k+1)||
            judge(matrix, i, j-1, rows, cols, str, walked, k+1))
            return true;
        //走到此代表此路不通
        walked[index] = false;
        return false;
    }

}
```

#### 13.机器人

[NowCode](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

##### 思路

与路径回朔相似，区别在于return的值，每次下一步需要记数。

```java
public class Solution {
    public int movingCount(int threshold, int rows, int cols)
    {
        boolean[][] walked = new boolean[rows][cols];
        return find(threshold, rows, cols, 0, 0, walked);
    }
    public int find(int threshold, int rows, int cols, int i, int j, boolean[][] walked){
        if(i<0 || j<0 || i>=rows || j>=cols || walked[i][j] || bitsum(i)+bitsum(j)>threshold)
            return 0;
        walked[i][j] = true;
        return find(threshold, rows, cols, i+1, j, walked) +
          find(threshold, rows, cols, i-1, j, walked)+
          find(threshold, rows, cols, i, j+1, walked)+
          find(threshold, rows, cols, i, j-1, walked)+1;
    }
    public int bitsum(int i){
        int sum =0;
        while(i != 0){
            sum += i%10;
            i /= 10;
        }
        return sum;
    }
}
```

#### 17.打印从1到最大数n

##### 题目

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

##### 思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```



### 贪心

#### 14.剪绳子

[LeetCode](https://leetcode-cn.com/problems/integer-break/)

##### 题目

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

##### 思路

贪心：如果分解式含1，则乘积越来越小；如果分解式含2，2(n-2)>n，当n>4时；如果分解式含3，3(n-3)>n，当n>4.5时；如果分解式含4不如2,；如果含5不如2和3；所以尽可能分解成3，如果剩1则分解成两个2。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

动态规划：dp[i]代表i分割之后得到的乘积最大的元素，每次需要和之前所有的状态进行比较，状态转移方程式为dp[i]=max(dp[i],(i-j)*max(dp[j],j))，因为dp[j]未曾包括不分割当前元素乘积最大的情况，因此需要加以考虑.

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

#### 63. 股票的最大利润

[LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/)

##### 题目

可以有一次买入和一次卖出，买入必须在前。求最大收益。

##### 思路

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。所以存储一个最大值和一个最底值，每轮对比。

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int soFarMin = prices[0];
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        soFarMin = Math.min(soFarMin, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);
    }
    return maxProfit;
}
```



## 实现函数

### Math.power()

#### 16.数值的整数次方

[NowCode](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

##### 思路

递归求解，每次次方减半

```java
public double Power(double base, int exponent) {
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;
    boolean isNegative = false;
    if (exponent < 0) {
        exponent = -exponent;
        isNegative = true;
    }
    double pow = Power(base * base, exponent / 2);
    if (exponent % 2 != 0)
        pow = pow * base;
    return isNegative ? 1 / pow : pow;
}
```

#### 64. 求1+2+3+...+n

[NowCode](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。

##### 思路

利用递归进行计算，利用&&具有短路原则代替判断语句

```java
public int Sum_Solution(int n) {
    int sum = n;
    boolean b = (n > 0) && ((sum += Sum_Solution(n - 1)) > 0);
    return sum;
}
```



# 数据结构

## 链表

### 反转

#### 6.从尾到头打印链表

[Nowcode](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

##### 思路

一、使用栈：把链表放入栈中再依次pop到list中

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        Stack<Integer> stack = new Stack<>();
        while(listNode != null){
            stack.add(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> list = new ArrayList<>();
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
}
```

二、头插法：新建一个头固定的链表，每次往头后面插入一个数，直到插满。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode head = new ListNode(0);
        while(listNode != null){
            ListNode listnext = listNode.next;
            listNode.next = head.next;
            head.next = listNode;
            listNode = listnext;
        }
        ArrayList list = new ArrayList<>();
        head = head.next;
        while(head != null){
            list.add(head.val);
            head = head.next;
        }
        return list;
    }
}
```

三、递归：要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。

```java
import java.util.ArrayList;
public class Solution {
    ArrayList list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //ArrayList list = new ArrayList<>();
        if(listNode != null){
            //list.addAll(printListFromTailToHead(listNode.next));
            printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

#### 24.反转链表

[NowCode](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，反转链表后，输出新链表的表头。

##### 思路

与上题思路相似，分递归和头插法

递归：

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

迭代：

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```



### 删除

#### 18.1.在 O(1) 时间内删除链表结点

##### 题目

已知即将要删的节点。

##### 思路

首先分两种情况：1.要删除的节点不在末尾；2.要删除的节点在末尾

1.将删除节点的next节点复制到删除节点上，删除next节点即可。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if(head == null || tobeDelete == null)
        return null;
    //删除节点不在末尾
    if(tobeDelete.next != null){
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    }else{
        if(head == tobeDelete)//只有一个节点
            return null;
        else{
            ListNode node = head;
            while(node.next != tobeDelete){
                node = node.next;
            }
            node.next = null;
        }
    }
    return head;
}
```

#### 18.2删除链表中的重复结点
*[NowCode](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)*

##### 题目

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

##### 思路

使用两个结点，preNode指向新的头结点，walkNode指向第一个结点。

当walk不是最后结点时：如果walk和下一个结点相同：如果pre和walk相邻则pre=walk，如果不相邻则pre指向walk的下一个结点。

当walk是最后结点时：如果pre和walk相邻则pre=walk，如果不相邻则pre指向walk的下一个结点。

每次判断完walk向前移动。

```java
public ListNode printListFromTailToHead(ListNode pHead) {
    ListNode newhead=new ListNode(0);//解决删除头结点的可能，例如{1，1，1，1，2}
    newhead.next=pHead;
    ListNode pre=newhead;
    ListNode walkNode=newhead.next;
    while(walkNode!=null){
        if(walkNode.next!=null){
            if(walkNode.next.val!=walkNode.val){
                if(pre.next!=walkNode){
                    pre.next=walkNode.next;    
                }else{
                    pre=walkNode;
                }
            }
        }else{//如果walkNode指向最后一个结点
           if(pre.next!=walkNode){
                pre.next=walkNode.next;    
           }else{
                pre=walkNode;
           }
        }
        walkNode=walkNode.next;    
    }
    return newhead.next;    
}
```

### 查找

#### 22.链表中倒数第K个节点

[Nowcode](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，输出该链表中倒数第k个结点。

##### 思路

设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。

```java
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head == null)
            return null;
        ListNode node1 = head;
        while(node1 != null && k-->0){
            node1 = node1.next;
        }
        if(k>0)
            return null;
        ListNode node2 = head;
        while(node1 != null){
            node1 = node1.next;
            node2 = node2.next;
        }
        return node2;
    }
}
```



#### 23.链表中环的入口结点

[NodeCode](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

##### 思路

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在的 z位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return null;
    ListNode slow = pHead, fast = pHead;
    do {
        fast = fast.next.next;
        slow = slow.next;
    } while (slow != fast);
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
```

#### 52. 两个链表的第一个公共结点

[NowCode](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

两个链表，寻找第一个公共结点的地方

##### 思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```java
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while(l1 != l2){
            l1 = (l1 == null) ? pHead2 : l1.next;
            l2 = (l2 == null) ? pHead1 : l2.next;
        }
        return l1;
    }
}
```



### 合并

#### 25.合并两个排序的链表

[NodeCode](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入两个单调递增的链表，输出两个链表合成后的链表

##### 思路

迭代：用一个新的链表，每次比较两个链表大小，把小的与新链表连接。

```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode res = new ListNode(0);
        ListNode node = res; 
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                node.next = list1;
                list1 = list1.next;
            }else{
                node.next = list2;
                list2 = list2.next;
            }
            node = node.next;
        }
        if(list1 != null){
            node.next = list1;
        }
        if(list2 != null){
            node.next = list2;
        }
        return res.next;
    }
}
```

递归:拆解成链表1和2谁小就next递归谁。

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```



## 二叉树

### 构建

#### 7.重建二叉树

[NowCode](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

##### 思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

* 中序其实只是用来判断序列中左右节点的个数，然后通过对前序左右节点分割，递归来实现二叉树的构建。

```java
import java.util.*;
public class Solution {
    private Map<Integer, Integer> indexWhere = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        for(int i=0; i<in.length; i++){
            indexWhere.put(in[i], i);
        }
        return reConstructBinaryTree(pre, 0, pre.length-1, 0);
    }
    private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL){
        if(preL > preR)
            return null;
        TreeNode node = new TreeNode(pre[preL]);
        int index = indexWhere.get(node.val);
        int leftSize = index - inL;
        node.left = reConstructBinaryTree(pre, preL+1, preL+leftSize, inL);
        node.right = reConstructBinaryTree(pre, preL+leftSize+1, preR, index+1);
        return node;
    }
}
```

#### 27.二叉树的镜像

[NowCode](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

操作给定的二叉树，将其变换为源二叉树的镜像。

##### 思路

类似数组交换，只需要按中序进行交换即可。

```java
public class Solution {
    public void Mirror(TreeNode root) {
        if(root == null)
            return;
        Swap(root);
        Mirror(root.left);
        Mirror(root.right);
    }
    public void Swap(TreeNode root){
        TreeNode t = root.right;
        root.right = root.left;
        root.left = t;
    }
}
```

#### 28.对称的二叉树

[NowCode](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

##### 思路

中序遍历，判断方法首先判断是否都为空，再判断是否有空，最后判断是否不等。

```java
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot == null)
            return true;
        return compareTree(pRoot.left, pRoot.right);
    }
    boolean compareTree(TreeNode p1, TreeNode p2){
        if(p1 == null && p2 == null)
            return true;
        if(p1 == null || p2 == null)
            return false;
        if(p1.val != p2.val)
            return false;
        return compareTree(p1.left, p2.right) && compareTree(p1.right, p2.left);
    }
}
```

#### 35.复杂链表的复制

[NowCode](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。

##### 思路

1.每个节点后面插入复制的节点。2.对复制节点的random进行赋值。3.拆分

```java
public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null)
        return null;
    // 插入新节点
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode clone = new RandomListNode(cur.label);
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next;
    }
    // 建立 random 链接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null)
            clone.random = cur.random.next;
        cur = clone.next;
    }
    // 拆分
    cur = pHead;
    RandomListNode pCloneHead = pHead.next;
    while (cur.next != null) {
        RandomListNode next = cur.next;
        cur.next = next.next;
        cur = next;
    }
    return pCloneHead;
}

```

#### 36. 二叉搜索树与双向链表

[NowCode](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

##### 思路

```java
private TreeNode pre = null;
private TreeNode head = null;

public TreeNode Convert(TreeNode root) {
    inOrder(root);
    return head;
}

private void inOrder(TreeNode node) {
    if (node == null)
        return;
    inOrder(node.left);
    node.left = pre;
    if (pre != null)
        pre.right = node;
    pre = node;
    //定位第一个点，用于返回链表头。
    if (head == null)
        head = node;
    inOrder(node.right);
}

```



### 查找

#### 8.二叉树的下一个节点

[NowCode](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

##### 思路

分两种情况：

1. 如果该节点有右子节点，则找最左的左子节点
2. 如果该节点没有右子节点，则找第一个把节点树作为左节点的祖先节点。

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null){
                node = node.left;
            }
            return node;
        }else{
            while(pNode.next != null){
                TreeLinkNode up = pNode.next;
                if(up.left == pNode)
                    return up;
                pNode = pNode.next;
            }
        }
        return null;
    }
}
```

#### 26.树的子结构

[NowCode](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

##### 思路

递归：递归root1的结点同时与root2比较，比较函数中再递归本身实现遍历。

```java
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1 == null || root2 == null)
            return false;
        return isSimTree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
    }
    public boolean isSimTree(TreeNode root1, TreeNode root2){
        if(root2 == null)
            return true;
        //要在root2不为空的前提下，所以要放在后面
        if(root1 == null)
            return false;
        if(root1.val != root2.val)
            return false;
        return isSimTree(root1.left, root2.left) && isSimTree(root1.right, root2.right);
    }
}
```

#### 32.1 从上往下打印二叉树

[NowCode](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

##### 思路

使用队列来进行层次遍历。

```java
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            while(len-- > 0){
                TreeNode node = queue.poll();
                if(node == null)
                    continue;
                res.add(node.val);
                queue.add(node.left);
                queue.add(node.right);
            }
        }
        return res;
    }
}
```

#### 33. 二叉搜索树的后序遍历序列

[NowCode](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。

##### 思路

通过最右为根节点然后比较大小区分左右树，并判断是否正确。再通过递归左右树完成全部搜索。

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence == null || sequence.length == 0)
            return false;
        return Verify(sequence, 0, sequence.length-1);
    }
    public boolean Verify(int[] sequence, int left, int right){
        if(right - left <= 1)
            return true;
        int rootValue = sequence[right];
        int curIndex = left;
        while(curIndex < right && sequence[curIndex] <= rootValue)
            curIndex++;
        for(int i=curIndex; i<right; i++){
            if(sequence[i] < rootValue)
                return false;
        }
        return Verify(sequence, left, curIndex - 1) && Verify(sequence, curIndex, right - 1);
    }
}
```

#### 34. 二叉树中和为某一值的路径

[NowCode](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

##### 思路

判断依据：target减到0，无左右节点。无左右节点且没减到零则把list删除。

```java
public class Solution {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        PathFind(root, target, new ArrayList<>());
        return res;
    }
    public void PathFind(TreeNode root, int target, ArrayList<Integer> path){
        if(root == null)
            return ;
        path.add(root.val);
        target -= root.val;
        if(target == 0 && root.left == null && root.right == null)
            res.add(new ArrayList(path));
        else{
            PathFind(root.right, target, path);
            PathFind(root.left, target, path);
        }
        path.remove(path.size()-1);
    }
}
```

#### 54.二叉查找树的第K个结点

[NowCode](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入k，查找第k小个的结点。

##### 思路

利用二叉查找树中序有序特点遍历，每次一个结点便+1，达到k即返回。

```java
public class Solution {
    int num = 0;
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot != null){
            TreeNode node = KthNode(pRoot.left, k);
            if(node != null)
                return node;
            num++;
            if(num == k)
                return pRoot;
            node = KthNode(pRoot.right, k);
            if(node != null)
                return node;
        }
        return null;
    }
}
```

#### 55.1. 二叉树深度

[NowCode](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

##### 思路

左右遍历每次累加1即可。

```java
public int TreeDepth(TreeNode root) {
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

#### 55.2.平衡二叉树

[NowCode](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一棵二叉树，判断该二叉树是否是平衡二叉树

##### 思路

最深记为1，往上加，当左右相差大于1即不是平衡二叉树

```java
public class Solution {
    private boolean balance = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        high(root);
        return balance;
    }
    private int high(TreeNode root){
        if(root == null)
            return 0;
        int left = high(root.left);
        int right = high(root.right);
        if(Math.abs(left - right) > 1)
            balance = false;
        return 1+Math.max(left, right);
    }
}
```



## 栈

### 构建

#### 9.用两个栈实现队列

[NowCode](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

##### 思路

stack 1用来处理入栈（push）操作，stack 2用来处理出栈（pop）操作。一个元素进入stack 1之后，出栈的顺序被反转。当元素要出栈时，先进入stack 2，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

* 在给stack 2压入元素时要考虑到此时stack 2是否是空，只有在2栈全部取完才可以从1栈中pop

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

#### 30.包含min函数的栈

[NowCode](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

##### 思路

使用两个栈，一个存储数据，一个把每次最小的压入栈中，注意pop的时候需要把两个栈都pop。

```java
private Stack<Integer> dataStack = new Stack<>();
private Stack<Integer> minStack = new Stack<>();

public void push(int node) {
    dataStack.push(node);
    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));
}

public void pop() {
    dataStack.pop();
    minStack.pop();
}

public int top() {
    return dataStack.peek();
}

public int min() {
    return minStack.peek();
}
```

#### 31.栈的压入、弹出

[NowCode](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

##### 思路

模拟一个栈入栈弹栈。

```java
import java.util.ArrayList;
import java.util.*;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        int n = pushA.length;
        Stack<Integer> stack = new Stack<>();
        for(int pushIndex = 0, popIndex = 0; pushIndex < n; pushIndex++){
            stack.push(pushA[pushIndex]);
            while(popIndex < n && !stack.isEmpty() && popA[popIndex] == stack.peek()){
                stack.pop();
                popIndex++;
            }
        }
        return stack.isEmpty();
    }
}
```

