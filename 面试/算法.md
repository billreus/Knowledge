# 树

## 前中后序

按照访问根节点的顺序：前序遍历先访问根节点，中序遍历先访问左节点再访问根节点，后序遍历在访问完左子树和右子树后再访问根节点。

### 递归实现

```java
//前序
void traverse(TreeNode root){
    visit(root);
    traverse(root.left);
    traverse(root.right);
}

//中序
void traverse(TreeNode root){
    traverse(root.left);
    visit(root);
    traverse(root.right);
}

//后序
void traverse(TreeNode root){
    traverse(root.left);    
    traverse(root.right);
    visit(root);
}
```

### 非递归实现

使用栈来存储节点，当栈弹出一个节点，就访问该节点并添加到list的中。并且将左右子树根节点都添加到栈中。

在栈中，前序需要先右后左，保证左子树先遍历；后序相反。

```java
//前序
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.right);
        stack.push(node.left);
    }
    return res;
}

//后序
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.left);
        stack.push(node.right);        
    }
    return res;
}
```

中序需要先访问左子树，只有当左子树为空才能从栈中弹出节点并储存，从而保证左子树都被访问过了。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while(cur != null || !stack.isEmpty()){
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        res.add(node.val);
        cur = node.right;
    }
    return res;
}
```

## 树的高度

一颗树如果是空树，则高度为 0，否则它的高度是两个子树高度最大值再加 1，加 1 是因为根节点的高度为 1。可以把两颗子树当做新的树，因此求解两颗子树的高度可以继续调用求解方法。

```java
public int maxDepth(TreeNode root){
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```

## 平衡树

平衡树满足每个节点左右子树的高度差不大于1。

```java
private boolean res = true;

public boolean isBalanced(TreeNode root){
    maxDepth(root);
    return res;
}

public int maxDepth(TreeNode root){
    if(root == null) return 0;
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    if(Math.abs(left - right) > 1) res = false;
    return 1+Math.max(left, right);
}
```

## 归并两棵树

两颗树归并为一颗，如果在某个节点处，两棵树在该节点上都不为空，那么将两个节点的值加起来，否则只取有值的那颗树的节点的值。

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2){
    if(t1 == null && t2 == null) return null;
    if(t2 == null) return t1;
    if(t1 == null) return t2;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergerTrees(t1.left, t2.left);
    root.right = mergerTrees(t1.right, t2.right);
    return root;
}
```