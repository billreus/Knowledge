# 树

## 前中后序

按照访问根节点的顺序：前序遍历先访问根节点，中序遍历先访问左节点再访问根节点，后序遍历在访问完左子树和右子树后再访问根节点。

### 递归实现

```java
//前序
void traverse(TreeNode root){
    visit(root);
    traverse(root.left);
    traverse(root.right);
}

//中序
void traverse(TreeNode root){
    traverse(root.left);
    visit(root);
    traverse(root.right);
}

//后序
void traverse(TreeNode root){
    traverse(root.left);    
    traverse(root.right);
    visit(root);
}
```

### 非递归实现

使用栈来存储节点，当栈弹出一个节点，就访问该节点并添加到list的中。并且将左右子树根节点都添加到栈中。

在栈中，前序需要先右后左，保证左子树先遍历；后序相反。

```java
//前序
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.right);
        stack.push(node.left);
    }
    return res;
}

//后序
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.left);
        stack.push(node.right);        
    }
    return res;
}
```

中序需要先访问左子树，只有当左子树为空才能从栈中弹出节点并储存，从而保证左子树都被访问过了。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while(cur != null || !stack.isEmpty()){
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        res.add(node.val);
        cur = node.right;
    }
    return res;
}
```