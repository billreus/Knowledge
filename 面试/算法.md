# 树

## 前中后序

按照访问根节点的顺序：前序遍历先访问根节点，中序遍历先访问左节点再访问根节点，后序遍历在访问完左子树和右子树后再访问根节点。

### 递归实现

```java
//前序
void traverse(TreeNode root){
    visit(root);
    traverse(root.left);
    traverse(root.right);
}

//中序
void traverse(TreeNode root){
    traverse(root.left);
    visit(root);
    traverse(root.right);
}

//后序
void traverse(TreeNode root){
    traverse(root.left);    
    traverse(root.right);
    visit(root);
}
```

### 非递归实现

使用栈来存储节点，当栈弹出一个节点，就访问该节点并添加到list的中。并且将左右子树根节点都添加到栈中。

在栈中，前序需要先右后左，保证左子树先遍历；后序相反。

```java
//前序
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.right);
        stack.push(node.left);
    }
    return res;
}

//后序
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        res.add(node.val);
        stack.push(node.left);
        stack.push(node.right);        
    }
    return res;
}
```

中序需要先访问左子树，只有当左子树为空才能从栈中弹出节点并储存，从而保证左子树都被访问过了。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while(cur != null || !stack.isEmpty()){
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        res.add(node.val);
        cur = node.right;
    }
    return res;
}
```

## 树的高度

一颗树如果是空树，则高度为 0，否则它的高度是两个子树高度最大值再加 1，加 1 是因为根节点的高度为 1。可以把两颗子树当做新的树，因此求解两颗子树的高度可以继续调用求解方法。

```java
public int maxDepth(TreeNode root){
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```

## 平衡树

平衡树满足每个节点左右子树的高度差不大于1。

```java
private boolean res = true;

public boolean isBalanced(TreeNode root){
    maxDepth(root);
    return res;
}

public int maxDepth(TreeNode root){
    if(root == null) return 0;
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    if(Math.abs(left - right) > 1) res = false;
    return 1+Math.max(left, right);
}
```

## 归并两棵树

两颗树归并为一颗，如果在某个节点处，两棵树在该节点上都不为空，那么将两个节点的值加起来，否则只取有值的那颗树的节点的值。

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2){
    if(t1 == null && t2 == null) return null;
    if(t2 == null) return t1;
    if(t1 == null) return t2;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergerTrees(t1.left, t2.left);
    root.right = mergerTrees(t1.right, t2.right);
    return root;
}
```

## 判断是否存在和等于一个数的路径

一棵树，题目要求的目标和为 5。该树存在一个 0 -> 1 -> 4 的路径，这个路径的和为 5，因此返回 true。（该路径需要符合从从走到尾）

使用递归的思路求解：对于一棵树，其根节点为 root，如果两颗子树任意一颗存在和为 sum - root.val，那么再加上根加点 root.val，总和为 sum。在两颗子树上的求解可以继续使用该递归函数。

```java
public boolean hasPathSum(TreeNode root, int sum){
    if(root == null) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);
}
```

## 统计路径等于一个数的数量

同样寻找路径，区别在于不要求从根节点到子节点。

```java
public int pathSum(TreeNode root, int sum){
    if(root == null) return 0;
    //以根为起点和不以根为起点
    int res = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return res;
}
private int pathSumStartWithRoot(TreeNode root, int sum){
    if(root == null) return 0;
    int res = 0;
    if(root.val == sum) ret++;
    res += pathSumStartWithRoot(root.left, sum-root.val) + pathSumStartWithRoot(root.right, sum-root.val);
    return res;
}
```

## 子树

来源:LeetCode572.SubTree of Another Tree

题目：给定两棵树 s 和 t，题目要求判断 t 是不是 s 的子树，也就是 s 中存不存在一颗和 t 完全相同的树。但如果只是 s 中的一部分和 t 相同是不满足题目要求的，例如 s 中以节点 1 为根节点的子树有 3 个节点的值和结构都和 t 相同，但是多了一个 5 节点，那么该子树和 t 就不完全相同，t 不是 s 的子树。

思路：与上题主体思想一致，分根节点相同和根节点不同去递归。判断条件为两个树的null和val值。

```java
public boolean isSubtree(TreeNode s, TreeNode t){
    if(s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}
private boolean isSubtreeWithRoot(TreeNode s, TreeNode t){
    if(t == null && s == null)
        return true;
    if(t == null || s == null)
        return false;
    if(t.val != s.val)
        return false;
    return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.left);
}
```

## 树的对称

来源：LeetCode101.Symmetric Tree

题目：判断一棵树是否对称

```java
public boolean isSymmetric(TreeNode root){
    if(root == null) return true;
    return isSymmetric(root.left, root.right);
}
private boolean isSymmetric(TreeNode t1, TreeNode t2){
    if(t1 == null && t2 == null)
        return true;
    if(t1 == null || t2 == null)
        return false;
    if(t1.val != t2.val)
        return false;
    return isSymmetric(t1.left, t2.right) && isSymmetric(t1.right, t2.left);
}
```