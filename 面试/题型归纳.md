# 命令

## 字符串

### 查找

查找字符串str中第x位置的字符：`char s = str.charAt(x);`

### 替换

替换字符串str中第x位置的字符为b：`str.setcharAt(x, 'b');`

### 转换

字符串转换成标准的string：`str.toString();`

### 注意事项

字符串由于不是基本数据类型所以返回长度是方法：length();

字符串中单引号和双引号的区别在于，单引号内部内容是一个char，只能是一个字符，双引号内部是字符串可以是多个字符。

## List，Stack

### 添加

添加都使用add()方法

### 弹出

栈弹出使用pop()方法

## Map

### 添加

添加使用put(key, value);

### 提取

提取value使用get(key);

# 算法

## 搜索

### 查重

#### 3.数组中重复的数字

[Nowcode](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

###### 题目

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
```
Input:
{2, 3, 1, 0, 2, 5}

Output:
true, 2
```
###### 思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：
```java
public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null || length < 0) return false;
        for(int i=0; i<length; i++){
            while(numbers[i] != i){
                if(numbers[i] == numbers[numbers[i]]){
                    duplication[0] = numbers[i];
                    return true;
                }
                swap(numbers, i, numbers[i]);
            }
        }
        return false;
    }
    public void swap(int num[], int i, int j){
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
}
```

#### 4.二维数组中的查找

[Nowcode](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

##### 思路

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```

## 字符串

### 插入

#### 5.替换空格

[Nowcode](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

将一个字符串中的空格替换成 "%20"。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

##### 思路

首先，需要遍历整个字符串每个空格就在字符串末尾添加两个空格。

其次，设置两个指针P1, P2，P1指向原字符串末尾，P2指向添加完空格以后的字符串末尾。

最后，P1指针从右往左查找空格，发现空格就P2添加字符，没发现空格就把当前的字符移到P2位置。

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	int p1 = str.length() - 1;
        for(int i=0; i<=p1; i++){
            if(str.charAt(i) == ' '){
                str.append("  ");
            }
        }
        int p2 = str.length() - 1;
        while(p1>=0 && p2 > p1){
            char s = str.charAt(p1--);
            if(s == ' '){
                str.setCharAt(p2--, '0');
                str.setCharAt(p2--, '2');
                str.setCharAt(p2--, '%');
            }else{
                str.setCharAt(p2--, s);
            }
        }
        return str.toString();
    }
}
```

## 动态规划

### 斐波那契

#### 10.1.斐波那契数列 

[NowCode](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

求斐波那契数列的第 n 项，n <= 39。

##### 思路

基本思路：按照递归思考，即f(n)=f(n+1)+f(n+2)

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

动态规划：由于递归会频繁重复调用导致栈溢出，动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        int[] res = new int[n+1];
        res[0] = 0;
        res[1] = 1;
        for(int i=2; i<=n; i++){
            res[i] = res[i-1] + res[i-2];
        }
        return res[n];
    }
}
```

动态规划改良：考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```



# 数据结构

## 链表

### 反转

#### 6.从尾到头打印链表

[Nowcode](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

##### 思路

一、使用栈：把链表放入栈中再依次pop到list中

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        Stack<Integer> stack = new Stack<>();
        while(listNode != null){
            stack.add(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> list = new ArrayList<>();
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
}
```

二、头插法：新建一个头固定的链表，每次往头后面插入一个数，直到插满。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode head = new ListNode(0);
        while(listNode != null){
            ListNode listnext = listNode.next;
            listNode.next = head.next;
            head.next = listNode;
            listNode = listnext;
        }
        ArrayList list = new ArrayList<>();
        head = head.next;
        while(head != null){
            list.add(head.val);
            head = head.next;
        }
        return list;
    }
}
```

三、递归：要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。

```java
import java.util.ArrayList;
public class Solution {
    ArrayList list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //ArrayList list = new ArrayList<>();
        if(listNode != null){
            //list.addAll(printListFromTailToHead(listNode.next));
            printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

## 二叉树

### 构建

#### 7.重建二叉树

[NowCode](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

##### 思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

* 中序其实只是用来判断序列中左右节点的个数，然后通过对前序左右节点分割，递归来实现二叉树的构建。

```java
import java.util.*;
public class Solution {
    private Map<Integer, Integer> indexWhere = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        for(int i=0; i<in.length; i++){
            indexWhere.put(in[i], i);
        }
        return reConstructBinaryTree(pre, 0, pre.length-1, 0);
    }
    private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL){
        if(preL > preR)
            return null;
        TreeNode node = new TreeNode(pre[preL]);
        int index = indexWhere.get(node.val);
        int leftSize = index - inL;
        node.left = reConstructBinaryTree(pre, preL+1, preL+leftSize, inL);
        node.right = reConstructBinaryTree(pre, preL+leftSize+1, preR, index+1);
        return node;
    }
}
```

### 查找

#### 8.二叉树的下一个节点

[NowCode](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

##### 思路

分两种情况：

1. 如果该节点有右子节点，则找最左的左子节点
2. 如果该节点没有右子节点，则找第一个把节点树作为左节点的祖先节点。

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null){
                node = node.left;
            }
            return node;
        }else{
            while(pNode.next != null){
                TreeLinkNode up = pNode.next;
                if(up.left == pNode)
                    return up;
                pNode = pNode.next;
            }
        }
        return null;
    }
}
```

## 栈

### 构建

#### 9.用两个栈实现队列

[NowCode](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

##### 思路

stack 1用来处理入栈（push）操作，stack 2用来处理出栈（pop）操作。一个元素进入stack 1之后，出栈的顺序被反转。当元素要出栈时，先进入stack 2，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

* 在给stack 2压入元素时要考虑到此时stack 2是否是空，只有在2栈全部取完才可以从1栈中pop

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

