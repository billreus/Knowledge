# 命令

## 字符串

### 查找

查找字符串str中第x位置的字符：`char s = str.charAt(x);`

### 替换

替换字符串str中第x位置的字符为b：`str.setcharAt(x, 'b');`

### 转换

字符串转换成标准的string：`str.toString();`

### 注意事项

字符串由于不是基本数据类型所以返回长度是方法：length();

字符串中单引号和双引号的区别在于，单引号内部内容是一个char，只能是一个字符，双引号内部是字符串可以是多个字符。

## List，Stack

### 添加

添加都使用add()方法

### 弹出

栈弹出使用pop()方法

## Map

### 添加

添加使用put(key, value);

### 提取

提取value使用get(key);

# 算法

## 搜索

### 查重

#### 3.数组中重复的数字

[Nowcode](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

###### 题目

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
```
Input:
{2, 3, 1, 0, 2, 5}

Output:
true, 2
```
###### 思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：
```java
public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null || length < 0) return false;
        for(int i=0; i<length; i++){
            while(numbers[i] != i){
                if(numbers[i] == numbers[numbers[i]]){
                    duplication[0] = numbers[i];
                    return true;
                }
                swap(numbers, i, numbers[i]);
            }
        }
        return false;
    }
    public void swap(int num[], int i, int j){
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
}
```

#### 4.二维数组中的查找

[Nowcode](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

##### 思路

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```

### 查找

#### 11.旋转数组的最小数字

[NowCode](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 

##### 思路

基本思路：其实当数组中后者比前者小的时候即最小数字，但是遍历数组复杂度为O(n)

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len<=1)return array[0];
        for(int i=0; i<len-1; i++){
            if(array[i] > array[i+1]){
                return array[i+1];
            }
        }
        return array[len-1];
    }
}
```

二分查找：将数组对半分可以得到一个非递减的数组和一个包含最小元素的数组。由于非递减数组第一个元素肯定小于最后一个元素，所以当a[m]<=a[h]则[m,h]区间是非递减数组，否则[m+1,h]是旋转数组，以此重复复杂度为O(logN)

```java
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len == 0)return 0;
        int l = 0, h = len - 1;
        while(l < h){
            int mid = l + (h - l) / 2;
            if(array[m] <= array[h]])//[m,h]非递减数组
                h = m;
            else
                l = m + 1;
        }
        return array[l];
    }
}
```

### 交换

#### 21.调整数组顺序使奇数位于偶数前面

[NowCode](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

##### 思路

1.创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。

```java
public void reOrderArray(int[] nums) {
    // 奇数个数
    int oddCnt = 0;
    for (int x : nums)
        if (!isEven(x))
            oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1)
            nums[i++] = num;
        else
            nums[j++] = num;
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}
```

2.使用冒泡思想，每次找到偶数且右边是奇数就交换。时间复杂度 O(N2)，空间复杂度 O(1)，时间换空间。

```java
public void reOrderArray(int[] nums) {
    int N = nums.length;
    for (int i = N - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (isEven(nums[j]) && !isEven(nums[j + 1])) {
                swap(nums, j, j + 1);
            }
        }
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```



### 位运算

#### 15.二进制个数

[NowCode](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个整数，输出该数二进制表示中 1 的个数。

##### 思路

n&(n-1):用于去除二进制数最后一位1。

```java
public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &= (n - 1);
    }
    return cnt;
}
```



## 字符串

### 插入

#### 5.替换空格

[Nowcode](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

将一个字符串中的空格替换成 "%20"。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

##### 思路

首先，需要遍历整个字符串每个空格就在字符串末尾添加两个空格。

其次，设置两个指针P1, P2，P1指向原字符串末尾，P2指向添加完空格以后的字符串末尾。

最后，P1指针从右往左查找空格，发现空格就P2添加字符，没发现空格就把当前的字符移到P2位置。

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	int p1 = str.length() - 1;
        for(int i=0; i<=p1; i++){
            if(str.charAt(i) == ' '){
                str.append("  ");
            }
        }
        int p2 = str.length() - 1;
        while(p1>=0 && p2 > p1){
            char s = str.charAt(p1--);
            if(s == ' '){
                str.setCharAt(p2--, '0');
                str.setCharAt(p2--, '2');
                str.setCharAt(p2--, '%');
            }else{
                str.setCharAt(p2--, s);
            }
        }
        return str.toString();
    }
}
```

### 对比

<<<<<<< Updated upstream
#### 19.正则表达式匹配

[NowCode](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab/*ac/*a"匹配，但是与"aa.a"和"ab*a"均不匹配

##### 思路

```java
public class Solution {
    public boolean match(char[] str, char[] pattern) {
    if (str == null || pattern == null) {
        return false;
    }
    int strIndex = 0;
    int patternIndex = 0;
    return matchCore(str, strIndex, pattern, patternIndex);
}
  
public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
    //有效性检验：str到尾，pattern到尾，匹配成功
    if (strIndex == str.length && patternIndex == pattern.length) {
        return true;
    }
    //pattern先到尾，匹配失败
    if (strIndex != str.length && patternIndex == pattern.length) {
        return false;
    }
    //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
    if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
            return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
        } else {
            return matchCore(str, strIndex, pattern, patternIndex + 2);
        }
    }
    //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
    if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
        return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
    }
    return false;
    }
=======
#### 20.表示数值的字符串

[NowCode](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

##### 思路

使用正则表达式进行匹配

```
[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1 次
+   ： 重复 1 ~ n 次
*   ： 重复 0 ~ n 次
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
```

​```java
public boolean isNumeric(char[] str) {
    if (str == null || str.length == 0)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
>>>>>>> Stashed changes
}
```



## 动态规划

### 斐波那契

#### 10.1.斐波那契数列 

[NowCode](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

求斐波那契数列的第 n 项，n <= 39。

##### 思路

基本思路：按照递归思考，即f(n)=f(n+1)+f(n+2)

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

动态规划：由于递归会频繁重复调用导致栈溢出，动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        int[] res = new int[n+1];
        res[0] = 0;
        res[1] = 1;
        for(int i=2; i<=n; i++){
            res[i] = res[i-1] + res[i-2];
        }
        return res[n];
    }
}
```

动态规划改良：考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```

#### 10.2.矩形覆盖

[NowCode](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？

##### 思路

当n为1时只有一种方法，当n为2时，有两种方法，要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形。即f(n)=f(n-1)+f(n-2)当n>=2时。

```java
public class Solution {
    public int RectCover(int target) {//递归版
        if(target <= 2)
            return target;
        return RectCover(target-1)+RectCover(target-2);
    }
}

public int RectCover(int n) {//动态规划版
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i <= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

#### 10.3.跳台阶

[NowCode](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

##### 思路

与斐波那契数列和矩形覆盖类似。

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target <= 2)
            return target;
        int pre1 = 1, pre2 = 2;
        int res = 0;
        for(int i=3; i <= target; i++){
            res = pre1 + pre2;
            pre1 = pre2;
            pre2 = res;
        }
        return res;
    }
}
```

#### 10.4.变态跳台阶

[NowCode](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

##### 思路

动态规划：

当target<2，f(0)=0, f(1)=1

当target>=2, f(0)=1, f(1)=1, f(2)=f(0)+f(1), f(3)=f(0)+f(1)+f(2)......

```java
public class Solution {
    public int JumpFloorII(int target) {
        int[] f = new int[target+1];
        if(target == 0) return 0;
        f[0] = 1;
        f[1] = 1;
        for(int i=2; i<=target; i++){
            for(int j=0; j<i; j++){
                f[i] += f[j];
            }
        }
        return f[target];
    }
}
```

### 回朔

#### 12.矩阵中的路径

[NowCode](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

##### 思路

回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。

```java
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        boolean[] walked = new boolean[matrix.length];
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                if(judge(matrix, i, j, rows, cols, str, walked, 0))
                    return true;
            }
        }
        return false;
    }
    private boolean judge(char[] matrix, int i, int j, int rows, int cols, char[] str, boolean[] walked, int k){
        //寻找失败条件
        int index = i*cols+j;
        if(i<0 || j<0 || i>=rows || j>=cols || matrix[index] != str[k] || walked[index])
            return false;
        if(k == str.length-1)
            return true;
        walked[index] = true;
        if(judge(matrix, i-1, j, rows, cols, str, walked, k+1)||
            judge(matrix, i+1, j, rows, cols, str, walked, k+1)||
            judge(matrix, i, j+1, rows, cols, str, walked, k+1)||
            judge(matrix, i, j-1, rows, cols, str, walked, k+1))
            return true;
        //走到此代表此路不通
        walked[index] = false;
        return false;
    }

}
```

#### 13.机器人

[NowCode](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

##### 思路

与路径回朔相似，区别在于return的值，每次下一步需要记数。

```java
public class Solution {
    public int movingCount(int threshold, int rows, int cols)
    {
        boolean[][] walked = new boolean[rows][cols];
        return find(threshold, rows, cols, 0, 0, walked);
    }
    public int find(int threshold, int rows, int cols, int i, int j, boolean[][] walked){
        if(i<0 || j<0 || i>=rows || j>=cols || walked[i][j] || bitsum(i)+bitsum(j)>threshold)
            return 0;
        walked[i][j] = true;
        return find(threshold, rows, cols, i+1, j, walked) +
          find(threshold, rows, cols, i-1, j, walked)+
          find(threshold, rows, cols, i, j+1, walked)+
          find(threshold, rows, cols, i, j-1, walked)+1;
    }
    public int bitsum(int i){
        int sum =0;
        while(i != 0){
            sum += i%10;
            i /= 10;
        }
        return sum;
    }
}
```

#### 17.打印从1到最大数n

##### 题目

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

##### 思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```



### 贪心

#### 14.剪绳子

[LeetCode](https://leetcode-cn.com/problems/integer-break/)

##### 题目

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

##### 思路

贪心：如果分解式含1，则乘积越来越小；如果分解式含2，2(n-2)>n，当n>4时；如果分解式含3，3(n-3)>n，当n>4.5时；如果分解式含4不如2,；如果含5不如2和3；所以尽可能分解成3，如果剩1则分解成两个2。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

动态规划：dp[i]代表i分割之后得到的乘积最大的元素，每次需要和之前所有的状态进行比较，状态转移方程式为dp[i]=max(dp[i],(i-j)*max(dp[j],j))，因为dp[j]未曾包括不分割当前元素乘积最大的情况，因此需要加以考虑.

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

## 实现函数

### Math.power()

#### 16.数值的整数次方

[NowCode](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

##### 思路

递归求解，每次次方减半

```java
public double Power(double base, int exponent) {
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;
    boolean isNegative = false;
    if (exponent < 0) {
        exponent = -exponent;
        isNegative = true;
    }
    double pow = Power(base * base, exponent / 2);
    if (exponent % 2 != 0)
        pow = pow * base;
    return isNegative ? 1 / pow : pow;
}
```



# 数据结构

## 链表

### 反转

#### 6.从尾到头打印链表

[Nowcode](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

##### 思路

一、使用栈：把链表放入栈中再依次pop到list中

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        Stack<Integer> stack = new Stack<>();
        while(listNode != null){
            stack.add(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> list = new ArrayList<>();
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
}
```

二、头插法：新建一个头固定的链表，每次往头后面插入一个数，直到插满。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode head = new ListNode(0);
        while(listNode != null){
            ListNode listnext = listNode.next;
            listNode.next = head.next;
            head.next = listNode;
            listNode = listnext;
        }
        ArrayList list = new ArrayList<>();
        head = head.next;
        while(head != null){
            list.add(head.val);
            head = head.next;
        }
        return list;
    }
}
```

三、递归：要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。

```java
import java.util.ArrayList;
public class Solution {
    ArrayList list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //ArrayList list = new ArrayList<>();
        if(listNode != null){
            //list.addAll(printListFromTailToHead(listNode.next));
            printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

#### 24.反转链表

[NowCode](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，反转链表后，输出新链表的表头。

##### 思路

与上题思路相似，分递归和头插法

递归：

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

迭代：

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```



### 删除

#### 18.1.在 O(1) 时间内删除链表结点

##### 题目

已知即将要删的节点。

##### 思路

首先分两种情况：1.要删除的节点不在末尾；2.要删除的节点在末尾

1.将删除节点的next节点复制到删除节点上，删除next节点即可。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if(head == null || tobeDelete == null)
        return null;
    //删除节点不在末尾
    if(tobeDelete.next != null){
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    }else{
        if(head == tobeDelete)//只有一个节点
            return null;
        else{
            ListNode node = head;
            while(node.next != tobeDelete){
                node = node.next;
            }
            node.next = null;
        }
    }
    return head;
}
```

#### 18.2删除链表中的重复结点
*[NowCode](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)*

##### 题目

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

##### 思路

使用两个结点，preNode指向新的头结点，walkNode指向第一个结点。

当walk不是最后结点时：如果walk和下一个结点相同：如果pre和walk相邻则pre=walk，如果不相邻则pre指向walk的下一个结点。

当walk是最后结点时：如果pre和walk相邻则pre=walk，如果不相邻则pre指向walk的下一个结点。

每次判断完walk向前移动。

```java
public ListNode printListFromTailToHead(ListNode pHead) {
    ListNode newhead=new ListNode(0);//解决删除头结点的可能，例如{1，1，1，1，2}
    newhead.next=pHead;
    ListNode pre=newhead;
    ListNode walkNode=newhead.next;
    while(walkNode!=null){
        if(walkNode.next!=null){
            if(walkNode.next.val!=walkNode.val){
                if(pre.next!=walkNode){
                    pre.next=walkNode.next;    
                }else{
                    pre=walkNode;
                }
            }
        }else{//如果walkNode指向最后一个结点
           if(pre.next!=walkNode){
                pre.next=walkNode.next;    
           }else{
                pre=walkNode;
           }
        }
        walkNode=walkNode.next;    
    }
    return newhead.next;    
}
```

### 查找

#### 22.链表中倒数第K个节点

[Nowcode](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，输出该链表中倒数第k个结点。

##### 思路

设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。

```java
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head == null)
            return null;
        ListNode node1 = head;
        while(node1 != null && k-->0){
            node1 = node1.next;
        }
        if(k>0)
            return null;
        ListNode node2 = head;
        while(node1 != null){
            node1 = node1.next;
            node2 = node2.next;
        }
        return node2;
    }
}
```



#### 23.链表中环的入口结点

[NodeCode](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

##### 思路

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在的 z位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return null;
    ListNode slow = pHead, fast = pHead;
    do {
        fast = fast.next.next;
        slow = slow.next;
    } while (slow != fast);
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
```

### 合并

#### 25.合并两个排序的链表

[NodeCode](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入两个单调递增的链表，输出两个链表合成后的链表

##### 思路

迭代：用一个新的链表，每次比较两个链表大小，把小的与新链表连接。

```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode res = new ListNode(0);
        ListNode node = res; 
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                node.next = list1;
                list1 = list1.next;
            }else{
                node.next = list2;
                list2 = list2.next;
            }
            node = node.next;
        }
        if(list1 != null){
            node.next = list1;
        }
        if(list2 != null){
            node.next = list2;
        }
        return res.next;
    }
}
```

递归:拆解成链表1和2谁小就next递归谁。

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```



## 二叉树

### 构建

#### 7.重建二叉树

[NowCode](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

##### 思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

* 中序其实只是用来判断序列中左右节点的个数，然后通过对前序左右节点分割，递归来实现二叉树的构建。

```java
import java.util.*;
public class Solution {
    private Map<Integer, Integer> indexWhere = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        for(int i=0; i<in.length; i++){
            indexWhere.put(in[i], i);
        }
        return reConstructBinaryTree(pre, 0, pre.length-1, 0);
    }
    private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL){
        if(preL > preR)
            return null;
        TreeNode node = new TreeNode(pre[preL]);
        int index = indexWhere.get(node.val);
        int leftSize = index - inL;
        node.left = reConstructBinaryTree(pre, preL+1, preL+leftSize, inL);
        node.right = reConstructBinaryTree(pre, preL+leftSize+1, preR, index+1);
        return node;
    }
}
```

### 查找

#### 8.二叉树的下一个节点

[NowCode](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

##### 思路

分两种情况：

1. 如果该节点有右子节点，则找最左的左子节点
2. 如果该节点没有右子节点，则找第一个把节点树作为左节点的祖先节点。

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null){
                node = node.left;
            }
            return node;
        }else{
            while(pNode.next != null){
                TreeLinkNode up = pNode.next;
                if(up.left == pNode)
                    return up;
                pNode = pNode.next;
            }
        }
        return null;
    }
}
```

#### 26.树的子结构

[NowCode](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

##### 思路

递归：递归root1的结点同时与root2比较，比较函数中再递归本身实现遍历。

```java
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1 == null || root2 == null)
            return false;
        return isSimTree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
    }
    public boolean isSimTree(TreeNode root1, TreeNode root2){
        if(root2 == null)
            return true;
        //要在root2不为空的前提下，所以要放在后面
        if(root1 == null)
            return false;
        if(root1.val != root2.val)
            return false;
        return isSimTree(root1.left, root2.left) && isSimTree(root1.right, root2.right);
    }
}
```



## 栈

### 构建

#### 9.用两个栈实现队列

[NowCode](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

##### 思路

stack 1用来处理入栈（push）操作，stack 2用来处理出栈（pop）操作。一个元素进入stack 1之后，出栈的顺序被反转。当元素要出栈时，先进入stack 2，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

* 在给stack 2压入元素时要考虑到此时stack 2是否是空，只有在2栈全部取完才可以从1栈中pop

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

