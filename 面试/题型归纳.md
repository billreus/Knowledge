# 命令

## 字符串

### 查找

查找字符串str中第x位置的字符：`char s = str.charAt(x);`

### 替换

替换字符串str中第x位置的字符为b：`str.setcharAt(x, 'b');`

### 转换

字符串转换成标准的string：`str.toString();`

### 注意事项

字符串由于不是基本数据类型所以返回长度是方法：length();

字符串中单引号和双引号的区别在于，单引号内部内容是一个char，只能是一个字符，双引号内部是字符串可以是多个字符。

## List，Stack

### 添加

添加都使用add()方法

### 弹出

栈弹出使用pop()方法

## Map

### 添加

添加使用put(key, value);

### 提取

提取value使用get(key);

# 算法

## 搜索

### 查重

#### 3.数组中重复的数字

[Nowcode](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

###### 题目

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
```
Input:
{2, 3, 1, 0, 2, 5}

Output:
true, 2
```
###### 思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：
```java
public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null || length < 0) return false;
        for(int i=0; i<length; i++){
            while(numbers[i] != i){
                if(numbers[i] == numbers[numbers[i]]){
                    duplication[0] = numbers[i];
                    return true;
                }
                swap(numbers, i, numbers[i]);
            }
        }
        return false;
    }
    public void swap(int num[], int i, int j){
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
}
```

#### 4.二维数组中的查找

[Nowcode](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

##### 思路

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```

### 查找

#### 11.旋转数组的最小数字

[NowCode](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 

##### 思路

基本思路：其实当数组中后者比前者小的时候即最小数字，但是遍历数组复杂度为O(n)

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len<=1)return array[0];
        for(int i=0; i<len-1; i++){
            if(array[i] > array[i+1]){
                return array[i+1];
            }
        }
        return array[len-1];
    }
}
```

二分查找：将数组对半分可以得到一个非递减的数组和一个包含最小元素的数组。由于非递减数组第一个元素肯定小于最后一个元素，所以当a[m]<=a[h]则[m,h]区间是非递减数组，否则[m+1,h]是旋转数组，以此重复复杂度为O(logN)

```java
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len == 0)return 0;
        int l = 0, h = len - 1;
        while(l < h){
            int mid = l + (h - l) / 2;
            if(array[m] <= array[h]])//[m,h]非递减数组
                h = m;
            else
                l = m + 1;
        }
        return array[l];
    }
}
```



## 字符串

### 插入

#### 5.替换空格

[Nowcode](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

将一个字符串中的空格替换成 "%20"。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

##### 思路

首先，需要遍历整个字符串每个空格就在字符串末尾添加两个空格。

其次，设置两个指针P1, P2，P1指向原字符串末尾，P2指向添加完空格以后的字符串末尾。

最后，P1指针从右往左查找空格，发现空格就P2添加字符，没发现空格就把当前的字符移到P2位置。

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	int p1 = str.length() - 1;
        for(int i=0; i<=p1; i++){
            if(str.charAt(i) == ' '){
                str.append("  ");
            }
        }
        int p2 = str.length() - 1;
        while(p1>=0 && p2 > p1){
            char s = str.charAt(p1--);
            if(s == ' '){
                str.setCharAt(p2--, '0');
                str.setCharAt(p2--, '2');
                str.setCharAt(p2--, '%');
            }else{
                str.setCharAt(p2--, s);
            }
        }
        return str.toString();
    }
}
```

## 动态规划

### 斐波那契

#### 10.1.斐波那契数列 

[NowCode](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

求斐波那契数列的第 n 项，n <= 39。

##### 思路

基本思路：按照递归思考，即f(n)=f(n+1)+f(n+2)

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

动态规划：由于递归会频繁重复调用导致栈溢出，动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1)
            return n;
        int[] res = new int[n+1];
        res[0] = 0;
        res[1] = 1;
        for(int i=2; i<=n; i++){
            res[i] = res[i-1] + res[i-2];
        }
        return res[n];
    }
}
```

动态规划改良：考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```

#### 10.2.矩形覆盖

[NowCode](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？

##### 思路

当n为1时只有一种方法，当n为2时，有两种方法，要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形。即f(n)=f(n-1)+f(n-2)当n>=2时。

```java
public class Solution {
    public int RectCover(int target) {//递归版
        if(target <= 2)
            return target;
        return RectCover(target-1)+RectCover(target-2);
    }
}

public int RectCover(int n) {//动态规划版
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i <= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

#### 10.3.跳台阶

[NowCode](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

##### 思路

与斐波那契数列和矩形覆盖类似。

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target <= 2)
            return target;
        int pre1 = 1, pre2 = 2;
        int res = 0;
        for(int i=3; i <= target; i++){
            res = pre1 + pre2;
            pre1 = pre2;
            pre2 = res;
        }
        return res;
    }
}
```

#### 10.4.变态跳台阶

[NowCode](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

##### 思路

动态规划：

当target<2，f(0)=0, f(1)=1

当target>=2, f(0)=1, f(1)=1, f(2)=f(0)+f(1), f(3)=f(0)+f(1)+f(2)......

```java
public class Solution {
    public int JumpFloorII(int target) {
        int[] f = new int[target+1];
        if(target == 0) return 0;
        f[0] = 1;
        f[1] = 1;
        for(int i=2; i<=target; i++){
            for(int j=0; j<i; j++){
                f[i] += f[j];
            }
        }
        return f[target];
    }
}
```



# 数据结构

## 链表

### 反转

#### 6.从尾到头打印链表

[Nowcode](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

##### 思路

一、使用栈：把链表放入栈中再依次pop到list中

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        Stack<Integer> stack = new Stack<>();
        while(listNode != null){
            stack.add(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> list = new ArrayList<>();
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
}
```

二、头插法：新建一个头固定的链表，每次往头后面插入一个数，直到插满。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode head = new ListNode(0);
        while(listNode != null){
            ListNode listnext = listNode.next;
            listNode.next = head.next;
            head.next = listNode;
            listNode = listnext;
        }
        ArrayList list = new ArrayList<>();
        head = head.next;
        while(head != null){
            list.add(head.val);
            head = head.next;
        }
        return list;
    }
}
```

三、递归：要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。

```java
import java.util.ArrayList;
public class Solution {
    ArrayList list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //ArrayList list = new ArrayList<>();
        if(listNode != null){
            //list.addAll(printListFromTailToHead(listNode.next));
            printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

## 二叉树

### 构建

#### 7.重建二叉树

[NowCode](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

##### 思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

* 中序其实只是用来判断序列中左右节点的个数，然后通过对前序左右节点分割，递归来实现二叉树的构建。

```java
import java.util.*;
public class Solution {
    private Map<Integer, Integer> indexWhere = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        for(int i=0; i<in.length; i++){
            indexWhere.put(in[i], i);
        }
        return reConstructBinaryTree(pre, 0, pre.length-1, 0);
    }
    private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL){
        if(preL > preR)
            return null;
        TreeNode node = new TreeNode(pre[preL]);
        int index = indexWhere.get(node.val);
        int leftSize = index - inL;
        node.left = reConstructBinaryTree(pre, preL+1, preL+leftSize, inL);
        node.right = reConstructBinaryTree(pre, preL+leftSize+1, preR, index+1);
        return node;
    }
}
```

### 查找

#### 8.二叉树的下一个节点

[NowCode](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

##### 思路

分两种情况：

1. 如果该节点有右子节点，则找最左的左子节点
2. 如果该节点没有右子节点，则找第一个把节点树作为左节点的祖先节点。

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null){
                node = node.left;
            }
            return node;
        }else{
            while(pNode.next != null){
                TreeLinkNode up = pNode.next;
                if(up.left == pNode)
                    return up;
                pNode = pNode.next;
            }
        }
        return null;
    }
}
```

## 栈

### 构建

#### 9.用两个栈实现队列

[NowCode](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

##### 题目

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

##### 思路

stack 1用来处理入栈（push）操作，stack 2用来处理出栈（pop）操作。一个元素进入stack 1之后，出栈的顺序被反转。当元素要出栈时，先进入stack 2，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

* 在给stack 2压入元素时要考虑到此时stack 2是否是空，只有在2栈全部取完才可以从1栈中pop

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

