## 232. 用栈实现队列

由于队列是先进先出，栈是先进后出，所以需要两个栈，用来保证先push进的数永远在上面。

```java
class MyQueue {
    
    Stack<Integer> s = new Stack<Integer>();
    Stack<Integer> sQueue = new Stack<Integer>();
    
    /** Initialize your data structure here. */
    public MyQueue() {
        
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        while(!sQueue.isEmpty()) s.push(sQueue.pop());
        sQueue.push(x);
        while(!s.isEmpty()) sQueue.push(s.pop());
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(sQueue.isEmpty()) return -1;
        return sQueue.pop(); 
    }
    
    /** Get the front element. */
    public int peek() {
        if(sQueue.isEmpty()) return -1;
        return sQueue.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return sQueue.isEmpty();
    }
}
```

## 225. 用队列实现栈

* pop,push是stack的API，在queue中无法使用，Linkedlist可以使用。
* offer/push, poll/pop区别在于前者遇到空会返回布尔值，后者会提示异常

### 基本思路

和223使用相同思路，两个队列实现栈

```java
class MyStack {
    LinkedList<Integer> queue = new LinkedList<>();
    LinkedList<Integer> queue2 = new LinkedList<>();    
    
    /** Initialize your data structure here. */
    public MyStack() {
        
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        while(!queue.isEmpty()) queue2.offer(queue.poll());
        queue.offer(x);
        while(!queue2.isEmpty()) queue.offer(queue2.poll());
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        //while(queue.isEmpty()) return -1;
        return queue.poll();
    }
    
    /** Get the top element. */
    public int top() {
        //while(queue.isEmpty()) return -1;
        return queue.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## 705. 设计哈希集合

设计一个数组，并给每个值存储一个布尔值，以此来实现添加和删除

```java
class MyHashSet {
    boolean set [];
    /** Initialize your data structure here. */
    public MyHashSet() {
        set =new boolean [1000000];
    }
    
    public void add(int key) {
        set[key]=true;
    }
    
    public void remove(int key) {
        set[key]=false;
    }
    
    /** Returns true if this set did not already contain the specified element */
    public boolean contains(int key) {
        return set[key];
    }
}
```

