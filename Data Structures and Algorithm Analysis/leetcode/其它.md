# 智力题

## 292. Nim游戏

巴什博奕，n%(m+1)!=0时，先手总是会赢

```java
class Solution {
    public boolean canWinNim(int n) {
        return n%4!=0;
    }
}
```

# 原理题

## 371. 两整数之和

 a ^ b是无进位的相加； a&b得到每一位的进位

```java
class Solution {
    public int getSum(int a, int b) {
        return b == 0 ? a : getSum(a^b,(a&b)<<1); 
    }
}
```

# 其他

## 933. 最近的请求次数

### 基本

1. 初始化后，每次调用ping()时
2. 先将当前时间 t 加入队列 queue , 判断队头（第一个元素）是否符合范围，不符合则弹出，直到寻找到符合的元素
3. 发挥队列长度（剩下的元素都为符合的 ping）

```java
class RecentCounter {
    Queue<Integer> queue;
    public RecentCounter() {
        queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.add(t);
        while(t - queue.peek() > 3000) 
            queue.poll();
        
        return queue.size();
    }
}
```

### 改进

1. 利用快慢指针法
2. 创建一个数组用于存储 ping 的时间，创建快指针 count ,慢指针 i
3. 每次调用 ping() ，count 记录当前是第几次 ping ,并将 t 存到对于数组内
4. 利用 for() 寻找到第一个符合的数组 ，此时 i 为该符合的数组位置
5. 返回当前 ping 的序号 - 开始符合的 ping 的序号 +1  

```java
class RecentCounter {
    int[] index;
    int count;
    int i;
 
    public RecentCounter() {
        index = new int[10000];
        count = -1;
        i = 0;
    }
    
    public int ping(int t) {
        count++;
        index[count] = t;
        for(; i <= count; i++){
            if(t - index[i] <= 3000) break;
        }
        
        return count - i + 1;
    }
}

```