# 智力题

## 292. Nim游戏

巴什博奕，n%(m+1)!=0时，先手总是会赢

```java
class Solution {
    public boolean canWinNim(int n) {
        return n%4!=0;
    }
}
```

## 458. 可怜的小猪

原理上一只猪可以1h判断5桶，两只猪把25桶放成5*5然后5桶混合一次即可判断一行或者一列

```java
class Solution {
    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        
        if(buckets == 1) return 0;
        int w = minutesToTest / minutesToDie + 1;
        int re = 1;
        while(Math.pow(w,re) < buckets)
            re ++;
        return re;
    }
}
```

# 原理题

## 371. 两整数之和

 a ^ b是无进位的相加； a&b得到每一位的进位

```java
class Solution {
    public int getSum(int a, int b) {
        return b == 0 ? a : getSum(a^b,(a&b)<<1); 
    }
}
```

# 其他

## 933. 最近的请求次数

### 基本

1. 初始化后，每次调用ping()时
2. 先将当前时间 t 加入队列 queue , 判断队头（第一个元素）是否符合范围，不符合则弹出，直到寻找到符合的元素
3. 发挥队列长度（剩下的元素都为符合的 ping）

```java
class RecentCounter {
    Queue<Integer> queue;
    public RecentCounter() {
        queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.add(t);
        while(t - queue.peek() > 3000) 
            queue.poll();
        
        return queue.size();
    }
}
```

### 改进

1. 利用快慢指针法
2. 创建一个数组用于存储 ping 的时间，创建快指针 count ,慢指针 i
3. 每次调用 ping() ，count 记录当前是第几次 ping ,并将 t 存到对于数组内
4. 利用 for() 寻找到第一个符合的数组 ，此时 i 为该符合的数组位置
5. 返回当前 ping 的序号 - 开始符合的 ping 的序号 +1  

```java
class RecentCounter {
    int[] index;
    int count;
    int i;
 
    public RecentCounter() {
        index = new int[10000];
        count = -1;
        i = 0;
    }
    
    public int ping(int t) {
        count++;
        index[count] = t;
        for(; i <= count; i++){
            if(t - index[i] <= 3000) break;
        }
        
        return count - i + 1;
    }
}

```

## 690. 员工的重要性

```java
/*
// Employee info
class Employee {
    // It's the unique id of each node;
    // unique id of this employee
    public int id;
    // the importance value of this employee
    public int importance;
    // the id of direct subordinates
    public List<Integer> subordinates;
};
*/
class Solution {
    Map<Integer, Employee> employeeMap = new HashMap<>();
    public int getImportance(List<Employee> employees, int id) {
        for(Employee employee : employees){
            employeeMap.put(employee.id, employee);
        }
        return dfs(id);
    }
    public int dfs(int id){
        Employee employee = employeeMap.get(id);//确定选中的员工
        int res = employee.importance;
        for(int eid: employee.subordinates){
            res += dfs(eid);
        }
        return res;
    }
}
```