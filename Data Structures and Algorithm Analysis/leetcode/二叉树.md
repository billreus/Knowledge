<!-- TOC -->

- [常用命令](#常用命令)
- [104. 二叉树的最大深度](#104-二叉树的最大深度)
- [559. N叉树的最大深度](#559-n叉树的最大深度)
- [617. 合并二叉树](#617-合并二叉树)
    - [基本思路](#基本思路)
    - [改进](#改进)
- [226. 翻转二叉树](#226-翻转二叉树)
- [965. 单值二叉树](#965-单值二叉树)
    - [基本思路](#基本思路-1)
    - [改进](#改进-1)
- [700. 二叉搜索树中的搜索](#700-二叉搜索树中的搜索)
- [590. N叉树的后序遍历](#590-n叉树的后序遍历)
    - [基本思路](#基本思路-2)
    - [改进](#改进-2)
- [589. N叉树的前序遍历](#589-n叉树的前序遍历)
- [108.将有序数组转化为二叉搜索树](#108将有序数组转化为二叉搜索树)
- [107. 二叉树的层次遍历II](#107-二叉树的层次遍历ii)
- [429. N叉树的层序遍历](#429-n叉树的层序遍历)
- [669. 修剪二叉搜索树](#669-修剪二叉搜索树)
- [872. 叶子相似的树](#872-叶子相似的树)

<!-- /TOC -->

## 常用命令

存放不确定长度数组：`List<Integer> list = new ArrayList<Integer>();`

数组增加：`list.add()`

栈操作:`pop(), isEmpty(), push(), peek()`

N叉树中提取子节点：`root.children.get(i)`

list等翻转：`Collections.reverse(list)`

## 104. 二叉树的最大深度

递归遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : (1+ Math.max(maxDepth(root.left), maxDepth(root.right)));
    }
}
```

## 559. N叉树的最大深度

DFS递归

```java
class Solution {
    public int maxDepth(Node root) {
        if(root == null) return 0;
        int depth = 0;
        
        for(int i=0; i<root.children.size(); i++){
            depth = Math.max(depth, maxDepth(root.children.get(i)));
        }
        return depth+1;
    }
}
```

层次遍历

```java
public int maxDepth(Node root) {
    if(root == null)
        return 0;
    if(root.children.size() == 0)
        return 1;
    int depth = 0;
    Queue<Node> queue = new LinkedList<Node>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        depth++;
        while(count > 0){
            Node node = queue.poll();
            if(node.children.size() != 0)
                queue.addAll(node.children);              
            count--;                
        }
    }
    return depth;        
}
```

## 617. 合并二叉树

### 基本思路

1. 判断t1和t2是否为空，给val赋值并赋值
2. 分别递归t1,t2左节点和t1,t2右节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        TreeNode newtree = null;
        int val = 0;
        
        if(t1 != null && t2 != null){
            val = t1.val + t2.val;
            newtree = new TreeNode(val);
            
            newtree.left = mergeTrees(t1.left, t2.left);
            newtree.right = mergeTrees(t1.right, t2.right);
        } else if( t1 != null){
            newtree = new TreeNode(t1.val);
            
            newtree.left = mergeTrees(t1.left, null);
            newtree.right = mergeTrees(t1.right, null);
        }else if( t2 != null){
            newtree = new TreeNode(t2.val);
            
            newtree.left = mergeTrees(null, t2.left);
            newtree.right = mergeTrees(null, t2.right);
        }else{
            newtree = null;
        }
        return newtree;
    }
}
```

### 改进

无需新建一个树去存放结果，在t1上操作合并递归即可

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        // 节点的值合并
        t1.val = t1.val + t2.val;
        // 继续
        t1.left =  mergeTrees(t1.left, t2 != null ? t2.left : null);
        t1.right = mergeTrees(t1.right, t2 != null ? t2.right : null);
        return t1;
    }
}
```

## 226. 翻转二叉树

左右置换，递归左右节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
         if (root != null) {
            TreeNode tmpNode = root.left;
            root.left = root.right;
            root.right = tmpNode;
            invertTree(root.left);
            invertTree(root.right);
        }
        return root;
    }
}
```

## 965. 单值二叉树

### 基本思路

对root.val进行判断，root子节点分成四种情况讨论

```java
class Solution {
    
    public boolean isUnivalTree(TreeNode root) {
        int cap = root.val;
        return tree(root, cap);
    }
    
    public boolean tree(TreeNode root, int cap){
        if(root.val != cap){
            return false;
        }
        else if(root.left == null && root.right == null){
            return true;
        } 
        else if(root.left == null && root.right != null){
            return tree(root.right, cap);
        }
        else if(root.left != null && root.right == null){
            return tree(root.left, cap);
        }
        else{
            return tree(root.right, cap) && tree(root.left, cap);
        }
    }
}
```

### 改进

没明白= =

```java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        return val(root) > -1;
    }
    
    public int val(TreeNode r){
        int v = r.val;
        if(r.left!=null && val(r.left) != v)
            return -1;
        if(r.right!=null && val(r.right) != v)
            return -1;
        return v;
    }
}
```

## 700. 二叉搜索树中的搜索

判断值是等还是大于还是小于

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) return null;
        if(root.val == val){
            return root;
        }
        else if(root.val > val){
            return searchBST(root.left, val);
        }
        else{
            return searchBST(root.right,val);
        }
    }
}
```

## 590. N叉树的后序遍历


### 基本思路

建立两个Stack，一个用于把每层放入，再每层弹出给下一个stack和把root交给子节点。下一个stack用于把值传递给list。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> list = new ArrayList<Integer>();
        
        if(root == null) return list;
        if(root.children == null){
            list.add(root.val);
            return list;
        }
        
        Stack<Node> stack = new Stack<Node>();
        Stack<Node> restack = new Stack<Node>();
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            restack.push(root);
            for(int i=0; i<root.children.size(); i++){
                stack.push(root.children.get(i));
            }
        }
        
        while(!restack.isEmpty()){
            list.add(restack.pop().val);
        }
        return list;
    }
}

```

### 改进

递归思想，遍历root.children并作为node递归。

```java
class Solution {
    List<Integer> list = new ArrayList();

    public List<Integer> postorder(Node root) {
        if (root != null) {
            for (Node node : root.children) {
                postorder(node);
            }
            list.add(root.val);
        }
        return list;
    }
}
```

## 589. N叉树的前序遍历

与后序方法类似，只需要更改list添加数的位置。

```java
class Solution {

    List<Integer> list = new ArrayList();

    public List<Integer> preorder(Node root) {
        if (root != null) {
            list.add(root.val);
            for (Node node : root.children) {
                preorder(node);
            }
        }
        return list;
    }
}
```

## 108.将有序数组转化为二叉搜索树

因为数组有序，取数组中间值，然后递归树的左值和右值即可。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int n = nums.length;
        if(nums ==null || n == 0){
            return null;
        }
        return buildTree(nums, 0, n-1);
    }
    public TreeNode buildTree(int[] nums, int left, int right){
        if(left > right) return null;
        if(left == right) return new TreeNode(nums[left]);
        
        int mid = (left+right)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, left, mid-1);
        root.right = buildTree(nums, mid+1, right);
        return root;
    }
}
```

## 107. 二叉树的层次遍历II

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        
        addlist(0, root, list);
        Collections.reverse(list);
        return list;
    }
    
    public void addlist(int level, TreeNode node, List<List<Integer>> list){
        if(node == null) return;//到null节点即返回
        
        if(list.size()-1 < level){//一层结束加一个List数组
            list.add(new ArrayList<>());
        }
        
        list.get(level).add(node.val);
        addlist(level+1, node.left, list);
        addlist(level+1, node.right, list);
    }
}
```

## 429. N叉树的层序遍历

与107的二叉树类似，只需要在递归上修改

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        addlist(0, root, list);
        return list;
    }
    public void addlist(int level, Node nodes, List<List<Integer>> list){
        if(nodes == null) return ;
        
        if(list.size()-1 < level){
            list.add(new ArrayList<>());
        }
        
        list.get(level).add(nodes.val);
        for(Node node :nodes.children){
            addlist(level+1, node, list);
        }
    }
    
}
```

## 669. 修剪二叉搜索树

采用中序遍历的方法

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root == null)
            return null;
        if(root.val > R) 
            return trimBST(root.left, L, R);
        if(root.val < L)
            return trimBST(root.right, L, R);
        root.left = trimBST(root.left, L, R);
        root.right = trimBST(root.right, L, R);
        return root;
    }
}
```

## 872. 叶子相似的树

递归遍历，遍历到空就添加到list

```java
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        
        ArrayList list1 = new ArrayList();
        ArrayList list2 = new ArrayList();
        treeHelp(list1 ,root1);
        treeHelp(list2 ,root2);
        return list1.equals(list2);
        
    }
    
    public void treeHelp(ArrayList list, TreeNode root){
        
        if(root.left == null && root.right ==null)  list.add(root.val);        
        if(root.left != null)  treeHelp(list,root.left);        
        if(root.right != null)  treeHelp(list,root.right);
          
    }
}
```