<!-- TOC -->

- [常用命令](#常用命令)
- [104. 二叉树的最大深度](#104-二叉树的最大深度)
- [559. N叉树的最大深度](#559-n叉树的最大深度)
- [617. 合并二叉树](#617-合并二叉树)
    - [基本思路](#基本思路)
    - [改进](#改进)
- [226. 翻转二叉树](#226-翻转二叉树)
- [965. 单值二叉树](#965-单值二叉树)
    - [基本思路](#基本思路-1)
    - [改进](#改进-1)
- [700. 二叉搜索树中的搜索](#700-二叉搜索树中的搜索)
- [590. N叉树的后序遍历](#590-n叉树的后序遍历)
    - [基本思路](#基本思路-2)
    - [改进](#改进-2)
- [589. N叉树的前序遍历](#589-n叉树的前序遍历)

<!-- /TOC -->

## 常用命令

存放不确定长度数组：`List<Integer> list = new ArrayList<Integer>();`

数组增加：`list.add()`

栈操作:`pop(), isEmpty(), push(), peek()`

N叉树中提取子节点：`root.children.get(i)`

## 104. 二叉树的最大深度

递归遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : (1+ Math.max(maxDepth(root.left), maxDepth(root.right)));
    }
}
```

## 559. N叉树的最大深度

DFS递归

```java
class Solution {
    public int maxDepth(Node root) {
        if(root == null) return 0;
        int depth = 0;
        
        for(int i=0; i<root.children.size(); i++){
            depth = Math.max(depth, maxDepth(root.children.get(i)));
        }
        return depth+1;
    }
}
```

层次遍历

```java
public int maxDepth(Node root) {
    if(root == null)
        return 0;
    if(root.children.size() == 0)
        return 1;
    int depth = 0;
    Queue<Node> queue = new LinkedList<Node>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        depth++;
        while(count > 0){
            Node node = queue.poll();
            if(node.children.size() != 0)
                queue.addAll(node.children);              
            count--;                
        }
    }
    return depth;        
}
```

## 617. 合并二叉树

### 基本思路

1. 判断t1和t2是否为空，给val赋值并赋值
2. 分别递归t1,t2左节点和t1,t2右节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        TreeNode newtree = null;
        int val = 0;
        
        if(t1 != null && t2 != null){
            val = t1.val + t2.val;
            newtree = new TreeNode(val);
            
            newtree.left = mergeTrees(t1.left, t2.left);
            newtree.right = mergeTrees(t1.right, t2.right);
        } else if( t1 != null){
            newtree = new TreeNode(t1.val);
            
            newtree.left = mergeTrees(t1.left, null);
            newtree.right = mergeTrees(t1.right, null);
        }else if( t2 != null){
            newtree = new TreeNode(t2.val);
            
            newtree.left = mergeTrees(null, t2.left);
            newtree.right = mergeTrees(null, t2.right);
        }else{
            newtree = null;
        }
        return newtree;
    }
}
```

### 改进

无需新建一个树去存放结果，在t1上操作合并递归即可

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        // 节点的值合并
        t1.val = t1.val + t2.val;
        // 继续
        t1.left =  mergeTrees(t1.left, t2 != null ? t2.left : null);
        t1.right = mergeTrees(t1.right, t2 != null ? t2.right : null);
        return t1;
    }
}
```

## 226. 翻转二叉树

左右置换，递归左右节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
         if (root != null) {
            TreeNode tmpNode = root.left;
            root.left = root.right;
            root.right = tmpNode;
            invertTree(root.left);
            invertTree(root.right);
        }
        return root;
    }
}
```

## 965. 单值二叉树

### 基本思路

对root.val进行判断，root子节点分成四种情况讨论

```java
class Solution {
    
    public boolean isUnivalTree(TreeNode root) {
        int cap = root.val;
        return tree(root, cap);
    }
    
    public boolean tree(TreeNode root, int cap){
        if(root.val != cap){
            return false;
        }
        else if(root.left == null && root.right == null){
            return true;
        } 
        else if(root.left == null && root.right != null){
            return tree(root.right, cap);
        }
        else if(root.left != null && root.right == null){
            return tree(root.left, cap);
        }
        else{
            return tree(root.right, cap) && tree(root.left, cap);
        }
    }
}
```

### 改进

没明白= =

```java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        return val(root) > -1;
    }
    
    public int val(TreeNode r){
        int v = r.val;
        if(r.left!=null && val(r.left) != v)
            return -1;
        if(r.right!=null && val(r.right) != v)
            return -1;
        return v;
    }
}
```

## 700. 二叉搜索树中的搜索

判断值是等还是大于还是小于

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) return null;
        if(root.val == val){
            return root;
        }
        else if(root.val > val){
            return searchBST(root.left, val);
        }
        else{
            return searchBST(root.right,val);
        }
    }
}
```

## 590. N叉树的后序遍历


### 基本思路

建立两个Stack，一个用于把每层放入，再每层弹出给下一个stack和把root交给子节点。下一个stack用于把值传递给list。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> list = new ArrayList<Integer>();
        
        if(root == null) return list;
        if(root.children == null){
            list.add(root.val);
            return list;
        }
        
        Stack<Node> stack = new Stack<Node>();
        Stack<Node> restack = new Stack<Node>();
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            restack.push(root);
            for(int i=0; i<root.children.size(); i++){
                stack.push(root.children.get(i));
            }
        }
        
        while(!restack.isEmpty()){
            list.add(restack.pop().val);
        }
        return list;
    }
}

```

### 改进

递归思想，遍历root.children并作为node递归。

```java
class Solution {
    List<Integer> list = new ArrayList();

    public List<Integer> postorder(Node root) {
        if (root != null) {
            for (Node node : root.children) {
                postorder(node);
            }
            list.add(root.val);
        }
        return list;
    }
}
```

## 589. N叉树的前序遍历

与后序方法类似，只需要更改list添加数的位置。

```java
class Solution {

    List<Integer> list = new ArrayList();

    public List<Integer> preorder(Node root) {
        if (root != null) {
            list.add(root.val);
            for (Node node : root.children) {
                preorder(node);
            }
        }
        return list;
    }
}
```