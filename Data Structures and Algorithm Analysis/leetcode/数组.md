<!-- TOC -->

- [常用命令](#常用命令)
- [905. 按奇偶排序数组](#905-按奇偶排序数组)
    - [基本思路](#基本思路)
    - [改进](#改进)
- [832. 翻转图像](#832-翻转图像)
    - [基本思路](#基本思路-1)
    - [改进](#改进-1)
- [461. 汉明距离](#461-汉明距离)
    - [基本思路](#基本思路-2)
    - [改进](#改进-2)
- [942. 增减字符串匹配](#942-增减字符串匹配)
    - [思路](#思路)
- [922.按奇偶排序数组II](#922按奇偶排序数组ii)
    - [思路](#思路-1)
    - [改进](#改进-3)
- [852. 山脉数组的峰顶索引](#852-山脉数组的峰顶索引)
    - [基本思路](#基本思路-3)
    - [改进](#改进-4)
- [961. 重复N次元素](#961-重复n次元素)
    - [基本思路](#基本思路-4)
    - [改进](#改进-5)
- [476. 数字的补救](#476-数字的补救)
- [728. 自然数](#728-自然数)
- [867. 转置矩阵](#867-转置矩阵)
- [258. 各位相加](#258-各位相加)
    - [基本思路](#基本思路-5)
    - [非递归循环方法](#非递归循环方法)
- [908. 最小差值I](#908-最小差值i)
- [561. 数组拆分I](#561-数组拆分i)
    - [基本思想](#基本思想)
    - [改进](#改进-6)
- [693. 交替位二进制数](#693-交替位二进制数)
- [118. 杨辉三角](#118-杨辉三角)
- [349. 两个数组的交集](#349-两个数组的交集)
    - [基本思路](#基本思路-6)
    - [改进](#改进-7)
- [463. 岛屿的周长](#463-岛屿的周长)
    - [优化](#优化)
- [509. 斐波那契数列](#509-斐波那契数列)
- [566. 重塑矩阵](#566-重塑矩阵)
    - [基本思路](#基本思路-7)
    - [改进](#改进-8)
- [575. 分糖果](#575-分糖果)
    - [基本思路](#基本思路-8)
    - [空间换时间](#空间换时间)
- [496. 下一个更大元素I](#496-下一个更大元素i)
    - [基本思路](#基本思路-9)
    - [优化](#优化-1)
- [883. 三维形体投影面积](#883-三维形体投影面积)
    - [基本思路](#基本思路-10)
    - [优化](#优化-2)
- [13. 罗马数字转整数](#13-罗马数字转整数)
- [136. 只出现一次的数字](#136-只出现一次的数字)
    - [基本思路](#基本思路-11)
    - [改进](#改进-9)
- [868. 二进制间距](#868-二进制间距)
    - [基本思路](#基本思路-12)
    - [改进](#改进-10)
- [766. 托普利茨矩阵](#766-托普利茨矩阵)
- [762. 二进制表示中质数个计算置位](#762-二进制表示中质数个计算置位)
    - [基本思路](#基本思路-13)
    - [改进](#改进-11)
- [9. 回文数](#9-回文数)
    - [基本方法](#基本方法)
    - [改进](#改进-12)
    - [API方法](#api方法)
- [169. 求众数](#169-求众数)
- [119.杨辉三角II](#119杨辉三角ii)
- [27. 移除元素](#27-移除元素)
- [283. 移动零](#283-移动零)
- [447. 回旋镖的数量](#447-回旋镖的数量)
- [485. 最大连续1的个数](#485-最大连续1的个数)
- [788. 旋转数字](#788-旋转数字)
- [202. 快乐数](#202-快乐数)
- [121. 买股票的最佳时机](#121-买股票的最佳时机)
    - [基本思路](#基本思路-14)
    - [最优解](#最优解)
- [122. 买股票的最佳时机II](#122-买股票的最佳时机ii)
- [303. 区域和检索-数组不可变](#303-区域和检索-数组不可变)
- [453. 最小移动次数使数组元素相等](#453-最小移动次数使数组元素相等)
    - [数学方法](#数学方法)
    - [逆向思维](#逆向思维)
- [860. 柠檬水找零](#860-柠檬水找零)
- [696. 计算二进制子串](#696-计算二进制子串)
- [268. 缺失数字](#268-缺失数字)
    - [基本思路](#基本思路-15)
    - [改进](#改进-13)
- [506. 相对名次](#506-相对名次)
- [896. 单调数列](#896-单调数列)
    - [基本思路](#基本思路-16)
    - [改进](#改进-14)
- [704. 二分查找](#704-二分查找)
- [455. 分发饼干](#455-分发饼干)
- [598. 范围求和II](#598-范围求和ii)

<!-- /TOC -->

## 常用命令

转换二进制字符: `String x = Integer.toBinaryString(x);`

转换二进制选择位：`Integer.bitCount(i)`

长度判断:`String.lengeth(); char.length;`

* length用于计算字符串数组，length()用于字符长度

二进制数最左边的最高位，且高位后面全部补零：`Integer.highestOneBit(num) `

&位与运算，0可以清零，1可以保护

^异或原则：相同的数异或返回0，0与任何数异或返回任何数，异或之间相互交换异或皆可。

## 905. 按奇偶排序数组

### 基本思路

遍历数组，偶数正向赋值给新数组，奇数反向赋值给新数组。

```java
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int[] doub = new int[A.length];
        int d = 0;
        int l = A.length - 1;
                    
        for(int i=0 ; i<A.length; i++){

            if(A[i] % 2 == 0){
                doub[d] = A[i];
                d++;
            }
            else{
                doub[l] = A[i];
                l--;
            }
            
        }
        return doub;
    }
}
```

### 改进

基本的方法开辟了额外空间，不开辟新空间可以遍历数组，找到第一个奇数后就从当前位置搜索下一个偶数，并交换。不过效率不一定高。

```python
class Solution:
    def sortArrayByParityII(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        A_len, i, j = len(A), 0, 1
        while i < A_len:
            if A[i] % 2 == 1:
                while A[j] % 2 == 1:
                    j += 2
                
                A[i], A[j] = A[j], A[i]

            i += 2

        return A
```

## 832. 翻转图像

### 基本思路

1. 获取数列行列
2. 固定行进行反转和取反
3. 遍历列

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int lineLen = A.length;
        int columnLen = A[0].length;        
        int picture [][] = new int[lineLen][columnLen];
        
        
        for (int i=0; i < lineLen; i++){
            int copy = columnLen - 1;
            for(int j=0; j < columnLen; j++){
                picture[i][j] = A[i][copy];
                copy--;
                notA(picture, i, j);
            }
        }
        return picture;
    }

    public void notA(int[][] A,int x,int y){
            if(A[x][y] ==0){
                A[x][y] =1;
            }else{A[x][y] =0;}
    }    
}
```

### 改进

每行的取反和头尾交换其实不需要遍历整个数组，只需要一个临时数去存储头，然后把头尾交换取反即可，交换到中间就整行交换结束。

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        for(int i =0;i<A.length;i++){
            int temp;
            int front = 0;
            int end = A[i].length-1;
            while(front <=end ){ //一行的交换取反
                temp = A[i][front]; //头存在临时里面
                A[i][front] = 1-A[i][end]; //头等于尾且取反
                A[i][end] = 1-temp; //临时取反
                front ++;
                end --;
            }
        }
        return A;
    }
}
```

## 461. 汉明距离

### 基本思路

1. x与y转换成2进制，并且补位成等长
2. 遍历比较每一位，累计不同

```java
class Solution {
    public int hammingDistance(int x, int y) {
        String xTwo = Integer.toBinaryString(x);
        String yTwo = Integer.toBinaryString(y);
        int xlength = xTwo.length();
        int ylength = yTwo.length();
        
        if(xlength < ylength){                        
            for(int i=0;i < ylength - xlength;i++)
                xTwo = "0"+xTwo;                  
        }
        else{
            for(int i=0;i < xlength - ylength;i++)
                yTwo = "0"+yTwo;     
        }
        
        char[] xc = xTwo.toCharArray();
        char[] yc = yTwo.toCharArray();
        //System.out.printf("%s, %s", xTwo, yTwo);
        int count = 0;
        for(int i=0; i<xc.length; i++){
            if(xc[i] != yc[i]){
                count++;
            }
        }
        return count;
    }
}
```

### 改进

1. 主要核心是异或(^),相同为0，不同为1；
2. 统计异或以后为1的位；

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int i = x ^ y;
        int c = 0;
        while(i > 0){
            // 最后一位是否为1
            if((i & 1) == 1){//位与运算，都为1为1
                c ++;
            }
            i = i >> 1;
        }
        return c;
    }
}
```

## 942. 增减字符串匹配

### 思路

读到I从小到达排列，读到D从大到小排列

```java
class Solution {
    public int[] diStringMatch(String S) {
        int N = S.length();
        char[] ss = S.toCharArray();
        int min = 0;
        int max = S.length();
        int[] result = new int[N+1];
        
        for(int i=0; i < N ; i++){
            if(ss[i] == 'I'){
                result[i] = min;
                min++;
            }
            if(ss[i] == 'D'){
                result[i] = max;
                max--;
            }
        }
        result[N] = max;
        return result;
    }
}
```

## 922.按奇偶排序数组II

### 思路

创建一个新数组存储，从A判断来的奇偶数

```java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int ou = 0;
        int ji = 1;
        int[] B = new int[A.length];
        
        for(int i = 0; i < A.length; i++){
            if(A[i]%2 == 0){
                B[ou] = A[i];
                ou = ou + 2;
            }
            else{
                B[ji] = A[i];
                ji = ji + 2;
            }
        }
        return B;
    }
}
```

### 改进

对于`if(A[i]%2 == 0)`优化成`if(A[i] & 1 == 0)`

## 852. 山脉数组的峰顶索引

### 基本思路

遍历找到最大值

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        int max = A[0];
        int index = 0;
        
        for(int i=1;  i<A.length; i++){
            if(A[i] > A[index]){
                max = A[i];
                index = i;
            }
        }
        return index;
    }
}
```

### 改进

二分法

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        return mountainIndex(A,0,A.length - 1);
    }
    
    public static int mountainIndex(int[] A,int l,int r) {
            int mid = l + (r - l) / 2;
            if(A[mid] > A[mid - 1] && A[mid] > A[mid + 1])
                return mid;
            else if(A[mid] < A[mid + 1])
                return mountainIndex(A,mid+1,r);
            else
                return mountainIndex(A,l,mid);
        
    }
}
```

## 961. 重复N次元素

### 基本思路

1. 对A进行排序，遍历A
2. 记录重复次数，满足一半就返回；不满足就重置计数

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Arrays.sort(A);
        int ret = A[0];
        int num = 0;
        
        for(int i=0; i < A.length; i++){
            if(A[i] != ret){
                ret = A[i];
                num = 1;
            }
            else{
                num++;
                if(num == A.length/2){
                    return ret;
                }
            }
        }
        return ret;
    }
}
```

### 改进

最快速度是使用set，长度为A/2+1，当无法存储时即此为结果

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Set<Integer> set = new HashSet<>(A.length / 2 + 1);
        for (int i : A) {
            if (!set.add(i)) {
                return i;
            }
        }
        return 0;
    }
}
```

由于有一半数肯定是相同的，只需要排序后判断最后一个数和中间右是否相同，如果相同则后一半都为答案数，如果不同则中间左边一位肯定是。

```java
public int repeatedNTimes(int[] A) {
    Arrays.sort(A);
    return A[A.length / 2] == A[A.length - 1] ? A[A.length - 1] : A[A.length / 2 - 1];
}
```

* 此方法速度最慢，只是简洁。

## 476. 数字的补救

主要注意取反头有补码表示正负

1. highestOneBit(num)最高为置1,-1以后首位为0其它为1。
2. &保证补码为0不干扰数字

```java
class Solution {
    public int findComplement(int num) {
        return ~num&(Integer.highestOneBit(num)-1);
    }
}
```

## 728. 自然数

使用/=10迭代来实现移位，使用%10来取右边最后一位。

```java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> res = new ArrayList<>();
        for(int i = left; i <= right; i++){
            if(check(i)) res.add(i);
        }
        return res;
    }
    
    private boolean check(int n){
        int d =n;
        while(d != 0){
            int test = d % 10;
            if(test == 0 || (n % test) != 0) {return false;}
            d /= 10;
        }
        return true;
    }
}
```

## 867. 转置矩阵

行列交换即可

```java
class Solution {
    public int[][] transpose(int[][] A) {
        if( A == null) return null;
        
        int[][] result = new int[A[0].length][A.length];
        
        for(int i=0; i < A[0].length; i++){
            for(int j=0; j< A.length; j++){
                result[i][j] = A[j][i];
            }
        }
        return result;
    }
}
```

## 258. 各位相加

### 基本思路

```java
class Solution {
    public int addDigits(int num) {
        int sum = (num/10)+(num%10);//8,1
        
        while(sum > 9){
            sum = addDigits(sum);
        }
        return sum;
    }
}
```

### 非递归循环方法

数字根是模9的值,-1+1是因为9,99,999。。。。

```java
class Solution {
    public int addDigits(int num) {
        if(num < 10) {
            return num;
        }else {
            return ((num - 1) % 9) + 1;
        }
    }
}
```

## 908. 最小差值I

题目转化为MAX-MIN-2x求最小值,其中x为-k<=x<=k.

如果x=k时结果大于0即最小值，小于0即0为最小差值。

```java
class Solution {
    public int smallestRangeI(int[] A, int K) {
        int max=Integer.MIN_VALUE;;
        int min=Integer.MAX_VALUE;;
        
        for(int i : A){
            max = i > max ? i : max;
            min = i < min ? i : min;
        }
        return Math.max(max-min - Math.abs(2*K), 0);
    }
}
```

## 561. 数组拆分I

### 基本思想

转换为数组从小到大，每间隔一个选取。

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        
        int res = 0;
        for(int i=0; i<nums.length; i=i+2){
            res += nums[i];
        }
        return res;
    }
}
```

### 改进

可以不使用默认排序改为使用桶排序

## 693. 交替位二进制数

一位位计算与下一位比较即可

```java
class Solution {
    public boolean hasAlternatingBits(int n) {

        int cur = n%2;
            n = n/2;
        while(n > 0){
            if( cur == n%2 ){
                return false;
            }
            cur = n%2;
            n = n/2;
        }
        return true;

    }
}
```

## 118. 杨辉三角

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        int[][] array = new int [numRows][numRows];
        
        for(int i=0; i<numRows; i++){
            List<Integer> list = new ArrayList<Integer>();
            for(int j=0; j<=i; j++){//一行
                if(j == 0 || j == i) {array[i][j] = 1;}
                else{
                    array[i][j] = array[i-1][j-1] + array[i-1][j];
                }
                list.add(array[i][j]);
            }
            res.add(list);
        }
        return res;
    }
}
```

## 349. 两个数组的交集

### 基本思路

set实现单个数组无重复数，set.contains()选取重复数，iterator().hasNext()迭代器遍历set读取结果。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        for (int i=0; nums1 != null && i<nums1.length; i++){
            set1.add(nums1[i]);
        }
        for (int i=0; nums2 != null && i<nums2.length; i++){
            if(set1.contains(nums2[i])){
                set2.add(nums2[i]);
            }            
        }
        
        if (set2.isEmpty()) {
            return new int[0];
        }

        int[] res = new int[set2.size()];
        Iterator<Integer> iterator = set2.iterator();
        int idx = 0;
        while (iterator.hasNext()) {
            res[idx++] = iterator.next();
        }

        return res;
        
    }
}
```

### 改进

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        
        for (int num1:nums1) { //找到nums1中最大最小值
            max = Math.max(num1, max);
            min = Math.min(num1, min);
        }
        
        boolean[] marks = new boolean[max-min+1];
        for (int num1:nums1) { //记录num1在marks中有的数
            marks[num1-min] = true;
        }
        
        int index = 0;
        for (int num2:nums2) {
            
            if (num2 < min || num2 > max) {//跳过num2中比num1中最大值大最小值小的数
                continue;
            }
            
            if (marks[num2-min]) {//用num1之前赋值好了增加的组进行判断，num2负责读取
                nums2[index++] = num2; // 合理使用 nums2 数组，将符合条件的数放到 nums2 的前面索引位置
                marks[num2-min] = false; // 设置 false，重复的数字就会被过滤掉
            }
        }
        
        return Arrays.copyOf(nums2, index); // 取 num2 数组从 0 开始 index 长度的子数组
    }
}
```

## 463. 岛屿的周长

设定几个规则:
1. 读到1的数就记4
2. 读到与右或下都是1就减2
3. 为了避免最后和最下的数组的越界需要停止扫描
4. 为了避免1行或1列的越界需要设置扫描行列的最小行列数

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int res = 0;
        int sum = 0;
        
        for(int j=0; j<grid[0].length; j++){
            for(int i=0; i<grid.length; i++){
                if((i<grid.length-1) && (grid.length>1)){//扫描上下，最后一行停止
                    if (grid[i][j] == 1 && grid[i][j] == grid[i+1][j]){
                    sum+=2;
                    }
                } 
                if((j<grid[0].length-1) && (grid[0].length>1)){//扫描左右，最后一列停止
                    if (grid[i][j] == 1 && grid[i][j] == grid[i][j+1]){
                    sum+=2;
                    }
                }
                
                if (grid[i][j] == 1){
                    res+=4;
                }
            }  
        }
        res = res - sum;
        return res;
    }
}
```

### 优化

1. 首先无论是扫描上下还是左右都需要判断是否为1，可以放在最外层
2. 为了避免越界和只有1行1列的情况，应该使用右判断左，下判断上，同时第一行第一列不用记，即可同时考虑到两种越界问题。

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int count = 0;//record the value of the answer
        for(int i = 0;i < grid.length;i++){
            for(int j = 0;j < grid[0].length;j++){
                if(grid[i][j] == 1){
                    count += 4;
                    if(i - 1 >= 0 && grid[i - 1][j] == 1){
                        count -= 2;
                    }
                    if(j - 1 >= 0 && grid[i][j - 1] == 1){
                        count -= 2;
                    }
                }

            }
        }
        return count;
    }
}
```

## 509. 斐波那契数列

```java
class Solution {
    public int fib(int N) {
        int res = 0;
        int temp0 = 0;
        int temp1 = 1;
        
        if(N==0)return 0;
        else if(N==1)return 1;
        else{
            for(int i=1; i<N; i++){
                res = temp0 + temp1;
                temp0 = temp1;
                temp1 = res;
            }
            return res;
        }
        
    }
}
```

## 566. 重塑矩阵

### 基本思路

把二维变成一维再重新转成二维

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int han = nums.length;
        int lie = nums[0].length;
        int[][] res = new int[r][c];
        int[] num = new int[han*lie];
        
        if(r*c != han*lie) return nums;
        else{
            int nn = 0;
            for(int ii=0; ii<han; ii++){//二维数组转换成一维
                for(int jj=0; jj<lie; jj++){
                    num[nn] = nums[ii][jj];
                    nn++;
                }
            }
            int n = 0;
            for(int i=0; i<r; i++){//转化成二维
                for(int j=0; j<c; j++){
                    res[i][j] = num[n];
                    n++;
                }
            }
        }
        return res;       
    }
}
```

### 改进

行列的转换公式为:[n/col][n%col]

* n为第n个数

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        
           int row = nums.length;
           int col = nums[0].length;
           int[][] res = new int[r][c];
           int n = 0;
        
            if (nums.length == 0 || r * c != row * col){
                return nums;
            }
        
            for (int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    res[n / c][n % c] = nums[i][j];
                    n++;
                }
            }
            return res;
    }
}
```

## 575. 分糖果

### 基本思路

```java
class Solution {
    public int distributeCandies(int[] candies) {
        Set<Integer> set = new HashSet<>();
        for(int candie:candies){
            set.add(candie);
        }
        int cateage = set.size();
        int nums = candies.length;

        if(cateage <= nums/2){
            return cateage;
        }
        else{
            return nums/2;
        }
        //return set.size() >= candies.length / 2 ? candies.length / 2 : set.size();
    }
}
```

### 空间换时间

```java
class Solution {
    public int distributeCandies(int[] candies) {
        //简而言之，把一个数组分两半，让一半的元素尽可能多
        //元素种类数>=数组的1/2，则可保证一半数组每个元素都不一样
        //如果<1/2,取元素的种类数即可
        //重点在于求元素种类数 
        
        //空间换时间
        boolean[] bools = new boolean[200001];
        int count = 0;
        for(int i:candies){
            if(bools[i + 100000] == false){
                bools[i + 100000] = true;
                count++;
            }
        }
        return count > candies.length/2 ? candies.length/2 : count; 
        
    }
}
```

## 496. 下一个更大元素I

### 基本思路

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        int index = 0;
        for(int i=0; i<nums1.length; i++){
            for(int j=0; j<nums2.length; j++){//遍历2,找到与1相同的数就记录index
                if(nums1[i] == nums2[j]){
                    index = j;
                    break;
                }
            }
            for(int k=index; k<nums2.length; k++){//判断2中右边第一个比1大的数
                if(nums2[k] > nums1[i]) {
                    res[i]=nums2[k];
                    break;
                }
                else{res[i]=-1;}
            }
        }
        return res;
    }
}
```

### 优化

在遍历2中找1的方法可以使用空间换时间的方法：
1. 找到2的最大值
2. 建立一个长度为最大值+1的数组bitmap，把2的值当作index放入到数组中，并为数组填充等值的数
3. 比较2中比1大的数的起始点以bitmap[nums1[i]]+1作为起点即可

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int l1 = nums1.length, l2 = nums2.length;
        int[] result = new int[l1];

        int max = 0;
        for (int i = 0; i < l2; i++)//步骤1
            if (nums2[i] > max)
                max = nums2[i];

        int[] bitmap = new int[max + 1];
        for (int i = 0; i < l2; i++)//步骤2
            bitmap[nums2[i]] = i;
        

        for (int i = 0; i < l1; i++) {//判断2中右边第一个比1大的数
            int n1 = nums1[i], m = -1;
            int idx = bitmap[n1];
            for (int j = idx + 1; j < l2; j++)
                if (nums2[j] > n1) {
                    m = nums2[j];
                    break;
                }
            result[i] = m;
        }

        return result;
    }
}
```

## 883. 三维形体投影面积

### 基本思路

三个参数相加和，分别为俯视非零数，从行看和从列看

```java
class Solution {
    public int projectionArea(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int res = 0;       
        int maxx = 0;
        int maxy = 0;
        int zero = 0;

        for(int j=0; j<col; j++){//删去俯视时为0
            for(int i=0; i<row; i++){
                if(grid[i][j] == 0) zero++;    
            }
        }
        
        for(int j=0; j<col; j++){//从行看
            int colmax = 0;
            for(int i=0; i<row; i++){
                if(grid[i][j]>colmax) colmax = grid[i][j];
            }
             
            maxx += colmax;
        }
        
        for(int i=0; i<row; i++){//从列看
            int rowmax = 0;
            for(int j=0; j<col; j++){
                if(grid[i][j]>rowmax) rowmax = grid[i][j];
            }
            maxy += rowmax;
        }
        res = row * col - zero + maxx + maxy;
        return res;
    }
}
```

### 优化

俯视非零数可以在遍历行或者列时每次非零加一，最值可以使用Math.max

```java
class Solution {
    public int projectionArea(int[][] grid) {
        int max=0;
        int l=grid.length;
        int w=grid[0].length;
        for(int i=0;i<l;i++){
            int max1=0;
            for(int j=0;j<w;j++){
                if(grid[i][j]!=0)
                    max+=1;
                max1=Math.max(max1,grid[i][j]);
            }
            max+=max1;
        }
        for(int i=0;i<w;i++){
            int max1=0;
            for(int j=0;j<l;j++){
                max1=Math.max(max1,grid[j][i]);
            }
            max+=max1;
        }    
        return max;
    }
}
```

## 13. 罗马数字转整数

```java
class Solution 
{
   public int romanToInt(String s) 
   {
    int nums[]=new int[s.length()];
    for(int i=0;i<s.length();i++)
    {
        switch (s.charAt(i))
        {
            case 'M':
                nums[i]=1000;
                break;
            case 'D':
                nums[i]=500;
                break;
            case 'C':
                nums[i]=100;
                break;
            case 'L':
                nums[i]=50;
                break;
            case 'X' :
                nums[i]=10;
                break;
            case 'V':
                nums[i]=5;
                break;
            case 'I':
                nums[i]=1;
                break;
        }
    }
    int sum=0;
    for(int i=0;i<nums.length-1;i++)
    {
        if(nums[i]<nums[i+1])
            sum-=nums[i];
        else
            sum+=nums[i];
    }
    return sum+nums[nums.length-1];//最后一个数
   }
}
```

## 136. 只出现一次的数字

### 基本思路

将数组排序，两两比较不同的就是只出现一次的。

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i =1; i< nums.length; i+=2){
            if(nums[i-1] != nums[i]){
                return nums[i-1];
            }
        }
        return nums[nums.length-1];
    }
}
```

### 改进

异或原则：相同的数异或返回0，0与任何数异或返回任何数，异或之间相互交换异或皆可。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int temp =0;
        for(int i=0;i<nums.length;i++){
            temp ^=nums[i];
        }
        return temp;
    }
}
```

## 868. 二进制间距

### 基本思路

转换2进制，读到一就记录位置，另外设置一个计数避免第一次读到数也记录位置

```java
class Solution {
    public int binaryGap(int N) {
        String NN = Integer.toBinaryString(N);
        char[] n = NN.toCharArray();
        int distance = 0;
        int index = 0;
        int index1 = 0;
        int ind = 0;
        for(int i=0; i<n.length; i++){
            if(n[i] == '1') {
                index1 = index;
                index = i;
                ind++;
            }
            if(ind>1) distance = Math.max(distance, index-index1);
        }
        return distance;
    }
}
```

### 改进

```java
public int binaryGap(int N) {
    int left = -1, right = -1, maxLen = 0, pos = 0;
    while (N != 0) {
        if (N % 2 == 1) {
            if (left == -1)//第一次
                left = pos;
            else {
                right = pos;
                maxLen = Math.max(maxLen, right - left);
                left = pos;
            }
        }
        pos++;
        N /= 2;
    }
    return maxLen;
}
```

## 766. 托普利茨矩阵

相同值的元素坐标符合[+1，+1]

```java
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        
        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][j] != matrix[i-1][j-1])return false;
            }
        }
        return true;
    }
}
```

## 762. 二进制表示中质数个计算置位

### 基本思路



```java
class Solution {
    public int countPrimeSetBits(int L, int R) {
        int res = 0;
        for(int nums=L; nums<=R; nums++){
            int count = 0;
            int num = nums;
            while(num>0){//转二进制
                int bri = num%2;
                if(bri == 1) count++;
                num=num/2;
            }
            if(count==2) res++;
            for(int i=2;i<count;i++){//判断质数
                if(count%i==0){
                    break;
                }
                if(i==count-1)res++;
            }            
        }
        return res;
    }
}
```

### 改进

把质数列出来

```java
class Solution {
    public int countPrimeSetBits(int L, int R) {
        boolean[] primes = new boolean[33];
        primes[2] = true;
        primes[3] = true;
        primes[5] = true;
        primes[7] = true;
        primes[11] = true;
        primes[13] = true;
        primes[17] = true;
        primes[19] = true;
        primes[23] = true;
        primes[29] = true;
        primes[31] = true;
        
        int count = 0;
        for(int i=L; i<=R; i++) {
            if (primes[Integer.bitCount(i)]) {
                count++;
            }
        }
        return count;
    }
```

## 9. 回文数

### 基本方法

使用数组对头尾比较

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0)return false;
        String X = String.valueOf(x);
        char[] xx = X.toCharArray();
        int len = xx.length;        
        for(int i=0; i<len/2+1; i++){
            if(xx[i] != xx[len-1-i]) return false; 
        }
        return true;
    }
}
```

### 改进

```java
class Solution {
    public boolean isPalindrome(int x) {
        
        /**************双指针算法*********************/
        if (x < 0) return false;
        int d = 1;
        while (x/d >= 10) {
            d *= 10;//得到x一共有多少位
        }
        while (x > 0) {
            //q是当前最高位
            int q = x/d;
            //r是当前最低位
            int r = x%10;
            if (q != r) return false;
            //注意这里是将比较完的最高最低位去掉
            x = x%d/10;
            //d也同时去掉两个0，因为x将最高最低同时去掉
            d /= 100;
        }
        return true;
    }
}
```

### API方法

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0){
            return false;
        }
        String str1 = String.valueOf(x);
        String str2 = new StringBuffer(str1).reverse().toString();
        return str1.equals(str2);
    }
}
```

## 169. 求众数

投票计数，遇到相同加一，不同减一，为0换下一个数。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 1;
        int maj = nums[0];
        for(int i=1; i<nums.length; i++){
            if(maj == nums[i])count++;
            else{
                count--;
                if(count==0) maj=nums[i+1];
            }
        }
        return maj;
    }
}
```

## 119.杨辉三角II

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> list = new ArrayList<>();
        int[][] array = new int[rowIndex+1][rowIndex+1];
        for(int i=0; i<=rowIndex; i++){         
            for(int j=0; j<=i; j++){
                if(j==0 || j==i){array[i][j] = 1;}
                else{array[i][j] = array[i-1][j-1] + array[i-1][j];}
                if(i==rowIndex){list.add(array[i][j]);} 
            }
        }
        return list;
    }
}
```

## 27. 移除元素

每次循环计数，不是需要删去的放在计数位置

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length == 0 || nums == null)    return 0;

        int res = 0;
        for (int i = 0; i < nums.length; i++){
            if(nums[i] != val){
                nums[res++] = nums[i];
            }
        }
        return res;
    }
}
```

## 283. 移动零

判断是不是零，不是零就依次存储，最后末尾全部填0；

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //int i = 0;
        int j = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i] != 0) nums[j++] = nums[i];
        }
        while(j < nums.length){
            nums[j++] = 0;
        }
    }
}
```

## 447. 回旋镖的数量

```java
class Solution{
    public int numberOfBoomerangs(int[][] p) {
        int count = 0;
        Map<Integer,Integer> map = new HashMap<>(p.length);
        for(int[] i: p){
            for(int[] j: p){//每一个数与其他所有树的距离存在map里
                int dx=i[0]-j[0];
                int dy=i[1]-j[1];
                int d = dx*dx+dy*dy;
                Integer value = map.get(d);
                if(value!=null){
                    count+=2*value;
                    map.put(d,value+1);
                } else 
                    map.put(d,1);
            }
            map.clear();//每个数结束需要清除
        }
        return count;
    }
}
```

## 485. 最大连续1的个数

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int res = 0;
        int compera = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i] == 1){
                compera+=1;
            }else{
                res = Math.max(res, compera);
                compera = 0;
            }
             res = Math.max(res, compera);
        }
        return res;
    }
}
```

## 788. 旋转数字

```java
class Solution {
    public int rotatedDigits(int N) {
        //每位都在(2, 5, 6, 9, 0, 1, 8)内，至少一位在(2, 5, 6, 9)内
        int count = 0;
        for(int i=1; i<=N; i++){
            if(isGoodNum(i)) count++;
        }
        return count;
    }
    private boolean isGoodNum(int x){
        boolean flag = false;
        while(x!=0){
            int t = x%10;
            if(t==3||t==4||t==7){
                return false;
            }
            else if(t==2||t==5||t==6||t==9){
                flag = true;
            }
            x=x/10;
        }
        return flag;
    }
}
```

## 202. 快乐数

不快乐数会在:4,16,37,58,89,145,42,20里循环

```java
class Solution {
    public boolean isHappy(int n) {
        while(n!=4 && n!=16 && n!=37 && n!=58 && n!=89 
                && n!=145 && n!=42 && n!=20 && n!=1){
            int num = 0;
            int t=0;
            while(n!=0){
                t = n%10;
                num +=t*t;            
                n/=10;
            }
            n = num;
        }
        if(n==1)return true;
        return false;
    }
}
```

## 121. 买股票的最佳时机

### 基本思路

每个数与后续所有数做差，保存最大值

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res=0;
        for(int j=0;j<prices.length; j++){
            for(int i=j+1; i<prices.length; i++){
                res = Math.max(res, prices[i]-prices[j]);
            }
        }
        if(res>0) return res;
        else return 0;
    }
}
```

### 最优解

遍历数组，同时寻找最小值，如果是最小值存储，如果不是与最小值做差即为res。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int profit = 0;
        for(int i = 0; i < prices.length; i++){
            if(prices[i] < min)
                min = prices[i];
            else if(prices[i] - min > profit)
                profit = prices[i] - min;
        }
        return profit;
    }
}
```

## 122. 买股票的最佳时机II

利润=后一天比前一天多出来的累加

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0; 
        for(int i=0; i<prices.length-1; i++){
            if(prices[i+1] - prices[i] > 0) 
                profit += prices[i+1] - prices[i];
        }
        return profit;
    }
}
```

## 303. 区域和检索-数组不可变

本题重点在于两个函数直接不存在数值传递等，又由于sumRange会频繁使用，所以可以在队列里面创建一个等长的数组，存储对应的数组和，求值相减即可。

```java
class NumArray {
    
    private int[] sums;

    public NumArray(int[] nums) {
        sums= new int[nums.length];
        if(nums.length==0) return;
        sums[0] = nums[0];
        for(int i=1; i<nums.length; i++){
            sums[i] += sums[i-1] + nums[i];
        }
    }
    
    public int sumRange(int i, int j) {
        if(i==0)
            return sums[j];
        else{
            return sums[j]-sums[i-1];
        }
    }
}
```

## 453. 最小移动次数使数组元素相等

### 数学方法

设目标相加次数为x，最后每个数变成y。

首先，最小值一定每次一定会加1，所以y=minx+x。所以等式可以写成:sum+(n-1)*x=n*y

化简得：x=sum-n*min

```java
class Solution {
    public int minMoves(int[] nums) {
        int min=Integer.MAX_VALUE;
        int sum=0;
        for(int num:nums){
            if(num<min){
                min=num;
            }
            sum+=num;
        }
        return sum - min*nums.length;
    }
}
```

### 逆向思维

每次将数组中的n-1个数字加1，相当于将剩余的一个数字减1。所以只需找到数组中的最小值m，计算m与数组中其他数字差的累计和即可。

```java
class Solution {
public:
    int minMoves(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size(), res = 0;
        
        for (int i = 1; i < len; i++) {
            res += nums[i] - nums[0];
        }
        
        return res;
    }
};
```

## 860. 柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int num5 = 0;
        int num10 = 0;
        for(int bill:bills){
            if(bill==5) num5++;
            else if(bill==10&&num5>0){
                num5--;
                num10++;
            }
            else if(bill==20 && num10>0 && num5>0){
                num5--;
                num10--;
            }
            else if(bill==20 && num5>=3){
                num5 -= 3;
            }
            else return false;
        }
        return true;
    }
}
```

## 696. 计算二进制子串

一个用来记录阅读到连续相同数的个数left，一个保存上一个left数的preleft，遇到变化，在left和preleft中取最小数

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int preleft=0;
        int left=0;
        int res=0;
        char[] S;
        S = s.toCharArray();
        int pre = S[0];
        for(char ss:S){
            if(ss==pre) left+=1;
            else{
                res+=Math.min(left, preleft);
                preleft = left;
                left = 1;
                pre = ss;
            }        
        }
        res += Math.min(left, preleft);
        return res;
    }
}
```

## 268. 缺失数字

### 基本思路

API排序，提出不同

```java
class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i=0; i<nums.length; i++){
            if(nums[i] != i)
                return i;
        }
        return nums.length;
    }
}
```

### 改进

不用API，可以使用数组存储

```java
class Solution {
    public int missingNumber(int[] nums) {
        int[] res = new int[nums.length+1];
        for(int i=0; i<nums.length; i++){
            res[nums[i]] = 1;
        }
        for(int j=0; j<res.length; j++){
            if(res[j]!=1) return j;
        }
        return nums.length;
    }
}
```

也可以进行求和做差

```java
class Solution {
    public int missingNumber(int[] nums) {
        int sum=0,len=nums.length;
        for(int i=0;i<len;i++){
            sum+=nums[i];
        }
        return len*(len+1)/2 - sum;
    }
}
```

## 506. 相对名次

```java
class Solution {
    public String[] findRelativeRanks(int[] nums) {
        int maxNum = -1;
        for (int num : nums) {
            if (num > maxNum) {
                maxNum = num;
            }
        }
        int[] map = new int[maxNum + 1];
        for (int i = 0; i < nums.length; i++) {//存储位置
            map[nums[i]] = i + 1;
        }
        String[] res = new String[nums.length];
        int rank = 1;
        for (int i = map.length - 1; i > -1; i--) {
            int index = map[i];
            if (index > 0) {
                String value = "";
                if (rank == 1) {
                    value = "Gold Medal";
                } else if (rank == 2) {
                    value = "Silver Medal";
                } else if (rank == 3) {
                    value = "Bronze Medal";
                } else {
                    value = String.valueOf(rank);
                }
                res[index - 1] = value;
                rank++;
            }
        }
        return res;
    }
}
```

## 896. 单调数列

### 基本思路

```java
class Solution {
    public boolean isMonotonic(int[] A) {
        int index=0;
        if(A.length<=1) return true;//一个数
        while(A[index+1]==A[index]){//判断大小方向
            if(index==A.length-2)return true;
            index++;            
        }
        for(int i=0; i<A.length-1; i++){比较
            if(A[index+1]>A[index]){
                if(A[i+1]<A[i])return false;
            }
            else{
                if(A[i+1]>A[i])return false;
            }
        }
        return true;
    }
}
```

### 改进

```java
class Solution {
 public boolean isMonotonic(int[] A) {
        return increasing(A) || decreasing(A);
    }

    public boolean increasing(int[] A) {
        for (int i = 0; i < A.length - 1; ++i)
            if (A[i] > A[i+1]) return false;
        return true;
    }

    public boolean decreasing(int[] A) {
        for (int i = 0; i < A.length - 1; ++i)
            if (A[i] < A[i+1]) return false;
        return true;
    }
}
```

## 704. 二分查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int right = nums.length-1;
        int left = 0;
        int index;
        //if(nums.length ==0)return -1;
        //if(nums.length==1 && nums[0]!=target) return -1;
        while(right>=left){
            index = (right+left)/2;
            if(target>nums[index]){
                left = index+1;
            }
            else if(target<nums[index]){
                right = index-1;
            }
            else{
                return index;
            }
        }
        return -1;
    }
}
```

## 455. 分发饼干

贪心算法+排序

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int child = 0;
        int cookie = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        while(child < g.length && cookie < s.length){
            if(g[child] <= s[cookie])
                child++;
            cookie++;
        }
        return child;
    }
}
```

## 598. 范围求和II

其实就是求ops出现的行列的最小值

```java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        int a = m;
        int b = n;
        for (int i = 0; i < ops.length; i++) {
            int[] op = ops[i];
            a = op[0] >= a ? a : op[0];
            b = op[1] >= b ? b : op[1];
        }
        return a * b;
    }
}
```