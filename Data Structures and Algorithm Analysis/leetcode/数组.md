<!-- TOC -->

- [常用命令](#常用命令)
- [905. 按奇偶排序数组](#905-按奇偶排序数组)
    - [基本思路](#基本思路)
    - [改进](#改进)
- [832. 翻转图像](#832-翻转图像)
    - [基本思路](#基本思路-1)
    - [改进](#改进-1)
- [461. 汉明距离](#461-汉明距离)
    - [基本思路](#基本思路-2)
    - [改进](#改进-2)
- [942. 增减字符串匹配](#942-增减字符串匹配)
    - [思路](#思路)
- [922.按奇偶排序数组II](#922按奇偶排序数组ii)
    - [思路](#思路-1)
    - [改进](#改进-3)
- [852. 山脉数组的峰顶索引](#852-山脉数组的峰顶索引)
    - [基本思路](#基本思路-3)
    - [改进](#改进-4)
- [961. 重复N次元素](#961-重复n次元素)
    - [基本思路](#基本思路-4)
    - [改进](#改进-5)
- [476. 数字的补救](#476-数字的补救)
- [728. 自然数](#728-自然数)
- [867. 转置矩阵](#867-转置矩阵)
- [258. 各位相加](#258-各位相加)
    - [基本思路](#基本思路-5)
    - [非递归循环方法](#非递归循环方法)
- [908. 最小差值I](#908-最小差值i)
- [561. 数组拆分I](#561-数组拆分i)
    - [基本思想](#基本思想)
    - [改进](#改进-6)
- [693. 交替位二进制数](#693-交替位二进制数)
- [118. 杨辉三角](#118-杨辉三角)
- [349. 两个数组的交集](#349-两个数组的交集)
    - [基本思路](#基本思路-6)
    - [改进](#改进-7)
- [463. 岛屿的周长](#463-岛屿的周长)
    - [优化](#优化)
- [509. 斐波那契数列](#509-斐波那契数列)
- [566. 重塑矩阵](#566-重塑矩阵)
    - [基本思路](#基本思路-7)
    - [改进](#改进-8)
- [575. 分糖果](#575-分糖果)
    - [基本思路](#基本思路-8)
    - [空间换时间](#空间换时间)

<!-- /TOC -->

## 常用命令

转换二进制字符: `String x = Integer.toBinaryString(x);`

长度判断:`String.lengeth(); char.length;`

* length用于计算字符串数组，length()用于字符长度

二进制数最左边的最高位，且高位后面全部补零：`Integer.highestOneBit(num) `

&位与运算，0可以清零，1可以保护

## 905. 按奇偶排序数组

### 基本思路

遍历数组，偶数正向赋值给新数组，奇数反向赋值给新数组。

```java
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int[] doub = new int[A.length];
        int d = 0;
        int l = A.length - 1;
                    
        for(int i=0 ; i<A.length; i++){

            if(A[i] % 2 == 0){
                doub[d] = A[i];
                d++;
            }
            else{
                doub[l] = A[i];
                l--;
            }
            
        }
        return doub;
    }
}
```

### 改进

基本的方法开辟了额外空间，不开辟新空间可以遍历数组，找到第一个奇数后就从当前位置搜索下一个偶数，并交换。不过效率不一定高。

```python
class Solution:
    def sortArrayByParityII(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        A_len, i, j = len(A), 0, 1
        while i < A_len:
            if A[i] % 2 == 1:
                while A[j] % 2 == 1:
                    j += 2
                
                A[i], A[j] = A[j], A[i]

            i += 2

        return A
```

## 832. 翻转图像

### 基本思路

1. 获取数列行列
2. 固定行进行反转和取反
3. 遍历列

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int lineLen = A.length;
        int columnLen = A[0].length;        
        int picture [][] = new int[lineLen][columnLen];
        
        
        for (int i=0; i < lineLen; i++){
            int copy = columnLen - 1;
            for(int j=0; j < columnLen; j++){
                picture[i][j] = A[i][copy];
                copy--;
                notA(picture, i, j);
            }
        }
        return picture;
    }

    public void notA(int[][] A,int x,int y){
            if(A[x][y] ==0){
                A[x][y] =1;
            }else{A[x][y] =0;}
    }    
}
```

### 改进

每行的取反和头尾交换其实不需要遍历整个数组，只需要一个临时数去存储头，然后把头尾交换取反即可，交换到中间就整行交换结束。

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        for(int i =0;i<A.length;i++){
            int temp;
            int front = 0;
            int end = A[i].length-1;
            while(front <=end ){ //一行的交换取反
                temp = A[i][front]; //头存在临时里面
                A[i][front] = 1-A[i][end]; //头等于尾且取反
                A[i][end] = 1-temp; //临时取反
                front ++;
                end --;
            }
        }
        return A;
    }
}
```

## 461. 汉明距离

### 基本思路

1. x与y转换成2进制，并且补位成等长
2. 遍历比较每一位，累计不同

```java
class Solution {
    public int hammingDistance(int x, int y) {
        String xTwo = Integer.toBinaryString(x);
        String yTwo = Integer.toBinaryString(y);
        int xlength = xTwo.length();
        int ylength = yTwo.length();
        
        if(xlength < ylength){                        
            for(int i=0;i < ylength - xlength;i++)
                xTwo = "0"+xTwo;                  
        }
        else{
            for(int i=0;i < xlength - ylength;i++)
                yTwo = "0"+yTwo;     
        }
        
        char[] xc = xTwo.toCharArray();
        char[] yc = yTwo.toCharArray();
        //System.out.printf("%s, %s", xTwo, yTwo);
        int count = 0;
        for(int i=0; i<xc.length; i++){
            if(xc[i] != yc[i]){
                count++;
            }
        }
        return count;
    }
}
```

### 改进

1. 主要核心是异或(^),相同为0，不同为1；
2. 统计异或以后为1的位；

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int i = x ^ y;
        int c = 0;
        while(i > 0){
            // 最后一位是否为1
            if((i & 1) == 1){//位与运算，都为1为1
                c ++;
            }
            i = i >> 1;
        }
        return c;
    }
}
```

## 942. 增减字符串匹配

### 思路

读到I从小到达排列，读到D从大到小排列

```java
class Solution {
    public int[] diStringMatch(String S) {
        int N = S.length();
        char[] ss = S.toCharArray();
        int min = 0;
        int max = S.length();
        int[] result = new int[N+1];
        
        for(int i=0; i < N ; i++){
            if(ss[i] == 'I'){
                result[i] = min;
                min++;
            }
            if(ss[i] == 'D'){
                result[i] = max;
                max--;
            }
        }
        result[N] = max;
        return result;
    }
}
```

## 922.按奇偶排序数组II

### 思路

创建一个新数组存储，从A判断来的奇偶数

```java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int ou = 0;
        int ji = 1;
        int[] B = new int[A.length];
        
        for(int i = 0; i < A.length; i++){
            if(A[i]%2 == 0){
                B[ou] = A[i];
                ou = ou + 2;
            }
            else{
                B[ji] = A[i];
                ji = ji + 2;
            }
        }
        return B;
    }
}
```

### 改进

对于`if(A[i]%2 == 0)`优化成`if(A[i] & 1 == 0)`

## 852. 山脉数组的峰顶索引

### 基本思路

遍历找到最大值

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        int max = A[0];
        int index = 0;
        
        for(int i=1;  i<A.length; i++){
            if(A[i] > A[index]){
                max = A[i];
                index = i;
            }
        }
        return index;
    }
}
```

### 改进

二分法

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        return mountainIndex(A,0,A.length - 1);
    }
    
    public static int mountainIndex(int[] A,int l,int r) {
            int mid = l + (r - l) / 2;
            if(A[mid] > A[mid - 1] && A[mid] > A[mid + 1])
                return mid;
            else if(A[mid] < A[mid + 1])
                return mountainIndex(A,mid+1,r);
            else
                return mountainIndex(A,l,mid);
        
    }
}
```

## 961. 重复N次元素

### 基本思路

1. 对A进行排序，遍历A
2. 记录重复次数，满足一半就返回；不满足就重置计数

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Arrays.sort(A);
        int ret = A[0];
        int num = 0;
        
        for(int i=0; i < A.length; i++){
            if(A[i] != ret){
                ret = A[i];
                num = 1;
            }
            else{
                num++;
                if(num == A.length/2){
                    return ret;
                }
            }
        }
        return ret;
    }
}
```

### 改进

最快速度是使用set，长度为A/2+1，当无法存储时即此为结果

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Set<Integer> set = new HashSet<>(A.length / 2 + 1);
        for (int i : A) {
            if (!set.add(i)) {
                return i;
            }
        }
        return 0;
    }
}
```

由于有一半数肯定是相同的，只需要排序后判断最后一个数和中间右是否相同，如果相同则后一半都为答案数，如果不同则中间左边一位肯定是。

```java
public int repeatedNTimes(int[] A) {
    Arrays.sort(A);
    return A[A.length / 2] == A[A.length - 1] ? A[A.length - 1] : A[A.length / 2 - 1];
}
```

* 此方法速度最慢，只是简洁。

## 476. 数字的补救

主要注意取反头有补码表示正负

1. highestOneBit(num)最高为置1,-1以后首位为0其它为1。
2. &保证补码为0不干扰数字

```java
class Solution {
    public int findComplement(int num) {
        return ~num&(Integer.highestOneBit(num)-1);
    }
}
```

## 728. 自然数

使用/=10迭代来实现移位，使用%10来取右边最后一位。

```java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> res = new ArrayList<>();
        for(int i = left; i <= right; i++){
            if(check(i)) res.add(i);
        }
        return res;
    }
    
    private boolean check(int n){
        int d =n;
        while(d != 0){
            int test = d % 10;
            if(test == 0 || (n % test) != 0) {return false;}
            d /= 10;
        }
        return true;
    }
}
```

## 867. 转置矩阵

行列交换即可

```java
class Solution {
    public int[][] transpose(int[][] A) {
        if( A == null) return null;
        
        int[][] result = new int[A[0].length][A.length];
        
        for(int i=0; i < A[0].length; i++){
            for(int j=0; j< A.length; j++){
                result[i][j] = A[j][i];
            }
        }
        return result;
    }
}
```

## 258. 各位相加

### 基本思路

```java
class Solution {
    public int addDigits(int num) {
        int sum = (num/10)+(num%10);//8,1
        
        while(sum > 9){
            sum = addDigits(sum);
        }
        return sum;
    }
}
```

### 非递归循环方法

数字根是模9的值,-1+1是因为9,99,999。。。。

```java
class Solution {
    public int addDigits(int num) {
        if(num < 10) {
            return num;
        }else {
            return ((num - 1) % 9) + 1;
        }
    }
}
```

## 908. 最小差值I

题目转化为MAX-MIN-2x求最小值,其中x为-k<=x<=k.

如果x=k时结果大于0即最小值，小于0即0为最小差值。

```java
class Solution {
    public int smallestRangeI(int[] A, int K) {
        int max=Integer.MIN_VALUE;;
        int min=Integer.MAX_VALUE;;
        
        for(int i : A){
            max = i > max ? i : max;
            min = i < min ? i : min;
        }
        return Math.max(max-min - Math.abs(2*K), 0);
    }
}
```

## 561. 数组拆分I

### 基本思想

转换为数组从小到大，每间隔一个选取。

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        
        int res = 0;
        for(int i=0; i<nums.length; i=i+2){
            res += nums[i];
        }
        return res;
    }
}
```

### 改进

可以不使用默认排序改为使用桶排序

## 693. 交替位二进制数

一位位计算与下一位比较即可

```java
class Solution {
    public boolean hasAlternatingBits(int n) {

        int cur = n%2;
            n = n/2;
        while(n > 0){
            if( cur == n%2 ){
                return false;
            }
            cur = n%2;
            n = n/2;
        }
        return true;

    }
}
```

## 118. 杨辉三角

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        int[][] array = new int [numRows][numRows];
        
        for(int i=0; i<numRows; i++){
            List<Integer> list = new ArrayList<Integer>();
            for(int j=0; j<=i; j++){//一行
                if(j == 0 || j == i) {array[i][j] = 1;}
                else{
                    array[i][j] = array[i-1][j-1] + array[i-1][j];
                }
                list.add(array[i][j]);
            }
            res.add(list);
        }
        return res;
    }
}
```

## 349. 两个数组的交集

### 基本思路

set实现单个数组无重复数，set.contains()选取重复数，iterator().hasNext()迭代器遍历set读取结果。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        for (int i=0; nums1 != null && i<nums1.length; i++){
            set1.add(nums1[i]);
        }
        for (int i=0; nums2 != null && i<nums2.length; i++){
            if(set1.contains(nums2[i])){
                set2.add(nums2[i]);
            }            
        }
        
        if (set2.isEmpty()) {
            return new int[0];
        }

        int[] res = new int[set2.size()];
        Iterator<Integer> iterator = set2.iterator();
        int idx = 0;
        while (iterator.hasNext()) {
            res[idx++] = iterator.next();
        }

        return res;
        
    }
}
```

### 改进

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        
        for (int num1:nums1) { //找到nums1中最大最小值
            max = Math.max(num1, max);
            min = Math.min(num1, min);
        }
        
        boolean[] marks = new boolean[max-min+1];
        for (int num1:nums1) { //记录num1在marks中有的数
            marks[num1-min] = true;
        }
        
        int index = 0;
        for (int num2:nums2) {
            
            if (num2 < min || num2 > max) {//跳过num2中比num1中最大值大最小值小的数
                continue;
            }
            
            if (marks[num2-min]) {//用num1之前赋值好了增加的组进行判断，num2负责读取
                nums2[index++] = num2; // 合理使用 nums2 数组，将符合条件的数放到 nums2 的前面索引位置
                marks[num2-min] = false; // 设置 false，重复的数字就会被过滤掉
            }
        }
        
        return Arrays.copyOf(nums2, index); // 取 num2 数组从 0 开始 index 长度的子数组
    }
}
```

## 463. 岛屿的周长

设定几个规则:
1. 读到1的数就记4
2. 读到与右或下都是1就减2
3. 为了避免最后和最下的数组的越界需要停止扫描
4. 为了避免1行或1列的越界需要设置扫描行列的最小行列数

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int res = 0;
        int sum = 0;
        
        for(int j=0; j<grid[0].length; j++){
            for(int i=0; i<grid.length; i++){
                if((i<grid.length-1) && (grid.length>1)){//扫描上下，最后一行停止
                    if (grid[i][j] == 1 && grid[i][j] == grid[i+1][j]){
                    sum+=2;
                    }
                } 
                if((j<grid[0].length-1) && (grid[0].length>1)){//扫描左右，最后一列停止
                    if (grid[i][j] == 1 && grid[i][j] == grid[i][j+1]){
                    sum+=2;
                    }
                }
                
                if (grid[i][j] == 1){
                    res+=4;
                }
            }  
        }
        res = res - sum;
        return res;
    }
}
```

### 优化

1. 首先无论是扫描上下还是左右都需要判断是否为1，可以放在最外层
2. 为了避免越界和只有1行1列的情况，应该使用右判断左，下判断上，同时第一行第一列不用记，即可同时考虑到两种越界问题。

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int count = 0;//record the value of the answer
        for(int i = 0;i < grid.length;i++){
            for(int j = 0;j < grid[0].length;j++){
                if(grid[i][j] == 1){
                    count += 4;
                    if(i - 1 >= 0 && grid[i - 1][j] == 1){
                        count -= 2;
                    }
                    if(j - 1 >= 0 && grid[i][j - 1] == 1){
                        count -= 2;
                    }
                }

            }
        }
        return count;
    }
}
```

## 509. 斐波那契数列

```java
class Solution {
    public int fib(int N) {
        int res = 0;
        int temp0 = 0;
        int temp1 = 1;
        
        if(N==0)return 0;
        else if(N==1)return 1;
        else{
            for(int i=1; i<N; i++){
                res = temp0 + temp1;
                temp0 = temp1;
                temp1 = res;
            }
            return res;
        }
        
    }
}
```

## 566. 重塑矩阵

### 基本思路

把二维变成一维再重新转成二维

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int han = nums.length;
        int lie = nums[0].length;
        int[][] res = new int[r][c];
        int[] num = new int[han*lie];
        
        if(r*c != han*lie) return nums;
        else{
            int nn = 0;
            for(int ii=0; ii<han; ii++){//二维数组转换成一维
                for(int jj=0; jj<lie; jj++){
                    num[nn] = nums[ii][jj];
                    nn++;
                }
            }
            int n = 0;
            for(int i=0; i<r; i++){//转化成二维
                for(int j=0; j<c; j++){
                    res[i][j] = num[n];
                    n++;
                }
            }
        }
        return res;       
    }
}
```

### 改进

行列的转换公式为:[n/col][n%col]

* n为第n个数

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        
           int row = nums.length;
           int col = nums[0].length;
           int[][] res = new int[r][c];
           int n = 0;
        
            if (nums.length == 0 || r * c != row * col){
                return nums;
            }
        
            for (int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    res[n / c][n % c] = nums[i][j];
                    n++;
                }
            }
            return res;
    }
}
```

## 575. 分糖果

### 基本思路

```java
class Solution {
    public int distributeCandies(int[] candies) {
        Set<Integer> set = new HashSet<>();
        for(int candie:candies){
            set.add(candie);
        }
        int cateage = set.size();
        int nums = candies.length;

        if(cateage <= nums/2){
            return cateage;
        }
        else{
            return nums/2;
        }
        //return set.size() >= candies.length / 2 ? candies.length / 2 : set.size();
    }
}
```

### 空间换时间

```java
class Solution {
    public int distributeCandies(int[] candies) {
        //简而言之，把一个数组分两半，让一半的元素尽可能多
        //元素种类数>=数组的1/2，则可保证一半数组每个元素都不一样
        //如果<1/2,取元素的种类数即可
        //重点在于求元素种类数 
        
        //空间换时间
        boolean[] bools = new boolean[200001];
        int count = 0;
        for(int i:candies){
            if(bools[i + 100000] == false){
                bools[i + 100000] = true;
                count++;
            }
        }
        return count > candies.length/2 ? candies.length/2 : count; 
        
    }
}
```

## 496. 下一个更大元素I

### 基本思路

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        int index = 0;
        for(int i=0; i<nums1.length; i++){
            for(int j=0; j<nums2.length; j++){//遍历2,找到与1相同的数就记录index
                if(nums1[i] == nums2[j]){
                    index = j;
                    break;
                }
            }
            for(int k=index; k<nums2.length; k++){//判断2中右边第一个比1大的数
                if(nums2[k] > nums1[i]) {
                    res[i]=nums2[k];
                    break;
                }
                else{res[i]=-1;}
            }
        }
        return res;
    }
}
```

### 优化

在遍历2中找1的方法可以使用空间换时间的方法：
1. 找到2的最大值
2. 建立一个长度为最大值+1的数组bitmap，把2的值当作index放入到数组中，并为数组填充等值的数
3. 比较2中比1大的数的起始点以bitmap[nums1[i]]+1作为起点即可

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int l1 = nums1.length, l2 = nums2.length;
        int[] result = new int[l1];

        int max = 0;
        for (int i = 0; i < l2; i++)//步骤1
            if (nums2[i] > max)
                max = nums2[i];

        int[] bitmap = new int[max + 1];
        for (int i = 0; i < l2; i++)//步骤2
            bitmap[nums2[i]] = i;
        

        for (int i = 0; i < l1; i++) {//判断2中右边第一个比1大的数
            int n1 = nums1[i], m = -1;
            int idx = bitmap[n1];
            for (int j = idx + 1; j < l2; j++)
                if (nums2[j] > n1) {
                    m = nums2[j];
                    break;
                }
            result[i] = m;
        }

        return result;
    }
}
```