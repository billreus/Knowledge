<!-- TOC -->

- [常用命令](#常用命令)
- [905. 按奇偶排序数组](#905-按奇偶排序数组)
    - [基本思路](#基本思路)
    - [改进](#改进)
- [832. 翻转图像](#832-翻转图像)
    - [基本思路](#基本思路-1)
    - [改进](#改进-1)
- [461. 汉明距离](#461-汉明距离)
    - [基本思路](#基本思路-2)
    - [改进](#改进-2)
- [942. 增减字符串匹配](#942-增减字符串匹配)
    - [思路](#思路)
- [922.按奇偶排序数组II](#922按奇偶排序数组ii)
    - [思路](#思路-1)
    - [改进](#改进-3)
- [852. 山脉数组的峰顶索引](#852-山脉数组的峰顶索引)
    - [基本思路](#基本思路-3)
    - [改进](#改进-4)
- [961. 重复N次元素](#961-重复n次元素)
    - [基本思路](#基本思路-4)
    - [改进](#改进-5)
- [476. 数字的补救](#476-数字的补救)
- [728. 自然数](#728-自然数)
- [867. 转置矩阵](#867-转置矩阵)
- [258. 各位相加](#258-各位相加)
    - [基本思路](#基本思路-5)
    - [非递归循环方法](#非递归循环方法)
- [908. 最小差值I](#908-最小差值i)
- [561. 数组拆分I](#561-数组拆分i)
    - [基本思想](#基本思想)
    - [改进](#改进-6)

<!-- /TOC -->

## 常用命令

转换二进制字符: `String x = Integer.toBinaryString(x);`

长度判断:`String.lengeth(); char.length;`

* length用于计算字符串数组，length()用于字符长度

二进制数最左边的最高位，且高位后面全部补零：`Integer.highestOneBit(num) `

&位与运算，0可以清零，1可以保护

## 905. 按奇偶排序数组

### 基本思路

遍历数组，偶数正向赋值给新数组，奇数反向赋值给新数组。

```java
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int[] doub = new int[A.length];
        int d = 0;
        int l = A.length - 1;
                    
        for(int i=0 ; i<A.length; i++){

            if(A[i] % 2 == 0){
                doub[d] = A[i];
                d++;
            }
            else{
                doub[l] = A[i];
                l--;
            }
            
        }
        return doub;
    }
}
```

### 改进

基本的方法开辟了额外空间，不开辟新空间可以遍历数组，找到第一个奇数后就从当前位置搜索下一个偶数，并交换。不过效率不一定高。

```python
class Solution:
    def sortArrayByParityII(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        A_len, i, j = len(A), 0, 1
        while i < A_len:
            if A[i] % 2 == 1:
                while A[j] % 2 == 1:
                    j += 2
                
                A[i], A[j] = A[j], A[i]

            i += 2

        return A
```

## 832. 翻转图像

### 基本思路

1. 获取数列行列
2. 固定行进行反转和取反
3. 遍历列

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int lineLen = A.length;
        int columnLen = A[0].length;        
        int picture [][] = new int[lineLen][columnLen];
        
        
        for (int i=0; i < lineLen; i++){
            int copy = columnLen - 1;
            for(int j=0; j < columnLen; j++){
                picture[i][j] = A[i][copy];
                copy--;
                notA(picture, i, j);
            }
        }
        return picture;
    }

    public void notA(int[][] A,int x,int y){
            if(A[x][y] ==0){
                A[x][y] =1;
            }else{A[x][y] =0;}
    }    
}
```

### 改进

每行的取反和头尾交换其实不需要遍历整个数组，只需要一个临时数去存储头，然后把头尾交换取反即可，交换到中间就整行交换结束。

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        for(int i =0;i<A.length;i++){
            int temp;
            int front = 0;
            int end = A[i].length-1;
            while(front <=end ){ //一行的交换取反
                temp = A[i][front]; //头存在临时里面
                A[i][front] = 1-A[i][end]; //头等于尾且取反
                A[i][end] = 1-temp; //临时取反
                front ++;
                end --;
            }
        }
        return A;
    }
}
```

## 461. 汉明距离

### 基本思路

1. x与y转换成2进制，并且补位成等长
2. 遍历比较每一位，累计不同

```java
class Solution {
    public int hammingDistance(int x, int y) {
        String xTwo = Integer.toBinaryString(x);
        String yTwo = Integer.toBinaryString(y);
        int xlength = xTwo.length();
        int ylength = yTwo.length();
        
        if(xlength < ylength){                        
            for(int i=0;i < ylength - xlength;i++)
                xTwo = "0"+xTwo;                  
        }
        else{
            for(int i=0;i < xlength - ylength;i++)
                yTwo = "0"+yTwo;     
        }
        
        char[] xc = xTwo.toCharArray();
        char[] yc = yTwo.toCharArray();
        //System.out.printf("%s, %s", xTwo, yTwo);
        int count = 0;
        for(int i=0; i<xc.length; i++){
            if(xc[i] != yc[i]){
                count++;
            }
        }
        return count;
    }
}
```

### 改进

1. 主要核心是异或(^),相同为0，不同为1；
2. 统计异或以后为1的位；

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int i = x ^ y;
        int c = 0;
        while(i > 0){
            // 最后一位是否为1
            if((i & 1) == 1){//位与运算，都为1为1
                c ++;
            }
            i = i >> 1;
        }
        return c;
    }
}
```

## 942. 增减字符串匹配

### 思路

读到I从小到达排列，读到D从大到小排列

```java
class Solution {
    public int[] diStringMatch(String S) {
        int N = S.length();
        char[] ss = S.toCharArray();
        int min = 0;
        int max = S.length();
        int[] result = new int[N+1];
        
        for(int i=0; i < N ; i++){
            if(ss[i] == 'I'){
                result[i] = min;
                min++;
            }
            if(ss[i] == 'D'){
                result[i] = max;
                max--;
            }
        }
        result[N] = max;
        return result;
    }
}
```

## 922.按奇偶排序数组II

### 思路

创建一个新数组存储，从A判断来的奇偶数

```java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int ou = 0;
        int ji = 1;
        int[] B = new int[A.length];
        
        for(int i = 0; i < A.length; i++){
            if(A[i]%2 == 0){
                B[ou] = A[i];
                ou = ou + 2;
            }
            else{
                B[ji] = A[i];
                ji = ji + 2;
            }
        }
        return B;
    }
}
```

### 改进

对于`if(A[i]%2 == 0)`优化成`if(A[i] & 1 == 0)`

## 852. 山脉数组的峰顶索引

### 基本思路

遍历找到最大值

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        int max = A[0];
        int index = 0;
        
        for(int i=1;  i<A.length; i++){
            if(A[i] > A[index]){
                max = A[i];
                index = i;
            }
        }
        return index;
    }
}
```

### 改进

二分法

```java
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        return mountainIndex(A,0,A.length - 1);
    }
    
    public static int mountainIndex(int[] A,int l,int r) {
            int mid = l + (r - l) / 2;
            if(A[mid] > A[mid - 1] && A[mid] > A[mid + 1])
                return mid;
            else if(A[mid] < A[mid + 1])
                return mountainIndex(A,mid+1,r);
            else
                return mountainIndex(A,l,mid);
        
    }
}
```

## 961. 重复N次元素

### 基本思路

1. 对A进行排序，遍历A
2. 记录重复次数，满足一半就返回；不满足就重置计数

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Arrays.sort(A);
        int ret = A[0];
        int num = 0;
        
        for(int i=0; i < A.length; i++){
            if(A[i] != ret){
                ret = A[i];
                num = 1;
            }
            else{
                num++;
                if(num == A.length/2){
                    return ret;
                }
            }
        }
        return ret;
    }
}
```

### 改进

最快速度是使用set，长度为A/2+1，当无法存储时即此为结果

```java
class Solution {
    public int repeatedNTimes(int[] A) {
        Set<Integer> set = new HashSet<>(A.length / 2 + 1);
        for (int i : A) {
            if (!set.add(i)) {
                return i;
            }
        }
        return 0;
    }
}
```

由于有一半数肯定是相同的，只需要排序后判断最后一个数和中间右是否相同，如果相同则后一半都为答案数，如果不同则中间左边一位肯定是。

```java
public int repeatedNTimes(int[] A) {
    Arrays.sort(A);
    return A[A.length / 2] == A[A.length - 1] ? A[A.length - 1] : A[A.length / 2 - 1];
}
```

* 此方法速度最慢，只是简洁。

## 476. 数字的补救

主要注意取反头有补码表示正负

1. highestOneBit(num)最高为置1,-1以后首位为0其它为1。
2. &保证补码为0不干扰数字

```java
class Solution {
    public int findComplement(int num) {
        return ~num&(Integer.highestOneBit(num)-1);
    }
}
```

## 728. 自然数

使用/=10迭代来实现移位，使用%10来取右边最后一位。

```java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> res = new ArrayList<>();
        for(int i = left; i <= right; i++){
            if(check(i)) res.add(i);
        }
        return res;
    }
    
    private boolean check(int n){
        int d =n;
        while(d != 0){
            int test = d % 10;
            if(test == 0 || (n % test) != 0) {return false;}
            d /= 10;
        }
        return true;
    }
}
```

## 867. 转置矩阵

行列交换即可

```java
class Solution {
    public int[][] transpose(int[][] A) {
        if( A == null) return null;
        
        int[][] result = new int[A[0].length][A.length];
        
        for(int i=0; i < A[0].length; i++){
            for(int j=0; j< A.length; j++){
                result[i][j] = A[j][i];
            }
        }
        return result;
    }
}
```

## 258. 各位相加

### 基本思路

```java
class Solution {
    public int addDigits(int num) {
        int sum = (num/10)+(num%10);//8,1
        
        while(sum > 9){
            sum = addDigits(sum);
        }
        return sum;
    }
}
```

### 非递归循环方法

数字根是模9的值,-1+1是因为9,99,999。。。。

```java
class Solution {
    public int addDigits(int num) {
        if(num < 10) {
            return num;
        }else {
            return ((num - 1) % 9) + 1;
        }
    }
}
```

## 908. 最小差值I

题目转化为MAX-MIN-2x求最小值,其中x为-k<=x<=k.

如果x=k时结果大于0即最小值，小于0即0为最小差值。

```java
class Solution {
    public int smallestRangeI(int[] A, int K) {
        int max=Integer.MIN_VALUE;;
        int min=Integer.MAX_VALUE;;
        
        for(int i : A){
            max = i > max ? i : max;
            min = i < min ? i : min;
        }
        return Math.max(max-min - Math.abs(2*K), 0);
    }
}
```

## 561. 数组拆分I

### 基本思想

转换为数组从小到大，每间隔一个选取。

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        
        int res = 0;
        for(int i=0; i<nums.length; i=i+2){
            res += nums[i];
        }
        return res;
    }
}
```

### 改进

可以不使用默认排序改为使用桶排序