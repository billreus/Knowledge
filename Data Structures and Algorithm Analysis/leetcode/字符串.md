<!-- TOC -->

- [常用命令](#常用命令)
- [771. 宝石与石头](#771-宝石与石头)
    - [最初想法](#最初想法)
    - [改进](#改进)
- [929. 独特的电子邮件](#929-独特的电子邮件)
    - [基本思路](#基本思路)
    - [改进](#改进-1)
- [709. 转换成小写字母](#709-转换成小写字母)
- [804. 唯一摩尔斯密码词](#804-唯一摩尔斯密码词)
    - [最初想法](#最初想法-1)
    - [改进](#改进-2)
- [657. 机器人是否返回原点](#657-机器人是否返回原点)
- [344. 反转字符串](#344-反转字符串)
    - [基本思路](#基本思路-1)
    - [改进](#改进-3)
- [944. 删列造序](#944-删列造序)
- [500. 键盘行](#500-键盘行)
    - [基本思路](#基本思路-2)
    - [改进](#改进-4)
- [171. Excel表列序号](#171-excel表列序号)
- [557. 反转字符串中的单词III](#557-反转字符串中的单词iii)
- [821. 字符的最短距离](#821-字符的最短距离)
    - [基本思路](#基本思路-3)
    - [改进](#改进-5)
- [811. 子域名访问计数](#811-子域名访问计数)
    - [基本思路](#基本思路-4)
    - [优化](#优化)
- [806. 写字符串需要的行数](#806-写字符串需要的行数)
- [682. 棒球比赛](#682-棒球比赛)
    - [基本思路](#基本思路-5)
    - [优化](#优化-1)
- [412. Fizz Buzz](#412-fizz-buzz)
- [893. 特殊等价字符串组](#893-特殊等价字符串组)
- [389.找不同](#389找不同)
    - [思路一（较快）](#思路一较快)
    - [思路二（慢）](#思路二慢)
    - [思路三(最快)](#思路三最快)
- [824. 山羊拉丁文](#824-山羊拉丁文)
- [937. 重新排列日志文件](#937-重新排列日志文件)
    - [基本方法](#基本方法)
    - [简化](#简化)
- [884. 两句话中的不常见单词](#884-两句话中的不常见单词)
- [520. 检测大写字母](#520-检测大写字母)

<!-- /TOC -->

## 常用命令

String转换成char

```java
String s = "abcd";
char[] ss = s.toCharArray();
```

转换成String/Integer:`String/Integer.valueOf(ss);`

String看作字符串，char看作字符

String[]比较字符时使用`xxx.equals("zifu")`进行比较

返回指定索引处的字符：`char word = words.chartAt(int index);`

返回指定字符所在索引：`stringword.indexOf(word)`

切割字符串(前开后闭)：`word.substring(0,3);`

替换字符:`word.replace(".", ",")`

* list,set添加使用add，stringbuilder和char添加使用append
* string作为字符串是不可改变的，需要添加型字符串可以使用Stringbuilder和StringBuffer

stack的查长度使用size()

## 771. 宝石与石头

### 最初想法

遍历两个string，嵌套for循环比较

```java
class Solution {

    public int numJewelsInStones(String J, String S) {
        
        int count = 0;
        
        for(int i = 0; i < J.length(); i++){
        
            char J_char = J.charAt(i);
            
            for(int k = 0; k < S.length(); k++){
                
                char S_char = S.charAt(k);
                
                if(J_char == S_char) count++;
            }
        }

        return count;
    }
}
```

用时19ms

### 改进

以下两种方法，也只优化到了18ms，省略了嵌套的for循环

第一种思想

* 用一个统计数组存储24个字母，先对石头遍历一遍遍历到的加一，再对宝石遍历，宝石提到的字符，直接提取统计的数据累加。

```java
class Solution{
    public int numJewelsInStones(String J, String S){
        char[] j = J.toCharArray();
        char[] s = S.toCharArray();
        int count = new int['z' - 'A' + 1];
        
        for (char ch:s){
            count[ch -'A']++;
        }
        
        int sum = 0;
        
        for (char ch:j){
            sum += count[ch - 'A'];
        }
        return sum;
    }
}
```

第二种思想

* 使用index直接在石头中定位到宝石的位置进行累加。

```java
class Solution{
    public int numJewelsInStones(String J, String S){
        char[] s = s.toCharArray();
        int sum = 0;
        
        for (char ch:s){
            if(J.indexOf(ch) >= 0) sum++;
        }
        return sum;
}
```

## 929. 独特的电子邮件

* leetcode答案中9,10ms为错误答案

### 基本思路

主要需要解决的问题：

1. 对于@前后字符的分割
2. 对于+和,的处理
3. 对于本地名称的去重

解决方法：

1. 使用indexOf()方法进行定位，substring()方法进行切割
2. 使用substring()处理"+"，用replace()处理"，"
3. 使用HastSet去重

```java
    public int numUniqueEmails(String[] emails) {
        Set<String> set=new HashSet<>();
        for(String email:emails){
            //本地名称(前闭后开)
            String name=email.substring(0,email.indexOf("@"));
            //域名
            String domain=email.substring(email.indexOf("@"));
            //根据指定规则解析后的本地名称，先按加号切割字符串，然后替换'.'
            String newName=name.substring(0,name.indexOf("+")).replaceAll(".","");
            //使用HashSet去重
            set.add(newName+domain);
        }
        return set.size();
    }
```

### 改进

```java
class Solution {

    public int numUniqueEmails(String[] emails) {
        ArrayList<String> ans = new ArrayList<>();
        
        for (String email : emails) {
            String web[] = email.split("@");
            web[0] = web[0].replace(".", "");

            for (int i = 0; i < web[0].length(); i++) {
                if (web[0].charAt(i) == '+') {
                    web[0] = web[0].substring(0, i);
                }
            }
            email = web[0] + "@" + web[1];
            if(!ans.contains(email))
                ans.add(email);
        }
        return ans.size();
    }
}
```

## 709. 转换成小写字母

String中toLowerCase()可以使字符变成小写字母，toUpperCase()变成大写字母；

```java
class Solution {
    public String toLowerCase(String str) {
        return str.toLowerCase();
    }
}
```

## 804. 唯一摩尔斯密码词

### 最初想法

1. 创建一个String存储摩斯密码，一个char存储24个字母，一个stringbuilder存储测试的摩斯密码，一个HashSet去重统计最后输出
2. 双重for把words提取出单个字母，再for对比24个字母，相同即添加对应位置的摩斯密码，最后转化成string添加到hashset计算size
```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] j = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        char[] w ={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
        HashSet<String> set = new HashSet<String>();
        
        for(String word : words){
            //StringBuffer ms = new StringBuffer();
            //单线程使用builder即可，速度快3ms
            StringBuilder ms = new StringBuilder();
            char[] wor = word.toCharArray();
            for(char ww : wor){
                for(int i=0; i<w.length; i++){
                    if(ww == w[i]){
                        ms.append(j[i]);
                    }
                }
            }
            set.add(ms.toString());
        }
        return set.size();
    }
}
```

### 改进

无需存储完整的24字母，使用ascii码，获取word字母减去97即可得到对应在摩斯数组中的位置
```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        int baseIndex = 97;
        Set<String> set = new HashSet<>();
        for (String word : words) {
        	int lenght = word.length();
        	StringBuilder sb = new StringBuilder();
			for (int i = 0; i < lenght; i++) {
				sb.append(morse[word.charAt(i) - baseIndex]);
			}
			set.add(sb.toString());
		}
        return set.size();
    }
    
    String[] morse = {
        ".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."
    };
}
```

## 657. 机器人是否返回原点

```java
class Solution {
    public boolean judgeCircle(String moves) {
        char[] mmoves = moves.toCharArray();
        int heng =0;
        int shu = 0;
        
        for(char move:mmoves){
            if(move == 'R'){heng++;}
            if(move == 'L'){heng--;}
            if(move == 'U'){shu++;}
            if(move == 'D'){shu--;}
        }
        if(heng == 0 && shu == 0){return true;}
        else{return false;}
    }
}
```

## 344. 反转字符串

### 基本思路

转换成char型反向存储

```java
class Solution {
    public String reverseString(String s) {
        char[] res = new char[s.length()];
        char[] ss = s.toCharArray();
        int i =s.length()-1;
        for(char cs : ss){
            res[i] = cs;
            i--;
        }
        return String.valueOf(res);
    }
}
```

### 改进

在原字符串上进行头尾互换即可

```java
class Solution {
    public String reverseString(String s) {
            char[] c = s.toCharArray();
            for(int i=0;i<s.length()/2;i++){
                char temp = c[i];
                c[i] = c[s.length()-1-i];
                c[s.length()-1-i] = temp;
            }
            return String.valueOf(c);
        }
}
```

## 944. 删列造序

```java
class Solution {
    public int minDeletionSize(String[] A) {
        if(A == null || A.length == 0) return 0;
        int count = 0;
        for(int i=0; i<A[0].length(); i++){
            for(int j=0; j<A.length-1; j++){
                if(A[j].charAt(i) > A[j+1].charAt(i)){
                    count++;
                    break;
                }
            }
            
        }
        return count;
    }
}
```

## 500. 键盘行

### 基本思路

1. 创建三个字符串用于存储三行字符
2. 遍历输入的字符
3. 以头字符作为依据，遍历每个字符的字母判断是否包含在该行，不再直接跳出
4. 最后把结果list转换成string

```java
class Solution {
    public String[] findWords(String[] words) {
        String s1 = "qwertyuiop";
        String s2 = "asdfghjkl";
        String s3 = "zxcvbnm";
        String tmp = s1;       
         List<String> list = new ArrayList<String>();
        for(String s : words){
            String ss = s.toLowerCase();
            char c = ss.charAt(0);
            if(s1.contains(c+"")){
                tmp = s1;
            }
            else if(s2.contains(c+"")){
                tmp = s2;
            }
            else if(s3.contains(c+"")){
                tmp = s3;
            }
            list.add(s);
            for(char cs : ss.toCharArray()){
                if(!tmp.contains(cs+"")){
                    list.remove(s);
                    break;
                }
            }
        } 
        String[] result = new String[list.size()];
        return list.toArray(result);
    }
}
```

### 改进

不用头字符作为依据，而是在遍历字符时以目标不在三行中的false作为判断，满足三行true条件才加入到list中

```java
class Solution {
    public String[] findWords(String[] words) {
        String s1 = "qwertyuiop";
        String s2 = "asdfghjkl";
        String s3 = "zxcvbnm";
        List<String> list = new LinkedList<>();
        for(int i = 0; i < words.length; i ++) {
            String s4 = words[i].toLowerCase();
            Boolean flag1 = true, flag2 = true, flag3 = true;    
            for(int j = 0; j < words[i].length(); j ++) {
                if(s1.indexOf(s4.charAt(j)) == -1) {
                    flag1 = false;
                }
                if(s2.indexOf(s4.charAt(j)) == -1) {
                    flag2 = false;
                }
                if(s3.indexOf(s4.charAt(j)) == -1) {
                    flag3 = false;
                }
            }
            if(flag1 == true || flag2 == true || flag3 == true) {
                list.add(words[i]);
            }
        }
        String[] res = new String[list.size()];
        for(int i = 0; i < list.size(); i ++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

## 171. Excel表列序号

题目其实就是转换26进制，26^n*m+26^(n-1)*j+...+26*x, n为字母位数，m,j等为每一位字母与A字母-1的差值。

```java
class Solution {
    public int titleToNumber(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length-1;
        int square;
        int total = 0;
        
        for(int i=0; i<ss.length; i++){
            square = (int)Math.pow(26, n);
            n--;
            total += ((int)ss[i]-64)*square;
        }
        return total;    
    }
}
```

## 557. 反转字符串中的单词III

```java
class Solution {
    public String reverseWords(String s) {
        char[] ss = s.toCharArray();
        int N = ss.length;
        int start = -1;
        char[] result = new char[N];
        for(int i=0; i<ss.length; i++){
            if(ss[i] == ' '){
                int end = i;                 
                while(start < i-1){
                    end--;
                    start++;
                    result[start] = ss[end];                    
                }
                start++;
                result[start] = ' ';
            }
            if(i==N-1){//最后一个单词的反转
                int end = i+1;
                while(start < i){
                    end--;
                    start++;
                    result[start] = ss[end];                    
                }
            }
            
        }
        return String.valueOf(result);
    }
}
```

代码优化后：

```java
class Solution {
    public String reverseWords(String s) {
        char[] cl = s.toCharArray();
        int start = 0;
        int nextSpace = s.indexOf(' ',start);
        while(nextSpace != -1) {
            reverse(cl,start,nextSpace - 1);
            start = nextSpace + 1;
            nextSpace = s.indexOf(' ',start);
        }
        reverse(cl,start,cl.length - 1);
        return new String(cl);
    }
    
    public void reverse(char[] cl,int start,int end){
        while(start < end){
            char temp = cl[start];
            cl[start] = cl[end];
            cl[end] = temp;
            start ++;
            end --;
        }
    }
}
```

## 821. 字符的最短距离

### 基本思路

记录c字符位置，每个字符位置和每个值的距离取最小

```java
class Solution {
    public int[] shortestToChar(String S, char C) {
        char[] s = S.toCharArray();
        int[] res = new int[s.length];
        List<Integer> list = new ArrayList<>();        
        
        for(int i=0; i<s.length; i++){//记录c字符的位置数组
            if(s[i] == C){
                list.add(i);
            }
        }
        
        for(int j=0; j<s.length; j++){
            int distance = s.length;
            for(int l:list){//距离等于每个c字符位置到该点中的最小值
                distance = Math.min(distance, Math.abs(j-l));
            }
            res[j] = distance;
        }
        return res;
    }
}
```

### 改进

1. 先处理最左和最右的两个字符，只需要递增即可
2. 中间区间从两头同时递增

```java
class Solution {
    public int[] shortestToChar(String S, char C) {
        ArrayList<Integer> list = new ArrayList<>();
            char[] chars = S.toCharArray();
            int[] res = new int[chars.length];
            // 记录 目标 位置的下标,得到一个有序数组
            for (int i = 0; i < chars.length; i++) {
                if(chars[i] == C){
                    list.add(i);
                }
            }
            // 最小坐标的左边
            int step = 0;
            for (int j = list.get(0); j >= 0; j--) {
                res[j] = step ++;
            }
            // 最大坐标的右边
            step = 0;
            for (int j = list.get(list.size()-1); j < chars.length; j++) {
                res[j] = step ++;
            }
            // 从区间两头向中间递增
            for (int i = 0; i < list.size() - 1; i++) {
                step = 1;
                int minIndex = list.get(i) + 1;
                int maxIndex = list.get(i + 1) - 1;
                while(minIndex <= maxIndex){
                    res[minIndex++] = res[maxIndex--] = step++;
                }
            }
            return res;
    }
}
```

## 811. 子域名访问计数

### 基本思路

```java
class Solution {
    public List<String> subdomainVisits(String[] cpdomains) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        for(String cpdomain:cpdomains){
            int j = cpdomain.indexOf(' ');//记录空格位置
            Integer value = Integer.valueOf(cpdomain.substring(0, j));//截取数字
            String key = cpdomain.substring(j+1);//截取网址
            
            for(int i=0; i<key.length(); i++){
                if(key.charAt(i) == '.'){
                    String key2 = key.substring(i+1);//截取.后面的网址
                    map.put(key2, value + map.getOrDefault(key2, 0));//累加
                }
            }
            map.put(key, value + map.getOrDefault(key, 0));            
        }
        
        List<String> list = new ArrayList<>();
        for (Map.Entry<String, Integer> m : map.entrySet()) {//map转换为list
            String s = m.getValue() + " " + m.getKey();
            list.add(s);
        }
        return list;

    }
}
```

### 优化

```java
class Solution {
    public List<String> subdomainVisits(String[] cpdomains) {
        Map<String,Integer> map = new HashMap<>();
        for(String domain:cpdomains){
            if(domain.length()==0)
                continue;
            int index = domain.indexOf(' ');
            int time = Integer.valueOf(domain.substring(0,index));
            domain = domain.substring(index+1);
            map.put(domain,map.getOrDefault(domain,0)+time);
            
            while(domain.indexOf('.')!=-1){
                domain = domain.substring(domain.indexOf('.')+1);
                map.put(domain,map.getOrDefault(domain,0)+time);
            }
        }
        
        List<String> res = new ArrayList<>();
        for(Map.Entry<String,Integer> entry:map.entrySet()){
            String s = entry.getValue()+" "+entry.getKey();
            res.add(s);
        }
        return res;
    }
}
```

## 806. 写字符串需要的行数

字母减去97即宽度所对应的index，累加即可

```java
class Solution {
    public int[] numberOfLines(int[] widths, String S) {
        int[] res = new int[2];
        char[] ss = S.toCharArray();
        int sum = 0;
        int line = 1;
        
        for(char s:ss){
            sum = sum+widths[s-97];
            if(sum > 100){
                line++;
                sum = widths[s-97];
            }
        }
        res[0] = line;
        res[1] = sum;
        return res;
    }
}
```

## 682. 棒球比赛

### 基本思路

使用stack对数据进行操作

```java
class Solution {
    public int calPoints(String[] ops) {
        Stack<Integer> stack = new Stack<Integer>();
        int res = 0;
        
        for(int i=0; i<ops.length; i++){
            //String s = ops
            if(ops[i].equals("C")){
                stack.pop();
            }
            else if(ops[i].equals("D")){
                stack.push(stack.peek()*2);
            }
            else if(ops[i].equals("+")){
                int pre = stack.pop();//为了读取prepre，后面再添加回来
                int prepre = stack.peek();
                stack.push(pre);
                stack.push(pre+prepre);
            }
            else stack.push(Integer.valueOf(ops[i]));
        }
        int length = stack.size();
        for(int j=0; j<length; j++){
            res += stack.pop();
        }
        return res;
    }
}
```

### 优化

使用一个stack[offset]来确定位置，代替出栈入栈等操作,每次操作同时进行累加

```java
class Solution {
    public int calPoints(String[] ops) {
        int[] stack = new int[ops.length];
        int offset = 0;
        int total = 0;
        for (int i=0;i<ops.length;i++){
            if (ops[i].equals("+")) {
                stack[offset] = stack[offset-1] + stack[offset-2];
                total += stack[offset];
                offset++;
            } else if (ops[i].equals("D")){
                stack[offset] = stack[offset -1] * 2;
                total += stack[offset];
                offset++;
            } else if (ops[i].equals("C")){
                offset--;
                total -= stack[offset];
            } else {
                stack[offset] = Integer.parseInt(ops[i]);
                total += stack[offset];
                offset ++;
            }
        }
        return total;
    }
}
```

## 412. Fizz Buzz

```java
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> list = new ArrayList<>();
        for(int i=1; i<n+1; i++){
             if(i%3 == 0 && i%5 != 0){
                list.add("Fizz");
            }
            else if(i%5 == 0 && i%3 != 0){
                list.add("Buzz");
            }
            else if(i%5==0 && i%3==0){
                list.add("FizzBuzz");
            }
            else{
                String s="";
                s = String.valueOf(i);
                list.add(s);
            }
        }       
        return list;
    }
}
```

## 893. 特殊等价字符串组

cout数组划分52个int位，0-25为偶数情况下的26个字母，26-51为奇数情况下的26个字母，每个String有一个cout，cout相同即为符合条件者。

```java
class Solution {
    public int numSpecialEquivGroups(String[] A) {
        Set<String> res = new HashSet();
        for(String As : A){
            int[] count = new int[52];
            for (int i = 0; i<As.length(); ++i)
                count[As.charAt(i)-'a'+26*(i%2)]++;
            res.add(Arrays.toString(count));
        }
        return res.size();
    }
}
```

## 389.找不同

### 思路一（较快）

将所给的字符串转换为字符数组，求字符数组的int和，作差，再转回char，返回

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int sums = 0;
        int sumt = 0;
        for(int i=0; i<ss.length; i++){
            sums += (int)ss[i];
        }
        for(int j=0; j<tt.length; j++){
            sumt += (int)tt[j];
        }
        return (char)(sumt-sums);
        
    }
}
```

### 思路二（慢）

使用sort对数据进行排序，然后依次对比

```java
class Solution {
        public char findTheDifference(String s, String t) {
        char tempOne[] = s.toCharArray();
        char tempTwo[] = t.toCharArray();
        
        Arrays.sort(tempOne);
        Arrays.sort(tempTwo);

        for (int i = 0; i < tempOne.length; i ++) {
            if ((tempOne[i] - tempTwo[i]) != 0) {
                return tempTwo[i];
            }
        }

        return tempTwo[tempTwo.length - 1];
    }
}
```

### 思路三(最快)

异或逐个比较最后肯定剩下一个

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char[] s1=s.toCharArray();
        char[] t1=t.toCharArray();
        char result=0;
        for(int i=0;i<s1.length;i++)
        {
            result^=s1[i];
            result^=t1[i];
        }    
        result^=t1[t1.length-1];
        return result;
    }
}
```

## 824. 山羊拉丁文

```java
class Solution {
    public String toGoatLatin(String S) {
        String vowelMap = "aeiouAEIOU";
        StringBuilder sb = new StringBuilder();
        char pre = '0';
        String taile = "maa";
        boolean isBegin = true;
        for(int i = 0;i<S.length();i++){
            if(S.charAt(i) == ' '){
                if(pre != '0')
                    sb.append(pre);
                sb.append(taile);
                sb.append(' ');
                taile += "a";
                pre = '0';
                isBegin = true;
            }
            else if(isBegin){
                isBegin = false;
                if(vowelMap.indexOf(S.charAt(i)) < 0){
                    pre = S.charAt(i);
                }
                else{
                    sb.append(S.charAt(i));
                }
            }
            else{
                sb.append(S.charAt(i));
            }
        }
        
        if(pre != '0')
            sb.append(pre);
        sb.append(taile);
        return sb.toString();
    }
}
```

## 937. 重新排列日志文件

### 基本方法

通过重写比较器

```java
class Solution {

    public String[] reorderLogFiles(String[] logs) {
        ArrayList<String> digits = new ArrayList<>();
        ArrayList<String> letters = new ArrayList<>();
        for (int i = 0; i < logs.length; i++) {//判断是数字还是字母
            String str = logs[i];
            int index = str.indexOf(' ');
            char c = str.charAt(index + 1);
            if (c >= '0' && c <= '9') {
                digits.add(str);
            } else {
                letters.add(str);
            }
        }
        Collections.sort(letters, new Comparator<String>() {//排序
            @Override
            public int compare(String o1, String o2) {
                int index1 = o1.indexOf(' ');
                int index2 = o2.indexOf(' ');
                while (index1 < o1.length() && index2 < o2.length()) {
                    char c1 = o1.charAt(index1++);
                    char c2 = o2.charAt(index2++);
                    if (c1 > c2) {
                        return 1;
                    } else if (c1 < c2) {
                        return -1;
                    }
                }
                if (index1 < o1.length()) {
                    return 1;
                } else if (index2 < o2.length()) {
                    return -1;
                }
                return 0;
            }
        });
        //合并
        String[] rst = new String[logs.length];
        int index = 0;
        for (int i = 0; i < letters.size(); i++) {
            rst[index++] = letters.get(i);
        }
        for (int i = 0; i < digits.size(); i++) {
            rst[index++] = digits.get(i);
        }
        return rst;
    }
}
```

### 简化

```java
class Solution {
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
            int index1 = o1.indexOf(' ');//标识符位置
            String s1 = o1.substring(index1+1);//o1内容
            int index2 = o2.indexOf(' ');
            String s2 = o2.substring(index2+1);//o2内容
            char c1 = s1.charAt(0);//第一个字符
            char c2 = s2.charAt(0);
            //判断是否为字母，如果都是字母进行比较
            if ( Character.isLetter(c1) && Character.isLetter(c2)) {
              return s1.compareTo(s2);
            }else if (Character.isLetter(c1)) {
              return -1;
            }else if (Character.isLetter(c2)) {
              return 1;
            }else {
              return 0;
            }
          }
        });
        return logs;
    }
}
```

## 884. 两句话中的不常见单词

使用map存放每个单词，最后输出为1的单词。

```java
class Solution {
    public String[] uncommonFromSentences(String A, String B) {
        Map<String, Integer> map = new HashMap<>();
        List<String> res = new ArrayList<>();
        for(String a:A.split(" ")){
            map.put(a, map.containsKey(a) ? map.get(a)+1 : 1);
        }
        for(String b:B.split(" ")){
            map.put(b, map.containsKey(b) ? map.get(b)+1 : 1);
        }
        for(String key:map.keySet()){
            if(map.get(key) == 1) res.add(key);
        }
        String[] ress = new String[res.size()];
        return res.toArray(ress);
    }
}
```

## 520. 检测大写字母

```java
class Solution {
    public boolean detectCapitalUse(String word) {
        char[] words = word.toCharArray(); 
        int count = 0;
        for(int i=0; i<words.length; i++){
            if(words[0]<='Z'){//首字母大写
                if(words[i] <='Z') count++;                
            }
            else{
                if(words[i]<='Z') return false;
            }
        }
        if(count != words.length && words[0] <='Z' && count != 1) return false;
        return true;
    }
}
```