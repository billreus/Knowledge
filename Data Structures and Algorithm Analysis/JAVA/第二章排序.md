# 2.1 初级排序算法

## 2.1.1 选择排序

### 原理

首先，找到数组中最小的那个元素。

其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）

再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。

如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断的选择剩余元素中的最小者。

### 复杂度分析

对于长度N的数组，选择排序大概需要$N^2/2$次比较和N次交换

### 特点

1. 运行时间了输入无关

2. 数据移动是最少的

## 2.1.2 插入排序

与选择排序一样，当前索引左边的所有元素都是有序的，但他们位置不确定，为了给更小的元素腾出空间，可能被移动。但是当索引到右端，数组排序结束。

与选择排序不同，插入排序的所需时间取决于输入元素的初始顺序。

### 复杂度分析

对随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要$N^2/4$次比较和$N^2/4$次交换。

## 2.1.3 希尔排序

思想是使数组中任意间隔为h的元素都是有序的。这样的数组也被称为h有序数组。

# 2.2 并归排序

并归即将两个有序的数组并归成一个更大的有序数组。

并归排序即将两个数组分成两半分别排序，再将结果归并起来。优点在于可以保证将任意长度为N的数组排序所需时间和NlogN成正比。

### 2.2.1 自顶向下的归并排序

算法2.4基于原地归并的抽象实现了另一种递归归并。

自顶向下每次sort分两边，分完开始merge。对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

### 2.2.2 自底向上的归并排序

程序之中根据sz=1,2,4,8....先两两合并，再四个一合并，再八个。。。。

对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

# 2.3 快速排序

```java
//快速排序的切分
private static int partition 
{
    int i = lo, j = hi + 1;
    Comparable v = a[lo];
    while(ture)
    {
        while(less(a[++i], v)) if(i == hi) break;
        while(less(v, a[--j])) if(j == lo) break;
        if(i >= j) break;
        exch(a, i, j);
    }    
    exch(a, lo, j);
    return j;
}
```

## 2.3.1 基本算法
```java
//算法2.5 快速排序
public class Quick
{
    public static void sort(Comparable[] a)
    {
        StdRandom.shuffle(a);// 消除对输入的依赖
        sort(a, 0, a.length - 1); 
    }

    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j-1);
        sort(a, j+1, hi);
    }
}

```

本质是：
1. 先把数组打乱 
2. 以第一个数为标准，从左找到比它大的，从右找到比它小的，交换。直到左边索引大于等于右边停止。
3. 把第一个数放到最终位置，切分成左右两边，继续以切分排序。

## 2.3.2 性能特点
速度比并归和希尔排序快，比较次数比较小。

## 2.3.3 算法改进

三向切分的快速排序可以在重复元素较多时有较快速度。

```java
//三向排序
public class Quick3way
{
    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int lt = lo, i = lo+1, gt = hi;
        Comparable v = a[lo];
        while(i <= gt)
        {
            int cmp = a[i].compareTo(v);
            if(cmp < 0) exch(a, lt++, i++);
            else if (cmp > 0) exch(a, i, gt--);
            else i++;            
        }
        sort(a, lo, lt - 1);
        sort(a, gt+1, hi);
    }
}
```
切分分为头lo，尾hi。相等元素左边位置lt，右边位置gt。

# 2.4 优先队列

支持删除最大元素和插入元素的数据类型叫做优先队列。

## 2.4.1 API

delMax()：删除最大元素
insert()：插入元素

## 2.4.2 初级实现

无序的数组实现：

基于下压栈，insert方法和push方法相同。

删除最大元素可以添加一段类似选择排序的内循环代码，将最大元素和边界元素交换然后删除，和我们对栈的pop方法的实现一样。

有序数组的实现：

在insert中添加代码，将所有的较大元素向右移动一格使数组保持有序。

## 2.4.3 堆

数据结构二叉堆能够很好的实现优先队列的基本操作。

### 堆的算法

用长度为N+1的私有数组pq[]来表示一个为N的堆，不使用pq[0]，堆的元素放在pq[1]至pq[N]中。

### 由下至上的堆有序化（上浮）

如果堆的有序状态因为某个结点比它父结点更大，那么我们就交换它和它的父结点来修复堆。

交换后，这个节点比它的两个子结点都打。

```java
private void swim(int k)
{
    while (k > 1 && less(k/2, k)) //k的父节点位于k/2
    {
        exch(k/2, k);
        k = k/2;
    }
}
```

### 由上至下的堆有序化（下沉）

如果某个父结点比它的两个子结点其中之一小，那么我们可以通过将它和他的两个子结点中较大的交换来恢复堆。

```java
private void sink(int k)
{
    while(2*k <= N) //k结点的子结点位于2k和2k+1
    {
        int j = 2*k;
        if (j < N && less(j, j+1)) j++; //选择子结点中较大的了k比较
        if (!less(k, j)) break;
        exch(k, j);
        k = j;
    }
}
```

### 插入元素

将新元素加到尾部，增加堆的大小，并让这个新元素上浮到合适位置

### 删除最大元素

从数组顶端上删去最大元素并将数组最后一个元素放到顶端，减小堆，让元素下沉到合适位置。