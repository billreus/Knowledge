<!-- TOC -->

- [2 排序](#2-排序)
    - [2.1. 冒泡排序](#21-冒泡排序)
        - [2.1.1. 原理](#211-原理)
        - [2.2.2. 实现](#222-实现)
        - [2.2.3. 复杂度](#223-复杂度)
    - [2.2. 选择排序](#22-选择排序)
        - [2.2.1. 原理](#221-原理)
        - [2.2.2. 实现](#222-实现-1)
        - [2.2.3. 复杂度](#223-复杂度-1)
    - [2.3. 插入排序](#23-插入排序)
        - [2.3.1. 原理](#231-原理)
        - [2.3.2. 实现](#232-实现)
        - [2.3.3. 复杂度](#233-复杂度)
    - [2.4. 希尔排序](#24-希尔排序)
        - [2.4.1. 原理](#241-原理)
        - [2.4.2. 实现](#242-实现)
        - [2.4.3. 复杂度](#243-复杂度)
    - [2.5. 并归排序](#25-并归排序)
        - [2.4.1. 自顶向下的归并排序](#241-自顶向下的归并排序)
        - [2.4.2. 自底向上的归并排序](#242-自底向上的归并排序)
    - [2.6. 快速排序](#26-快速排序)
        - [2.5.1 基本算法](#251-基本算法)
        - [2.5.2 性能特点](#252-性能特点)
        - [2.5.3. 算法改进](#253-算法改进)
    - [2.7. 优先队列](#27-优先队列)
        - [2.6.1 API](#261-api)
        - [2.6.2 初级实现](#262-初级实现)
        - [2.6.3 堆](#263-堆)
            - [堆的算法](#堆的算法)
            - [由下至上的堆有序化（上浮）](#由下至上的堆有序化上浮)
            - [由上至下的堆有序化（下沉）](#由上至下的堆有序化下沉)
            - [插入元素](#插入元素)
            - [删除最大元素](#删除最大元素)
        - [2.6.4. 基于堆的优先队列](#264-基于堆的优先队列)
        - [2.6.5. 堆排序](#265-堆排序)

<!-- /TOC -->

# 2 排序

```java
//排序算法类的模版
public class Example
{
    public static void sort(Comparable[] a)
    
    private static boolean less(Comparable v, Comparable w)
    { return v.compareTo(w) < 0 }

    private static void exch(Comparable[] a, int i, int j)
    { Comparable t = a[i]; a[i] = a[j]; a[j] = t; }

    private static void show(Comparable[] a)
    {
        for (int i = 0; i < a.length; i++)
            StdOut.print(a[i] + " ");
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a)
    {
        for (int i = 1; i < a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    public static void main(String[] args)
    {
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```
## 2.1. 冒泡排序

### 2.1.1. 原理

1. 遍历数列，从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾
2.  采用相同的方法再次遍历，第二大的元素会被排列在最大元素之前。
3.  重复此操作，直到整个数列都有序为止

### 2.2.2. 实现

```java
public class BubbleSort{
    public static void sort(Comparable[] a){
        int N = a.length;
        for (i = N-1; i > 0; i--){
            for (int j = 0; j < i; j++){
                if(less(a[j+1], a[j])) exch(a, j+1, j);
            }
        }
    }
}
```

### 2.2.3. 复杂度

其外层循环执行 N - 1次。内层循环最多的时候执行N次，最少的时候执行1次，平均执行 (N+1)/2次。

所以循环体内的比较交换约执行 (N - 1)(N + 1) / 2 = (N^2 - 1)/2，其复杂度为O(N^2)。

## 2.2. 选择排序

### 2.2.1. 原理

1. 找到数组中最小的那个元素。

2. 将它和数组的第一个元素交换位置

3. 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。

如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断的选择剩余元素中的最小者。

### 2.2.2. 实现

```java
// 算法2.1 选择排序
public class Selection
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for (int i = 0; i < N; i++)
        {
            int min = i;
            for (int j = i+1; j < N; j++)
                if (less(a[j], a[min])) min = j; //less 比较大小，前者小返回True
            exch(a, i, min);  //把min的值赋值给i，等价于选取了排序的数放到该位置
        }
    }
}
```

### 2.2.3. 复杂度

对于长度为N的数组，选择排序需要大约N²/2次比较和N次交换。也即最好、最差、平均时间效率均为O（n²）。

虽然选择排序和冒泡排序的时间复杂度一样，但实际上，选择排序进行的交换操作很少，最多会发生 N - 1次交换。而冒泡排序最坏的情况下要发生N^2 /2交换操作。从这个意义上讲，交换排序的性能略优于冒泡排序

## 2.3. 插入排序

### 2.3.1. 原理

1. 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素。
2. 每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

### 2.3.2. 实现

```java
//算法2.2 插入排序
public class Insertion
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for (int i =1; i < N; i++) //从a[1]开始比较
        {   // 如果a[i]比左边小，交换，然后继续和左边比较，比较到比左边大就停止，开始i+1的索引
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
                exch(a, j, j-1);
        }
    }
}
```

### 2.3.3. 复杂度

简单插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);在最坏情况下，时间复杂度依然为O(n^2)。

## 2.4. 希尔排序

### 2.4.1. 原理

1. 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；
2. 对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。
3. 减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。
 
### 2.4.2. 实现

```java
//算法2.3 希尔排序
public class Shell
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        int h = 1;
        while (h < N/3) h = 3*h + 1; //给h的间隔赋值，在吃采用1,4,13,40....h从高到底运算
        while (h >= 1) 
        {
            for (int i = h; i < N; i++) //一个h间隔的排序
            {//从h往右索引，与j-h,j-2h....对比
                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h)
                    exch(a, j, j-h);
            }    
            h = h/3;
        }
    }
}
```

### 2.4.3. 复杂度

希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N^(3/2))。

## 2.5. 并归排序

并归即将两个有序的数组并归成一个更大的有序数组。

并归排序即将两个数组分成两半分别排序，再将结果归并起来。优点在于可以保证将任意长度为N的数组排序所需时间和NlogN成正比。

### 2.4.1. 自顶向下的归并排序

算法2.4基于原地归并的抽象实现了另一种递归归并。

自顶向下每次sort分两边，分完开始merge。对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

### 2.4.2. 自底向上的归并排序

程序之中根据sz=1,2,4,8....先两两合并，再四个一合并，再八个。。。。

对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

## 2.6. 快速排序

```java
//快速排序的切分
private static int partition 
{
    int i = lo, j = hi + 1;
    Comparable v = a[lo];
    while(ture)
    {
        while(less(a[++i], v)) if(i == hi) break;
        while(less(v, a[--j])) if(j == lo) break;
        if(i >= j) break;
        exch(a, i, j);
    }    
    exch(a, lo, j);
    return j;
}
```

### 2.5.1 基本算法
```java
//算法2.5 快速排序
public class Quick
{
    public static void sort(Comparable[] a)
    {
        StdRandom.shuffle(a);// 消除对输入的依赖
        sort(a, 0, a.length - 1); 
    }

    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j-1);
        sort(a, j+1, hi);
    }
}

```

本质是：
1. 先把数组打乱 
2. 以第一个数为标准，从左找到比它大的，从右找到比它小的，交换。直到左边索引大于等于右边停止。
3. 把第一个数放到最终位置，切分成左右两边，继续以切分排序。

### 2.5.2 性能特点
速度比并归和希尔排序快，比较次数比较小。

### 2.5.3. 算法改进

三向切分的快速排序可以在重复元素较多时有较快速度。

```java
//三向排序
public class Quick3way
{
    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int lt = lo, i = lo+1, gt = hi;
        Comparable v = a[lo];
        while(i <= gt)
        {
            int cmp = a[i].compareTo(v);
            if(cmp < 0) exch(a, lt++, i++);
            else if (cmp > 0) exch(a, i, gt--);
            else i++;            
        }
        sort(a, lo, lt - 1);
        sort(a, gt+1, hi);
    }
}
```
切分分为头lo，尾hi。相等元素左边位置lt，右边位置gt。

## 2.7. 优先队列

支持删除最大元素和插入元素的数据类型叫做优先队列。

### 2.6.1 API

delMax()：删除最大元素
insert()：插入元素

### 2.6.2 初级实现

无序的数组实现：

基于下压栈，insert方法和push方法相同。

删除最大元素可以添加一段类似选择排序的内循环代码，将最大元素和边界元素交换然后删除，和我们对栈的pop方法的实现一样。

有序数组的实现：

在insert中添加代码，将所有的较大元素向右移动一格使数组保持有序。

### 2.6.3 堆

数据结构二叉堆能够很好的实现优先队列的基本操作。

#### 堆的算法

用长度为N+1的私有数组pq[]来表示一个为N的堆，不使用pq[0]，堆的元素放在pq[1]至pq[N]中。

#### 由下至上的堆有序化（上浮）

如果堆的有序状态因为某个结点比它父结点更大，那么我们就交换它和它的父结点来修复堆。

交换后，这个节点比它的两个子结点都打。

```java
private void swim(int k)
{
    while (k > 1 && less(k/2, k)) //k的父节点位于k/2
    {
        exch(k/2, k);
        k = k/2;
    }
}
```

#### 由上至下的堆有序化（下沉）

如果某个父结点比它的两个子结点其中之一小，那么我们可以通过将它和他的两个子结点中较大的交换来恢复堆。

```java
private void sink(int k)
{
    while(2*k <= N) //k结点的子结点位于2k和2k+1
    {
        int j = 2*k;
        if (j < N && less(j, j+1)) j++; //选择子结点中较大的了k比较
        if (!less(k, j)) break;
        exch(k, j);
        k = j;
    }
}
```

#### 插入元素

将新元素加到尾部，增加堆的大小，并让这个新元素上浮到合适位置

#### 删除最大元素

从数组顶端上删去最大元素并将数组最后一个元素放到顶端，减小堆，让元素下沉到合适位置。

### 2.6.4. 基于堆的优先队列

```java
public class MaxPQ<Key extends Comparable<Key>>
{
    private Key[] pq;
    private int N = 0;

    public MaxPQ(int maxN)
    { pq = (Key[] new Comparable[maxN+1])}

    public boolean isEmpty()
    { return N == 0; }

    public int size()
    { return N; }

    public void insert(key v)
    {
        pq[++N] = v;
        swim(N); //上浮
    }

    public Key delMax()
    {
        Key max = pq[1];
        exch(1, N--); //根结点最大元素和最后一个元素交换
        pq[N+1] = null;
        sink(1); //下沉
        return max;
    }

    // 下面代码同前面代码中的代码
    private boolean less(int i, int j)
    private void exch(int i, int j)
    private void swim(int k)
    private void sink(int k)
}
```

### 2.6.5. 堆排序

```java
public static void sort(Comparable[] a)
{
    int N = a.length;
    // 最大值放在了堆顶（堆有序）
    for (int k = N/2; k >= 1; k--)
        sink(a, k, N);
    while (N > 1)
    {
        exch(a, 1, N--); //顶与低交换
        sink(a, 1, N); //顶再比较下沉至确定位置（每次下次即为从最后一个个固定最大值）
    }
}
```