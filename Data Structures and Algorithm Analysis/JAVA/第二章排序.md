# 2.1 初级排序算法

## 2.1.1 选择排序

### 原理

首先，找到数组中最小的那个元素。

其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）

再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。

如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断的选择剩余元素中的最小者。

### 复杂度分析

对于长度N的数组，选择排序大概需要$N^2/2$次比较和N次交换

### 特点

1. 运行时间了输入无关

2. 数据移动是最少的

## 2.1.2 插入排序

与选择排序一样，当前索引左边的所有元素都是有序的，但他们位置不确定，为了给更小的元素腾出空间，可能被移动。但是当索引到右端，数组排序结束。

与选择排序不同，插入排序的所需时间取决于输入元素的初始顺序。

### 复杂度分析

对随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要$N^2/4$次比较和$N^2/4$次交换。

## 2.1.3 希尔排序

思想是使数组中任意间隔为h的元素都是有序的。这样的数组也被称为h有序数组。

# 2.2 并归排序

并归即将两个有序的数组并归成一个更大的有序数组。

并归排序即将两个数组分成两半分别排序，再将结果归并起来。优点在于可以保证将任意长度为N的数组排序所需时间和NlogN成正比。

### 2.2.1 自顶向下的归并排序

算法2.4基于原地归并的抽象实现了另一种递归归并。

自顶向下每次sort分两边，分完开始merge。对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

### 2.2.2 自底向上的归并排序

程序之中根据sz=1,2,4,8....先两两合并，再四个一合并，再八个。。。。

对任意长度N的数组，需要1/2NlgN至NlgN次比较。最多需要6NlgN次。

# 2.3 快速排序

```java
//快速排序的切分
private static int partition 
{
    int i = lo, j = hi + 1;
    Comparable v = a[lo];
    while(ture)
    {
        while(less(a[++i], v)) if(i == hi) break;
        while(less(v, a[--j])) if(j == lo) break;
        if(i >= j) break;
        exch(a, i, j);
    }    
    exch(a, lo, j);
    return j;
}
```

## 2.3.1 基本算法
```java
//算法2.5 快速排序
public class Quick
{
    public static void sort(Comparable[] a)
    {
        StdRandom.shuffle(a);// 消除对输入的依赖
        sort(a, 0, a.length - 1); 
    }

    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j-1);
        sort(a, j+1, hi);
    }
}

```

本质是：
1. 先把数组打乱 
2. 以第一个数为标准，从左找到比它大的，从右找到比它小的，交换。直到左边索引大于等于右边停止。
3. 把第一个数放到最终位置，切分成左右两边，继续以切分排序。

## 2.3.2 性能特点
速度比并归和希尔排序快，比较次数比较小。

## 2.3.3 算法改进

三向切分的快速排序可以在重复元素较多时有较快速度。

```java
//三向排序
public class Quick3way
{
    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;
        int lt = lo, i = lo+1, gt = hi;
        Comparable v = a[lo];
        while(i <= gt)
        {
            int cmp = a[i].compareTo(v);
            if(cmp < 0) exch(a, lt++, i++);
            else if (cmp > 0) exch(a, i, gt--);
            else i++;            
        }
        sort(a, lo, lt - 1);
        sort(a, gt+1, hi);
    }
}
```
切分分为头lo，尾hi。相等元素左边位置lt，右边位置gt。