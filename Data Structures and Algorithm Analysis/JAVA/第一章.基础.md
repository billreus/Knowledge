<!-- TOC -->

- [1.背包、队列、栈](#1背包队列栈)
    - [1.1. API](#11-api)
        - [1.1.1. 背包(不支持删除)](#111-背包不支持删除)
        - [1.1.2. 队列（先进先出）](#112-队列先进先出)
        - [1.1.3. 栈（后进先出）](#113-栈后进先出)
        - [1.1.4. 可迭代集合类型](#114-可迭代集合类型)
    - [1.2. 链表](#12-链表)
        - [1.2.1. 插入、删除](#121-插入删除)
        - [1.2.2. 遍历](#122-遍历)
        - [1.2.3. 栈的链表实现](#123-栈的链表实现)
        - [1.2.8. 队列的链表实现](#128-队列的链表实现)
        - [1.2.9. 背包的链表实现](#129-背包的链表实现)
    - [1.3. 综述](#13-综述)
    - [1.4. 算法分析](#14-算法分析)

<!-- /TOC -->

# 1.背包、队列、栈

## 1.1. API

### 1.1.1. 背包(不支持删除)
`public class Bag<Item> implements Iterable<Item>`

|类型|函数名|作用|
|:-------:|:---------:|:-----------:|
||Bag()|创建一个空背包|
|void|add(Item item)|添加一个元素|
|boolean|isEmpty()|背包是否为空|
|int|size()|背包中元素数量|

### 1.1.2. 队列（先进先出）
`public class Queue<Item> implements Iterable<Item>`

|类型|函数名|作用|
|:-------:|:---------:|:-----------:|
||Queue()|创建一个空队列|
|void|enqueque(Item item)|添加一个元素|
|Item|dequeque()|删除最早添加的元素|
|boolean|isEmpty()|队列是否为空|
|int|size()|队列中元素数量|

### 1.1.3. 栈（后进先出）
`public class Stack<Item> implements Iterable<Item>`

|类型|函数名|作用|
|:-------:|:---------:|:-----------:|
||Stack()|创建一个空栈|
|void|push(Item item)|添加一个元素|
|Item|pop()|删除最近添加的元素|
|boolean|isEmpty()|栈是否为空|

数学表达式求值可以使用栈，其逻辑遵循：
1. 将操作数压入操作数栈；
2. 将运算符压入运算符栈；
3. 忽略左括号
4. 遇到右括号时，弹出运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。


### 1.1.4. 可迭代集合类型
假设在Queue中：
`Queue<Transaction> collection = new Queue<Transaction>();`

如果集合是可迭代的，可以用一行语句即可打印出列表：

```java
for (Trancsaction t : collection){ 
    StdOut.println(t); 
    }
```

## 1.2. 链表

定义：链表是一种递归的数据结构，它或者为空，或者是指向一个节点(node)的引用，该节点含有一个泛型的元素和一个指向另一个链表的引用。

首先用一个嵌套类来定义节点的抽象数据类型：

```java
private class Node{//节点记录
    Item item;
    Node next;    
}
```
然后为每个元素创造节点：

```java
// 构造链表
Node first = new Node();
Node second = new Node();
Node third = new Node();
```

并将每个节点的item域设为所需的值

```java
first.item = "to";
second.item = "be";
third.item = "or";
```

最后设置next域来构造链表：

```java
first.next = second;
second.next = third;
```

### 1.2.1. 插入、删除

例如，要在首节点为first的给定列表开头插入字符串not。只需要将first保存在oldfirst中，然后将一个新节点赋予first，并将它的item域设为not，next的域设为oldfirst。

删除链表只需要将first指向first.next即可

综上可以得出通过first连接访问链表的首结点，通过last链接访问链表的尾结点：
* 在表头插入结点
* 在表头删除结点
* 在表尾插入结点

而删除尾节点需要将链表尾结点的前一个节点中的链接值改为nul，唯一的办法是遍历整条链表找出指向last的结点。

* 此方法和链表长度挂钩，实现任意插入删除需要使用双向链表。

### 1.2.2. 遍历

要访问一个数组中的所有元素，我们会使用以下代码来循环处理a[]中所有元素：

```java
for (int i = 0; i < N; i++){
    //处理a[i]
}
```

对于链表：

```java
for (Node x = first; x != null; x = x.next){
    //处理x.item
}
```

### 1.2.3. 栈的链表实现

```java
//1.2.7栈的链表实现
public class Stack<Item>{

    private Node first; //栈顶（最近添加的元素）
    private int N;

    private class Node{
        Item item;
        Node next;
    }

    public boolean isEmpty(){ 
        return first == null;
    }

    public int size(){
        return N;
    }

    pubilc void push(Item item){ //从表头添加
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;  
    }

    pubilc Item pop(){//从表头（栈顶）删除元素
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
}
```

### 1.2.8. 队列的链表实现

```java
//1.2.8队列的链表实现（先进先出）
public class Queue<Item>{
    
    private Node first; //最找添加的结点链接
    private Node last; //最近添加的结点链接
    private int N;
    
    private class Node
    {
        Item item;
        Node next;
    }
    
    public boolean isEmpty(){ 
        return first == null;
    }

    public int size(){
        return N;
    }

    pubilc void enqueue(Item item){ //向表尾添加元素
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;  
    }

    pubilc Item dequeue(){//从表头删除元素
        Item item = first.item;
        first = first.next;
        if(isEmpty()) last = null;
        N--;
        return item;
    }
}
```

### 1.2.9. 背包的链表实现

使用链表实现背包只需要将stack中的push()改名为add(),并去除掉pop()即可

```java
//1.2.9背包的链表实现
import java.util.Iterator;

public class Bag<Item>  implements Iterable<Item>{
    
    private Node first;

    private class Node{
        Item item;
        Node next;
    }

    public void add(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
    }

    //迭代器，可以给队列，栈实现遍历列表迭代
    public Iterator<Item> iterator(){ 
        return new ListIterator(); 
    }

    private class ListIterator implements Iterator<Item>{
        private Node current = first;

        public boolean hasNext(){ 
            return current != null; 
        }

        public void remove() { }

        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}
```

## 1.3. 综述

数组的优点是通过索引可以访问任意元素，缺点是在初始化时需要知道元素的数量

链表的优点是使用空间大小和元素数量成正比，缺点是通过应用访问任意元素

## 1.4. 算法分析

|描述|增长数量级|说明|
|---|----|-----|
|常数|1|普通语句|
|对数|logN|二分策略|
|线性（多次为方）|N|循环|
|线性对数|NlogN|分治|
|指数|$2_N$|穷举|