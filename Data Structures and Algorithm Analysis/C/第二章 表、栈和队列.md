# 1.表
## 1.1. 表ADT
对于表的所有操作可以通过数组实现。
定义$A_{i+1}$后继$A_i$, $A_{i-1}$前驱$A_i$
## 1.2. 链表
为了避免插入和删除的线性开销，我们允许表可以不连续存储。

链表即由一系列不必在内存中相连的结构组成。每个结构均含有表元素和指向包含该元素后继元的结构和指针，我们称之为Next指针。最后一个Next指针指向NULL；

对于删除命令可以通过修改指针，使$A_{i-1}$指针直接指向$A_{i+1}$来达到删除$A_i$的目的

对于插入需使用一次malloc调用从系统得到新单元，并将前指针指向新单元，新单元指针指向后单元实现。

## 1.3. 双链表
有时候需要倒序扫描链表，只需在数据结构上附加一个域，使它包含指向前一个单元的指针。

缺点是增加了空间需求，使得插入和删除的开销增加了一倍。

优点是简化了删除操作，不再需使用一个指向前驱元的指针来访问一个关键字。

## 1.4.循环链表
让最后一个单元反过来指向第一个单元，并且还可以是双向链表。

## 1.5.基数排序
如果我们有N个整数，范围从1到M，可以使用一种快速排序，叫做桶式排序。复杂度O(N)

* 1.留置一个数组$Count$,大小为M,初始化为零。
* 2.当$A_i$被读入时$Count[A_i]$加1。
* 3.从头扫描Count[],值为几打印几次。

当N比较大时可以采用按位进桶，先扫描个位排序，再十位百位。复杂度O(P(N+B))，P为排序趟数，N是元素个数，B是桶数。

# 2.栈