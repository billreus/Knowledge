# 1.表
## 1.1. 表ADT
对于表的所有操作可以通过数组实现。
定义$A_{i+1}$后继$A_i$, $A_{i-1}$前驱$A_i$
## 1.2. 链表
为了避免插入和删除的线性开销，我们允许表可以不连续存储。

链表即由一系列不必在内存中相连的结构组成。每个结构均含有表元素和指向包含该元素后继元的结构和指针，我们称之为Next指针。最后一个Next指针指向NULL；

对于删除命令可以通过修改指针，使$A_{i-1}$指针直接指向$A_{i+1}$来达到删除$A_i$的目的

对于插入需使用一次malloc调用从系统得到新单元，并将前指针指向新单元，新单元指针指向后单元实现。

## 1.3. 双链表
有时候需要倒序扫描链表，只需在数据结构上附加一个域，使它包含指向前一个单元的指针。

缺点是增加了空间需求，使得插入和删除的开销增加了一倍。

优点是简化了删除操作，不再需使用一个指向前驱元的指针来访问一个关键字。

## 1.4.循环链表
让最后一个单元反过来指向第一个单元，并且还可以是双向链表。

## 1.5.基数排序
如果我们有N个整数，范围从1到M，可以使用一种快速排序，叫做桶式排序。复杂度O(N)

* 1.留置一个数组$Count$,大小为M,初始化为零。
* 2.当$A_i$被读入时$Count[A_i]$加1。
* 3.从头扫描Count[],值为几打印几次。

当N比较大时可以采用按位进桶，先扫描个位排序，再十位百位。复杂度O(P(N+B))，P为排序趟数，N是元素个数，B是桶数。

# 2.栈
## 2.1 定义
栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶(top)。

栈的基本操作有Push(进栈)和Pop(出栈)，前者相等于插入，后者是删除最后插入的元素。

## 2.2 栈的实现
栈是一个表，所以栈的实现一般使用指针或者数组。

### 2.2.1 栈的链表实现
方法一是使用单链表。通过表顶端插入实现Push，删除表顶端实现Pop。Top操作只考察表顶端元素并返回值。

# 3.队列
## 3.1 定义
像栈一样，队列(queue)也是表，只是队列在插入在一段进行删除在另一端进行。

## 3.2 队列模型
基本操作是Enqueue(入队)，在表的末端(rear)插入元素；Dequeue(出队)，删除在表的开头(front)元素。

数组实现方法：保留一个数组Queue[]以及位置Front和Rear位于队列两端。记录实际存在于队列中的元素个数Size。

让元素X入队：让Size和Rear增1，然后置Queue[Rear]=X。
让元素出队：置返回值为Queue[Front]，Size减1，然后Front增1。

* 为了保证queue充分利用，可以在Front或Rear到达数组尾端就重新绕回开头，即循环数组。
