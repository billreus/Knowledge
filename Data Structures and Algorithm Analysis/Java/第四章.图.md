# 4. 图

由点和连线组成，点常称作“顶点”而点与点之间的连线被称为“边或弧”。记作G=(V,E)。

根据边是否有方向，图可以分为有向图和无向图。

## 4.1. 无向图

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/tu4.1.jpg)

上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，

(01) V1={A,B,C,D,E,F}。 V1表示由"A,B,C,D,E,F"几个顶点组成的集合。 
(02) E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)...等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。

## 4.2. 有向图

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/tu4.102.jpg)

上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，

(01) V2={A,C,B,F,D,E,G}。 V2表示由"A,B,C,D,E,F,G"几个顶点组成的集合。 
(02) A2={<A,B>,<B,C>,<B,F>,<B,E>,<C,E>,<E,D>,<D,C>,<E,B>,<F,G>}。 E1是由矢量<A,B>,矢量<B,C>...等等组成的集合。

## 4.3. 常用定义

邻接点：一条边上的两个顶点。

度：邻接到该顶点的边的数目。

* 有向图中，指向顶点的为入度，指出顶点的为出度。

权：路径带权重

## 4.4. 存储结构

### 4.4.1. 邻接矩阵

邻接矩阵定义：A[i][j] = 1(有边存在) or 0(无边存在)

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.105.jpg)

无向图

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.106.jpg)

有向图

### 4.4.2. 邻接表

邻接表是图的一种链式存储表示方法。它是改进后的"邻接矩阵"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.107.jpg)

无向图

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.108.jpg)

有向图

### 4.4.3. 邻接矩阵无向图

#### 4.4.3.1. 定义

```java
public class MatrixUDG {

    private char[] mVexs;       // 顶点集合
    private int[][] mMatrix;    // 邻接矩阵

    ...
}
```

MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mMatrix则是用于保存矩阵信息的二维数组。

#### 4.4.3.2. 创建图

```java
/*
 * 创建图(用已提供的矩阵)
 *
 * 参数说明：
 *     vexs  -- 顶点数组
 *     edges -- 边数组
 */
public MatrixUDG(char[] vexs, char[][] edges) {

    // 初始化"顶点数"和"边数"
    int vlen = vexs.length;
    int elen = edges.length;

    // 初始化"顶点"
    mVexs = new char[vlen];
    for (int i = 0; i < mVexs.length; i++)
        mVexs[i] = vexs[i];

    // 初始化"边"
    mMatrix = new int[vlen][vlen];
    for (int i = 0; i < elen; i++) {
        // 读取边的起始顶点和结束顶点
        int p1 = getPosition(edges[i][0]);
        int p2 = getPosition(edges[i][1]);

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}
```

```java
/* 
 * 创建图(自己输入数据)
 */
public MatrixUDG() {

    // 输入"顶点数"和"边数"
    System.out.printf("input vertex number: ");
    int vlen = readInt();
    System.out.printf("input edge number: ");
    int elen = readInt();
    if ( vlen < 1 || elen < 1 || (elen > (vlen*(vlen - 1)))) {
        System.out.printf("input error: invalid parameters!\n");
        return ;
    }

    // 初始化"顶点"
    mVexs = new char[vlen];
    for (int i = 0; i < mVexs.length; i++) {
        System.out.printf("vertex(%d): ", i);
        mVexs[i] = readChar();
    }

    // 初始化"边"
    mMatrix = new int[vlen][vlen];
    for (int i = 0; i < elen; i++) {
        // 读取边的起始顶点和结束顶点
        System.out.printf("edge(%d):", i);
        char c1 = readChar();
        char c2 = readChar();
        int p1 = getPosition(c1);
        int p2 = getPosition(c2);

        if (p1==-1 || p2==-1) {
            System.out.printf("input error: invalid edge!\n");
            return ;
        }

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}

```

## 4.5. 图的遍历

### 4.5.1. 深度优先搜索

1. 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，访问该顶点
2. 依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，
3. 直至图中所有和v有路径相通的顶点都被访问到。 
4. 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，
5. 重复上述过程，直至图中所有顶点都被访问到为止。

显然，深度优先搜索是一个递归的过程。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.202.jpg)

A-C-B-D-F-G-E

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.204.jpg)

A -> B -> C -> E -> D -> F -> G

### 4.5.2. 广度优先搜索(BFS)

1. 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点
2. 分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。
3. 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

* 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.205.jpg)

A -> C -> D -> F -> B -> G -> E

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/4.206.jpg)

A -> B -> C -> E -> F -> D -> G