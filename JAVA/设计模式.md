# 设计模式

## 1 概念

设计模式是对软件设计中普遍存在的各种问题，所提出的 解决方案。

### 1.1 原则

#### 1.1.1 开闭原则

对扩展开放，对修改封闭。

在程序需要扩展的时候，不去修改原有代码，实现热插拔效果。为此我们需要使用接口和抽象类。

#### 1.1.2 里氏代换原则

只有当子类可以替换基类时，基类才能真正被复用。

#### 1.1.3 依赖倒转原则

：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。

#### 1.1.4 接口隔离原则

使用多个隔离的接口，比使用单个庞大的接口要好。

#### 1.1.5 单一职责原则

类的职责单一，不能将太多职责放在一个类中。

#### 1.1.6 最少知道原则

一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

#### 1.1.7 合成复用原则

一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。

### 1.2 设计模式

通常来说设计模式分为三大类：

* 创建型模式，共5种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。

* 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

* 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 2 工厂模式

### 2.1 含义

工厂通常是一个用来创建其他对象的对象。工厂模式根据不同的参数来实现不同的分配方案和创建对象。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

### 2.2 普通工厂模式

普通工厂模式来创建人，先创建一个男人，他每天吃饭睡觉打豆豆。再创建一个女人，她每天吃饭睡觉打豆豆。

定义了接口human代替class male和female在class HumanFactory中的重复引用。

```java
// 二者共同的接口
public interface Human{
    public void eat();
    public void sleep();
    public void beat();
}

// 创建实现类 Male
public class Male implements Human{
    public void eat(){
        System.out.println("Male can eat."); 
    }
    public void sleep(){
        System.out.println("Male can sleep.");
    }
    public void beat(){
        System.out.println("Male can beat.");
    }
} 
//创建实现类 Female
public class Female implements Human{
    public void eat(){
        System.out.println("Female can eat."); 
    }
    public void sleep(){
        System.out.println("Female can sleep.");
    }
    public void beat(){
        System.out.println("Female can beat.");
    }
} 

// 创建普通工厂类
public class HumanFactory{
    public Human createHuman(String gender){
        if( gender.equals("male") ){
           return new Male();
        }else if( gender.equals("female")){
           return new Female();
        }else {
            System.out.println("请输入正确的类型！");
            return null;
        }
    }
}

// 工厂测试类
public class FactoryTest {
    public static void main(String[] args){
        HumanFactory factory = new HumanFactory();
        Human male = factory.createHuman("male");
        male.eat();
        male.sleep();
        male.beat();
    }
}
```

### 2.3 多个工厂方法模式

普通工厂模式中，如果传递字符串则会出错，不能创建对象。多个工厂方法模式提供多个工厂方法，分别创建对象。

接口的使用和普通工厂一样，实现了类似的类声明只需要使用接口。

```java
// 多个工厂方法
public class HumanFactory{
    public Male createMale() {
        return new Male();
    }
    public Female createFemale() {
        return new Female();
    }
}

// 工厂测试类
public class FactoryTest {
    public static void main(String[] args){
        HumanFactory factory = new HumanFactory();
        Human male = factory.createMale();
        male.eat();
        male.sleep();
        male.beat();
    }
}
```

### 2.4 静态工厂方法模式

将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。

```java
// 多个工厂方法
public class HumanFactory{
    public static Male createMale() {
        return new Male();
    }
    public static Female createFemale() {
        return new Female();
    }
}

// 工厂测试类
public class FactoryTest {
    public static void main(String[] args){
        Human male = HumanFactory.createMale();
        male.eat();
        male.sleep();
        male.beat();
    }
}
```

### 2.5 抽象工厂模式

在普通工厂的基础上，对工厂的类也使用接口调用，实现了多个工厂公用一个接口调用

```java
// 抽象食物
interface Food {
    public String getFoodName();
}

// 抽象餐具
interface TableWare {
    public String getToolName();
}

// 抽象工厂
interface KitchenFactory {
    public Food getFood();
    public TableWare getTableWare();
}

//具体食物 Apple 的定义如下
class Apple implements Food{
    public String getFoodName() {
        return "apple";
    }
}

//具体餐具 Knife 的定义如下
class Knife implements TableWare {
    public String getToolName() {
        return "knife";
    }
}

// 具体工厂接口下的 AKitchen ，可以分生出B、C、D厨房等
class AKitchen implements KitchenFactory {

    public Food getFood() {
       return new Apple();
    }

    public TableWare getTableWare() {
       return new Knife();
    }
}

// 吃货要开吃了
public class Foodaholic {

    public void eat(KitchenFactory k) {
       System.out.println("A foodaholic is eating "+ k.getFood().getFoodName()
              + " with " + k.getTableWare().getToolName() );
    }

    public static void main(String[] args) {
       Foodaholic fh = new Foodaholic();
       KitchenFactory kf = new AKitchen();
       fh.eat(kf);
    }
}
```

抽象工厂模式特别适合于这样的一种产品结构：产品分为几个系列，在每个系列中，产品的布局都是类似的，在一个系列中某个位置的产品，在另一个系列中一定有一个对应的产品。这样的产品结构是存在的，这几个系列中同一位置的产品可能是互斥的，它们是针对不同客户的解决方案，每个客户都只选择其一。

工厂方法模式：针对的是 一个产品等级结构。

抽象工厂模式：针对 多个产品等级结构。

## 3 适配器模式

在国内的家中只能用国标接口进行充电

```java
// 国标插头
public interface CnPluginInterface {
    void chargeWith2Pins();
}

// 实现国标插座的充电方法
public class CnPlugin implements CnPluginInterface {
    public void chargeWith2Pins() {
        System.out.println("charge with CnPlugin");
    }
}

// 在国内家中充电
public class Home {
    private CnPluginInterface cnPlugin;

    public Home() { }

    public Home(CnPluginInterface cnPlugin) {
        this.cnPlugin = cnPlugin;
    }

    public void setPlugin(CnPluginInterface cnPlugin) {
        this.cnPlugin = cnPlugin;
    }

    // 充电
    public void charge() {
        // 国标充电
        cnPlugin.chargeWith2Pins();
    }
}

// 国标测试类
public class CnTest {
    public static void main(String[] args) {
        CnPluginInterface cnPlugin = new CnPlugin();
        Home home = new Home(cnPlugin);
        // 会输出 “charge with CnPlugin”
        home.charge();
    }
}
```

然而，当把 iPhone6 带回来时，因为与家里的插座不匹配，所以需要一个适配器。这个适配器必须满足以下条件：

必须符合国内标准的接口，否则的话还是没办法插到国内插座中；
在调用上面实现的国标接口进行充电时，提供一种机制，将这个调用转到对英标接口的调用 。
这就要求：

适配器必须实现原有的旧的接口
适配器对象中持有对新接口的引用，当调用旧接口时，将这个调用委托给实现新接口的对象来处理，也就是在适配器对象中组合一个新接口。

```java
// 英标插头
public interface EnPluginInterface {
    void chargeWith3Pins();
}

// 实现英标插座的充电方法
public class EnPlugin implements EnPluginInterface {
    public void chargeWith3Pins() {
        System.out.println("charge with EnPlugin");
    }
}

//适配器
public class PluginAdapter implements CnPluginInterface {
     private EnPluginInterface enPlugin;

     public PluginAdapter(EnPluginInterface enPlugin) {
         this.enPlugin = enPlugin;
 }

 // 这是重点，适配器实现了英标的插头，然后重载国标的充电方法为英标的方法

public void chargeWith2Pins() {
    enPlugin.chargeWith3Pins();
     }
}

// 适配器测试类
public class AdapterTest {
    public static void main(String[] args) {
        EnPluginInterface enPlugin = new EnPlugin();
        Home home = new Home();
        PluginAdapter pluginAdapter = new PluginAdapter(enPlugin);
        home.setPlugin(pluginAdapter);
        // 会输出 “charge with EnPlugin”
        home.charge();
    }
}
```

当你想使用一个已有的类，但是这个类的接口跟你的又不一样，不能拿来直接用，这个时候你就需要一个适配器来帮你了，其主要作用就是在旧的接口、新的接口之间完成适配。