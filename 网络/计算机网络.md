<!-- TOC -->

- [1. 计算机网络体系](#1-计算机网络体系)
    - [1.1. 五层协议](#11-五层协议)
    - [1.2. OSI](#12-osi)
    - [1.3. TCP/IP](#13-tcpip)
    - [1.4. 数据传输过程](#14-数据传输过程)
- [2. 物理层](#2-物理层)
- [3. 数据链路层](#3-数据链路层)
    - [3.1. 封装成帧](#31-封装成帧)
    - [3.2. 信道分类](#32-信道分类)
    - [3.3. 信道复用技术](#33-信道复用技术)
    - [3.4. MAC地址](#34-mac地址)
    - [3.5. 交换机](#35-交换机)
- [4. 网络层](#4-网络层)
    - [4.1. IP数据报格式](#41-ip数据报格式)
    - [4.2. VPN虚拟专用网](#42-vpn虚拟专用网)
    - [4.3. NAT网络地址转换](#43-nat网络地址转换)
- [5. 传输层](#5-传输层)
    - [5.1. UDP和TCP](#51-udp和tcp)
    - [5.2. TCP三次握手](#52-tcp三次握手)
    - [5.3. TCP四次挥手](#53-tcp四次挥手)
- [6. 应用层](#6-应用层)
    - [6.1. 域名系统](#61-域名系统)
    - [6.2. 文件传输协议FTP](#62-文件传输协议ftp)
- [7. Web页面请求过程](#7-web页面请求过程)
- [8. HTTP](#8-http)
    - [8.1. 基础概念](#81-基础概念)
    - [8.2. 请求和相应报文](#82-请求和相应报文)
    - [8.3. HTTP方法](#83-http方法)
    - [8.4. 状态码](#84-状态码)
    - [8.5. Cookie](#85-cookie)
        - [8.5.1. 用途](#851-用途)
        - [8.5.2. 创建过程](#852-创建过程)
        - [8.5.3. Session](#853-session)
        - [8.5.4. Cookie 与 Session 选择](#854-cookie-与-session-选择)
    - [8.6. GET和POST比较](#86-get和post比较)
        - [8.6.1. 参数](#861-参数)
        - [8.6.2. 安全](#862-安全)

<!-- /TOC -->

# 1. 计算机网络体系

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net.png)

## 1.1. 五层协议

应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。

传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

## 1.2. OSI

相对于五层协议，在应用层多了表示和会话层，五层协议没有表示层和会话层，是将这些功能留给应用程序开发者处理。

表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。

会话层 ：建立及管理会话。

## 1.3. TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net1.png)

TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占据举足轻重的地位。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net2.png)

## 1.4. 数据传输过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net3.jpg)

# 2. 物理层

通信方式：单工，半双工，全双工通信

带通调制：把数字信号转换为模拟信号

# 3. 数据链路层

## 3.1. 封装成帧

将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net4.jpg)

## 3.2. 信道分类

1. 广播

一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。

2. 点对点

一对一通信，不会发生碰撞，使用PPP协议进行控制

## 3.3. 信道复用技术

1. 频分复用：所有主机在相同时间占用不同的带宽资源。
2. 时分复用：所有主机在不同的时间占用相同的带宽资源。
3. 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。
4. 波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。

## 3.4. MAC地址

MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

## 3.5. 交换机

交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。

正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。

# 4. 网络层

IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

与 IP 协议配套使用的还有三个协议：

* 地址解析协议 ARP（Address Resolution Protocol）
* 网际控制报文协议 ICMP（Internet Control Message Protocol）
* 网际组管理协议 IGMP（Internet Group Management Protocol）

## 4.1. IP数据报格式

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net5.jpg)

* 版本 : 有 4（IPv4）和 6（IPv6）两个值；

* 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。

* 区分服务 : 用来获得更好的服务，一般情况下不使用。

* 总长度 : 包括首部长度和数据部分长度。

* 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。

* 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。

* 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。

* 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。

* 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

## 4.2. VPN虚拟专用网

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

## 4.3. NAT网络地址转换

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。

# 5. 传输层

## 5.1. UDP和TCP

* 用户数据报协议 UDP（User Datagram Protocol）：是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信。

* 传输控制协议 TCP(Transmission Control Protocol):是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的（一对一）。
  
## 5.2. TCP三次握手

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.png)

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
5. B 收到 A 的确认后，连接建立。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## 5.3. TCP四次挥手

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/net6.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

* A 发送连接释放报文，FIN=1。

* B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

* 当 B 不再需要连接时，发送连接释放报文，FIN=1。

* A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

* B 收到 A 的确认后释放连接。

四次挥手原因： 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT: 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。

这么做有两个理由：

确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

# 6. 应用层

## 6.1. 域名系统

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性

## 6.2. 文件传输协议FTP

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

* 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
* 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

* 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。

* 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

# 7. Web页面请求过程

1. DHCP配置主机信息
2. ARP解析MAC地址
3. DNS解析域名
4. HTTP请求页面

# 8. HTTP

## 8.1. 基础概念

URI分为URL和URN，目前WEB使用URL。例如：http://wwww.abc.com/index.html

## 8.2. 请求和相应报文

请求报文

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/http1.png)

响应报文

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/http2.png)

## 8.3. HTTP方法

客户端发送的请求报文第一行为请求行，包含了方法

1. GET:获取资源
2. HEAD:获取报文首部，和GET方法一样，不返回报文实体，主要用于确认URL的有效性和资源更新的日期时间等。
3. POST:传输实体主体，POST主要用于传输数据，GET主要用于获取资源。
4. PUT：上传文件
5. PAECH:对资源进行部分修改
6. DELETE:删除文件
7. OPRIONS:查询支持方法，会返回Allow: GET, POST, HEAD, OPTIONS 这样的内容。
8. CONNECT:要求与代理服务器通信时建立隧道
9. TRACE:追踪路径

## 8.4. 状态码

服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

column0 | column1 | column2
------- | ------- | -------
状态码 | 类别 | 原因短语
1XX | Informational（信息性状态码） | 接收的请求正在处理
2XX | Success（成功状态码） | 请求正常处理完毕
3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求
4XX | Client Error（客户端错误状态码） | 服务器无法处理请求
5XX | Server Error（服务器错误状态码）

## 8.5. Cookie

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

### 8.5.1. 用途

* 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
* 个性化设置（如用户自定义设置、主题等）
* 浏览器行为跟踪（如跟踪分析用户行为等)

### 8.5.2. 创建过程

服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 8.5.3. Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：

* 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
* 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
* 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
* 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

### 8.5.4. Cookie 与 Session 选择

1. Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
2. Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
3. 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

## 8.6. GET和POST比较

GET 用于获取资源，而 POST 用于传输实体主体。

### 8.6.1. 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参考支持标准字符集。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1

POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

### 8.6.2. 安全

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

