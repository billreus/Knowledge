# 1. Java内存区域与内存溢出异常

虚拟机实现了自动内存管理机制，不用为每一个new操作配对delete/free代码，也不容易出现内存泄露和内存溢出。

## 1.1. 数据区域

Java虚拟机在执行程序时会把所管理的内存划分成若干个数据区域。每个区域有各自的用途，创建和销毁时间。

主要有五个区域：

1. 方法区(Method Area)
2. 虚拟机栈(VM Stack)
3. 本地方法栈(Native Method Stack)
4. 堆(Heap)
5. 程序计数器(Program Counter Register)

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/suju.png)

### 1.1.1. 程序计数器

程序计数器是一块较小的内存空间，记录正在执行的虚拟机字节码指令的地址。

字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等基础功能都需要依赖这个计数器完成。

### 1.1.2. 虚拟机栈

虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。每个方法从执行到执行完成对应着一个栈帧在虚拟机栈中入栈到出栈。

### 1.1.3. 本地方法栈

与虚拟机栈作用相似，虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机使用到的Native方法服务。

### 1.1.4. Java堆

是Java虚拟机管理的内存中最大一块，在虚拟机启动时创建。用于存放对象实例，对象实例在这里分配内存。

* Java堆是垃圾收集器管理的主要区域(GC堆)

### 1.1.5. 方法区

与Java堆一样是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 1.1.6. 运行时常量池

是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区运行时存放在常量池中。

## 1.2. 虚拟机对象

### 1.2.1. 对象的创建

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有先执行相应类的加载
2. 虚拟机为新生对象分配内存
3. 虚拟机对对象进行必要的设置，例如是哪个类的实例，如何找到类的元数据，对象哈希码等

### 1.2.2. 对象的内存分布

对象在内存中存储分布可以分为3块区域：对象头，实例数据，对齐填充

对象头分为两部分，一部分是用于存储对象自身运行的数据，如哈希码，锁的标志位，GC分代年龄等，其被称为Mark Word；另一部分是类型指针，用于确定这个对象是哪个类的实例。

实例数据是对象真正存储的有效信息，即代码中定义的各种类型的字段内容。

### 1.2.3. 对象的访问定位

通过栈上的reference数据来操作堆上的具体对象。

访问方式：
1. 句柄访问
2. 直接指针访问

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/jubin.jpg)

句柄访问时Java堆中会划分一块内存作为句柄池，reference中存储的对象就是句柄地址，句柄中包含了对象实例数据与类型数据各自的具体信息地址。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/zhizhen.jpg)

直接指针访问必须考虑如何放置访问类型数据的相关信息，reference中存储的是对象地址。

句柄访问在对象移动只虚改变指针即可，而直接访问好处是速度更快，目前虚拟机使用第二种。

# 2. 垃圾收集器与内存分配策略

## 2.1. 可达性算法

最原始的方法是引用计数，不过当互相引用对象时会导致引用计数都不为0。

可达性分析通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，被判定为可回收对象。

## 2.2. 垃圾收集算法

### 2.2.1. 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

不过效率不高，清除后会产生大量不连续内存碎片。

### 2.2.2. 复制算法

用内存按容量划分两个大小相等的两块，每次只用一块，当一块内存用完了就把还活着的对象复制到另一块上面，把已使用过的内存空间一次清理掉。

使得每次都是对整个半区进行内存回收，内存分配也不用考虑碎片，只需要移动堆顶指针，简单高效，不过代价是内存缩小一半。

### 2.2.3. 标记-整理算法

与复制相似，不过不是直接对可回收对象进行清理，二三让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。

