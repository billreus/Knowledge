# 1. Java内存区域与内存溢出异常

虚拟机实现了自动内存管理机制，不用为每一个new操作配对delete/free代码，也不容易出现内存泄露和内存溢出。

## 1.1. 数据区域

Java虚拟机在执行程序时会把所管理的内存划分成若干个数据区域。每个区域有各自的用途，创建和销毁时间。

主要有五个区域：

1. 方法区(Method Area)
2. 虚拟机栈(VM Stack)
3. 本地方法栈(Native Method Stack)
4. 堆(Heap)
5. 程序计数器(Program Counter Register)

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/suju.png)

### 1.1.1. 程序计数器

程序计数器是一块较小的内存空间，记录正在执行的虚拟机字节码指令的地址。

字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等基础功能都需要依赖这个计数器完成。

### 1.1.2. 虚拟机栈

虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。每个方法从执行到执行完成对应着一个栈帧在虚拟机栈中入栈到出栈。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/xunijizhan.png)

### 1.1.3. 本地方法栈

与虚拟机栈作用相似，虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机使用到的本地方法服务。

### 1.1.4. Java堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

是Java虚拟机管理的内存中最大一块，在虚拟机启动时创建。用于存放对象实例，对象实例在这里分配内存。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。

### 1.1.5. 方法区

与Java堆一样是各个线程共享的内存区域，用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 1.1.6. 运行时常量池

是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区运行时存放在常量池中。

### 1.1.7 直接内存

在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。

这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

## 1.2. 虚拟机对象

### 1.2.1. 对象的创建

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有先执行相应类的加载
2. 虚拟机为新生对象分配内存
3. 虚拟机对对象进行必要的设置，例如是哪个类的实例，如何找到类的元数据，对象哈希码等

### 1.2.2. 对象的内存分布

对象在内存中存储分布可以分为3块区域：对象头，实例数据，对齐填充

对象头分为两部分，一部分是用于存储对象自身运行的数据，如哈希码，锁的标志位，GC分代年龄等，其被称为Mark Word；另一部分是类型指针，用于确定这个对象是哪个类的实例。

实例数据是对象真正存储的有效信息，即代码中定义的各种类型的字段内容。

### 1.2.3. 对象的访问定位

通过栈上的reference数据来操作堆上的具体对象。

访问方式：
1. 句柄访问
2. 直接指针访问

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/jubin.jpg)

句柄访问时Java堆中会划分一块内存作为句柄池，reference中存储的对象就是句柄地址，句柄中包含了对象实例数据与类型数据各自的具体信息地址。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/zhizhen.jpg)

直接指针访问必须考虑如何放置访问类型数据的相关信息，reference中存储的是对象地址。

句柄访问在对象移动只虚改变指针即可，而直接访问好处是速度更快，目前虚拟机使用第二种。

# 2. 垃圾收集器与内存分配策略

## 2.1. 判断对象是否可被回收算法

### 2.1.1. 引用计数算法

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

### 2.1.2. 可达性算法

通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：

* 虚拟机栈中局部变量表中引用的对象
* 本地方法栈中 JNI 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象

## 2.2. 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

### 2.2.1. 强引用

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

### 2.2.2. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

### 2.2.3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来实现弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### 2.2.4. 修引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。

为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 2.3. 垃圾收集算法

### 2.2.1. 标记-清除算法

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/laji1.jpg)

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

不过效率不高，清除后会产生大量不连续内存碎片，导致无法给大对象分配内存。

### 2.2.2. 复制算法

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/laji3.jpg)

用内存按容量划分两个大小相等的两块，每次只用一块，当一块内存用完了就把还活着的对象复制到另一块上面，把已使用过的内存空间一次清理掉。

使得每次都是对整个半区进行内存回收，内存分配也不用考虑碎片，只需要移动堆顶指针，简单高效，不过代价是内存缩小一半。

### 2.2.3. 标记-整理算法

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/laji2.jpg)

与复制相似，不过不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 2.2.4. 分代收集

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

* 新生代使用：复制算法
* 老年代使用：标记 - 清除 或者 标记 - 整理 算法

## 2.4. 垃圾收集器

