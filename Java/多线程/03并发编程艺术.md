# 1. 并发底层原理

## 1.1. 补充概念

并发三要素：
1. 原子性：一个或多个操作要么全部执行成功要么全部执行失败。
2. 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. 可见性：当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。

悲观锁：每次操作都加锁，会造成线程阻塞

乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。​

## 1.2. volatile

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。

实现可见性的过程：
1. 将当前处理器的缓存行的数据写回到系统内存
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

* 为了提高处理速度，处理器不直接和内存通信，二三先将系统内存的数据读取到内部缓存后进行操作。
* 会使其他CPU数据无效的原因是：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

## 1.3. synchronized

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

### 1.3.1. Java对象头

synchronized用的锁是存在Java对象头里。

Java对象头包含三个内容：
1. Mark Word：存储对象的hashCode或者锁信息
2. Class Meradata Address：存储到对象类型数据的指针
3. Array length: 数组的长度

### 1.3.2. 锁的升级与对比

锁一共有4种状态，级别从高到低依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。

* 锁可以升级不可降级。目的是为了提高获得锁和释放锁的效率。

#### 1.3.2.1. 偏向锁

