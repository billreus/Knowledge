# 1. 并发底层原理

## 1.1. 补充概念

并发三要素：
1. 原子性：一个或多个操作要么全部执行成功要么全部执行失败。
2. 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. 可见性：当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。

悲观锁：每次操作都加锁，会造成线程阻塞

乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。​

## 1.2. volatile

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。

实现可见性的过程：
1. 将当前处理器的缓存行的数据写回到系统内存
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

* 为了提高处理速度，处理器不直接和内存通信，二三先将系统内存的数据读取到内部缓存后进行操作。
* 会使其他CPU数据无效的原因是：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

## 1.3. synchronized

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

### 1.3.1. Java对象头

synchronized用的锁是存在Java对象头里。

Java对象头包含三个内容：
1. Mark Word：存储对象的hashCode或者锁信息
2. Class Meradata Address：存储到对象类型数据的指针
3. Array length: 数组的长度

### 1.3.2. 锁的升级与对比

锁一共有4种状态，级别从高到低依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。

* 锁可以升级不可降级。目的是为了提高获得锁和释放锁的效率。

#### 1.3.2.1. 偏向锁

由于锁不仅存在多线程竞争，而且总由同一线程多次获得，为了使获得锁的代价更低引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后进出该线程只需要测试对象头Mark Word中是否存储着指向当前线程的偏向锁。

* CAS替换Mark Word即从无锁到锁状态。

撤销：等到竞争出现才释放锁。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/chexiao.jpg)

#### 1.3.2.2. 轻量级锁

加锁过程：
1. 线程执行同步块前，JVM会对当前线程的栈帧中创建用于存储锁的记录空间，并将对象头中的Mark Word复制到锁记录中。(Displaced Mark Word)
2. 线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
3. 如果成功当前线程获得锁，如果失败表示当前线程尝试使用自旋来获取锁。

解锁过程：
1. 使用原子的CAS操作将Displaced Mark Word替换回对象头
2. 如果替换成功表示没有竞争，如果失败表示当前锁存在竞争，锁就会膨胀成重量锁。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/qinliansuo.png)

因为自旋会消耗CPU，所以一旦锁升级就不会在恢复到轻量锁状态。

#### 1.3.2.3. 锁的优缺点

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/suoyou.png)

## 1.4. 原子操作

### 1.4.1. 保证原子性

1. 使用总线锁保证原子性

多个处理器同时对缓存中变量读取和操作会造成操作不是原子的，为此总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器输出此信号，其他处理器请求会被阻塞，该处理器可以独占共享内存。

2. 使用缓存锁保证原子性

总线锁在锁住内存的同时，也把CPU和内存之间的通信锁住，使得其它处理器不能操作其他内存地址的数据，所所以开销比较大。缓存锁可以实现对某个内存地址的操作是原子性的。

缓存锁定的原理：处理器不在总线上声言LOCK#信号，而是修改内部内存地址，由于缓存一致性机制会阻止同时修改内存区域数据，使得其它处理器写入无效。

### 1.4.2. Java实现

Java中可以通过锁和循环CAS方式来实现原子操作。

# 2. Java内存模型JMM

并发的核心是：线程之间如何通信和线程之间如何同步。

通信是指线程之间以何种机制来交换信息，一般采用共享内存和消息传递。

## 2.1. 共享内存和消息传递

共享内存：线程之间通过共享程序的公共状态，通过写-读内存中的公共状态进行隐私通信。同步是显示进行的，某个方法或代码必须在线程之间互斥执行。

消息传递：线程间没有公共状态，必须通过发送消息来进行通信。由于消息发送在消息接受之前，所以同步是隐式的。

Java并发采用共享内存模型，线程间通信是隐式的。

## 2.2. 抽象结构

Java中所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。 局部变量，方法定义参数和异常参数不会共享。

Java内存模型的抽象示意图如下：

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/JMM1.jpg)

如上图线程A和B如果要通信，需要以下步骤：
1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去
2. 线程B到主内存中去读取线程A之前已更新过的共享变量

步骤示意如下图：

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/JMM2.png)

## 2.3. happens-before

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。

Java使用JSR-133内存模型，有如下的happens-before规则：
1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁
3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

## 2.4. 重排序

数据依赖性：读和写访问同一个变量。

由于编译器和处理器为了优化性能对指令序列会进行重排序，读写顺序就有可能会变化。

为了遵循as-if-serial规则对数据依赖关系的操作不进行重排序。

## 2.5. volatile

把volatile变量的单个读/写看成使用同一个锁对这些单个读/写操作进行了同步。

示例：

```java
class VolatileFeaturesExample{
    volatile long vl = 0L; //使用volatile声明64位long变量

    public void set(long l){//单个volatile变量的写
        v1 = l;
    }

    public void getAndIncrement(){//多个volatile变量的读/写
        vl++;
    }

    public long get(){//单个volatile变量的读
        return vl;
    }
}
```

假设有多个线程调用上面的3个方法，这个程序语义上与下面程序等价

```java
class VolatileFeatturesExample{
    long vl = 0L;

    public synchronized void set(long l){
        vl = l;
    }
    public void getAndIncrement(){//
        long temp = get(); //同步读
        temp += 1L; //普通+1写操作
        set(temp); //同步写
    }
    public synchronized long get(){
        return vl;
    }
}
```

综上可以看出对于volatile变量进行读/写是具有原子性的，如果是多个volatile操作不具有原子性。

### 2.5.1. 内存操作

volatile写读操作如下：
1. 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。
2. 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。
3. 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。

## 2.6. 锁的原理

```java
class MonitorExample {
    int a = 0;
    public synchronized void writer() { // 1
        a++;　　　　　　　　　　          // 2
    }　　　　　　　　　　　　             // 3
    public synchronized void reader() { // 4
        int i = a;　　　　　　　　       // 5
        ……
    }　　　　　　　　　　　　             // 6
}
```

假设线程A执行writer()方法后B执行reader()方法。根据happens-before规则：
1. 程序次序: 1happens-before2, 2happens-before3, 4happens-before5, 5happens-before6
2. 监视器锁: 3happens-before4
3. 根据传递性： 2happens-before5

* 锁的特性体现在第二步

### 2.6.1. 锁的释放

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。

当程序获取锁时，JMM会把该线程对应的本地内存置为无效，使得必须从主内存中读取共享变量。

可以看出锁的释放与volatile写，锁的获取与volatile读有相同的内存语义。

### 2.6.2. 锁的实质

* 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。
* 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
* 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。

 ### 2.6.3. CAS和AQS

CAS(CompareAndSet()方法)，即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。

由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。
1. A线程写volatile变量，随后B线程读这个volatile变量。
2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
3. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
4. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，如下图所示：

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/CASAQS.png)

## 2.6. final

final域遵循两个重排序规则：
1. 在构造函数内对一个final域的写入和把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
2. 第一次读一个包含final域的对象的引用和初次读这个final域之间不能重排序

示例：

```java
public class FinalExample {
    int i;　　　　　　　　　　// 普通变量
    final int j;　　　　　　　　// final变量
    static FinalExample obj;
    
    public FinalExample () {　　// 构造函数
        i = 1;　　　　　　　　// 写普通域
        j = 2;　　　　　　　　// 写final域
    }

    public static void writer () {　// 写线程A执行
        obj = new FinalExample ();
    }

    public static void reader () {　// 读线程B执行
        FinalExample object = obj; // 读对象引用
        int a = object.i;　　　　　// 读普通域
        int b = object.j;　　　　　// 读final域
    }
}
```

写final域的重排序规则可以确保在对象obj在引用之前，已经被正确初始化过。而普通域在读线程B的对象引用obj时可能obj对象还没构造完成。

## 2.7. 总结

关键字volatile主要用来修饰字段，告知程序任何对该变量的访问都需要从共享内存中获取，对它的获取也必须同步刷新共享内存，保证了所有线程对变量访问的可见性。

关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

# 3. 