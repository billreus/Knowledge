# 1. 并发底层原理

## 1.1. 补充概念

并发三要素：
1. 原子性：一个或多个操作要么全部执行成功要么全部执行失败。
2. 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. 可见性：当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。

悲观锁：每次操作都加锁，会造成线程阻塞

乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。​

## 1.2. volatile

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。

实现可见性的过程：
1. 将当前处理器的缓存行的数据写回到系统内存
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

* 为了提高处理速度，处理器不直接和内存通信，二三先将系统内存的数据读取到内部缓存后进行操作。
* 会使其他CPU数据无效的原因是：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

## 1.3. synchronized

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

### 1.3.1. Java对象头

synchronized用的锁是存在Java对象头里。

Java对象头包含三个内容：
1. Mark Word：存储对象的hashCode或者锁信息
2. Class Meradata Address：存储到对象类型数据的指针
3. Array length: 数组的长度

### 1.3.2. 锁的升级与对比

锁一共有4种状态，级别从高到低依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。

* 锁可以升级不可降级。目的是为了提高获得锁和释放锁的效率。

#### 1.3.2.1. 偏向锁

由于锁不仅存在多线程竞争，而且总由同一线程多次获得，为了使获得锁的代价更低引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后进出该线程只需要测试对象头Mark Word中是否存储着指向当前线程的偏向锁。

* CAS替换Mark Word即从无锁到锁状态。

撤销：等到竞争出现才释放锁。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/chexiao.jpg)

#### 1.3.2.2. 轻量级锁

加锁过程：
1. 线程执行同步块前，JVM会对当前线程的栈帧中创建用于存储锁的记录空间，并将对象头中的Mark Word复制到锁记录中。(Displaced Mark Word)
2. 线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
3. 如果成功当前线程获得锁，如果失败表示当前线程尝试使用自旋来获取锁。

解锁过程：
1. 使用原子的CAS操作将Displaced Mark Word替换回对象头
2. 如果替换成功表示没有竞争，如果失败表示当前锁存在竞争，锁就会膨胀成重量锁。

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/qinliansuo.png)

因为自旋会消耗CPU，所以一旦锁升级就不会在恢复到轻量锁状态。

#### 1.3.2.3. 锁的优缺点

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/suoyou.png)

## 1.4. 原子操作

### 1.4.1. 保证原子性

1. 使用总线锁保证原子性

多个处理器同时对缓存中变量读取和操作会造成操作不是原子的，为此总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器输出此信号，其他处理器请求会被阻塞，该处理器可以独占共享内存。

2. 使用缓存锁保证原子性

总线锁在锁住内存的同时，也把CPU和内存之间的通信锁住，使得其它处理器不能操作其他内存地址的数据，所所以开销比较大。缓存锁可以实现对某个内存地址的操作是原子性的。

缓存锁定的原理：处理器不在总线上声言LOCK#信号，而是修改内部内存地址，由于缓存一致性机制会阻止同时修改内存区域数据，使得其它处理器写入无效。

### 1.4.2. Java实现

Java中可以通过锁和循环CAS方式来实现原子操作。

# 2. Java内存模型JMM

并发的核心是：线程之间如何通信和线程之间如何同步。

通信是指线程之间以何种机制来交换信息，一般采用共享内存和消息传递。

## 2.1. 共享内存和消息传递

共享内存：线程之间通过共享程序的公共状态，通过写-读内存中的公共状态进行隐私通信。同步是显示进行的，某个方法或代码必须在线程之间互斥执行。

消息传递：线程间没有公共状态，必须通过发送消息来进行通信。由于消息发送在消息接受之前，所以同步是隐式的。

Java并发采用共享内存模型，线程间通信是隐式的。

## 2.2. 抽象结构

Java中所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。 局部变量，方法定义参数和异常参数不会共享。

Java内存模型的抽象示意图如下：

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/JMM1.jpg)

如上图线程A和B如果要通信，需要以下步骤：
1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去
2. 线程B到主内存中去读取线程A之前已更新过的共享变量

步骤示意如下图：

![Image text](https://github.com/billreus/Konwledge/blob/master/picture/JMM2.png)

## 2.3. happens-before

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。

Java使用JSR-133内存模型，有如下的happens-before规则：
1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁
3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

## 2.4. 重排序