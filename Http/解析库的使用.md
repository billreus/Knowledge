## 4.1 XPath使用

### 4.1.1 常用规则

nodename:选取此节点的所有子节点

/:从当前节点选取直接子节点

//：从当前节点选取子孙节点

.：选取当前节点

..：选取当前节点的父节点

@：选取属性

### 4.1.2 实例

```py
from lxml import etree
text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </ul>
 </div>
'''
html = etree.HTML(text)
result = etree.tostring(html)
print(result.decode('utf-8'))
```

首先调用了etree模块的HTML类对text中的html文本进行初始化，由于最后一个li节点没有闭合，再调用tostring进行修正，但是结果是bytes类型，最后利用decode()方法转成str类型。

输出结果如下：

```html
<html><body><div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </li></ul>
 </div>
</body></html>
```

li节点不仅给补全，还自动添加了body、html节点

除了上面方法也可以直接对文本文件进行解析：

```py
from lxml import etree

html = etree.parse('./test.html', etree.HTMLParser())
result = etree.tostring(html)
print(result.decode('utf-8'))
```

### 4.1.3 所有节点

如果我们要选取所有节点，只需要使用//开头的XPath

```py
from lxml import etree
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//*')
print(result)

>>> [<Element html at 0x10510d9c8>, <Element body at 0x10510da08>, <Element div at 0x10510da48>, <Element ul at 0x10510da88>, <Element li at 0x10510dac8>, <Element a at 0x10510db48>, <Element li at 0x10510db88>, <Element a at 0x10510dbc8>, <Element li at 0x10510dc08>, <Element a at 0x10510db08>, <Element li at 0x10510dc48>, <Element a at 0x10510dc88>, <Element li at 0x10510dcc8>, <Element a at 0x10510dd08>]
```

代码中的*代表匹配所有节点，所以每个节点都被获取。

如果我们想匹配所有li的结点只需要

```py
result = html.xpath('//li')
```

### 4.1.4 子节点

通过/或//即可查找元素的子节点或子孙节点，例如选择li节点中的a子节点：

```py
from lxml import etree

html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li/a')
print(result)
```

也可以直接通过ul节点获取子孙a节点：

```py
result = html.xpath('//ul//a')
```

所以/和//的区别在于，/是直接子节点//是获取子孙节点

### 4.1.5 父节点

```py
from lxml import etree

html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//a[@href="link4.html"]/../@class')
print(result)

>>> ['item=1']
```

通过@选取属性确定a的节点，再通过..提取父节点，最后@出class属性

同时我们也可以使用parent::来获取父节点：

```py
result = html.xpath('//a[@href="link4.html"]/parent::*/@class')
```

### 4.1.6 属性匹配

@还可以实现对属性的过滤作用

```py
from lxml import etree
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li[@class="item-0"]')
print(result)
```

 [@class="item-0"] 就限制了节点的 class 属性为 item-0，而 HTML 文本中符合条件的 li 节点有两个，所以返回结果应该返回两个匹配到的元素

### 4.1.7 文本获取

XPath中的text()方法可以获取节点中的文本

```py
from lxml import etree

html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li[@class="item-0"]/a/text()')
print(result)

>>> ['first item', 'fifth item']
```

### 4.1.8 属性获取

节点的属性获取可以使用@

```py
from lxml import etree

html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li/a/@href')
print(result)

>>> ['link1.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html']
```

### 4.1.9 属性多值匹配

某些节点的属性可能有多个值，例如：

```py
from lxml import etree
text = '''
<li class="li li-first"><a href="link.html">first item</a></li>
'''
html = etree.HTML(text)
result = html.xpath('//li[@class="li"]/a/text()')
print(result)
```

其中的class有li和li-first两个值，使用上面的匹配无法爬取。多个属性需要contains()函数

```py
result = html.xpath('//li[contains(@class, "li")]/a/text()')
```

### 4.1.10 多属性匹配

有些节点需要同时匹配多个属性，可以使用and运算符来连接

```py
from lxml import etree
text = '''
<li class="li li-first" name="item"><a href="link.html">first item</a></li>
'''
html = etree.HTML(text)
result = html.xpath('//li[contains(@class, "li") and @name="item"]/a/text()')
print(result)
```

这里的 and 其实是 XPath 中的运算符，另外还有很多运算符，如 or、mod 等等

### 4.1.11 按序选择

有时候某些属性匹配多个节点，我们只需要其中某个节点

```py
from lxml import etree

text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </ul>
 </div>
'''
html = etree.HTML(text)
result = html.xpath('//li[1]/a/text()')
print(result)
result = html.xpath('//li[last()]/a/text()')
print(result)
result = html.xpath('//li[position()<3]/a/text()')
print(result)
result = html.xpath('//li[last()-2]/a/text()')
print(result)
```

利用中括号传入索引的方法获取特定次序的节点

```py
>>> ['first item']
    ['fifth item']
    ['first item', 'second item']
    ['third item']
```

### 4.1.12 节点轴选择

XPath 提供了很多节点轴选择方法，英文叫做 XPath Axes，包括获取子元素、兄弟元素、父元素、祖先元素等等，在一定情况下使用它可以方便地完成节点的选择

```py
from lxml import etree

text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html"><span>first item</span></a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </ul>
 </div>
'''
html = etree.HTML(text)
result = html.xpath('//li[1]/ancestor::*')
print(result)
result = html.xpath('//li[1]/ancestor::div')
print(result)
result = html.xpath('//li[1]/attribute::*')
print(result)
result = html.xpath('//li[1]/child::a[@href="link1.html"]')
print(result)
result = html.xpath('//li[1]/descendant::span')
print(result)
result = html.xpath('//li[1]/following::*[2]')
print(result)
result = html.xpath('//li[1]/following-sibling::*')
print(result)

>>> [<Element html at 0x107941808>, <Element body at 0x1079418c8>, <Element div at 0x107941908>, <Element ul at 0x107941948>]
    [<Element div at 0x107941908>]
    ['item-0']
    [<Element a at 0x1079418c8>]
    [<Element span at 0x107941948>]
    [<Element a at 0x1079418c8>]
    [<Element li at 0x107941948>, <Element li at 0x107941988>, <Element li at 0x1079419c8>, <Element li at 0x107941a08>]
```

第一次选择我们调用了 ancestor 轴，可以获取所有祖先节点，其后需要跟两个冒号，然后是节点的选择器，这里我们直接使用了 *，表示匹配所有节点，因此返回结果是第一个 li 节点的所有祖先节点，包括 html，body，div，ul。

第二次选择我们又加了限定条件，这次在冒号后面加了 div，这样得到的结果就只有 div 这个祖先节点了。

第三次选择我们调用了 attribute 轴，可以获取所有属性值，其后跟的选择器还是 *，这代表获取节点的所有属性，返回值就是 li 节点的所有属性值。

第四次选择我们调用了 child 轴，可以获取所有直接子节点，在这里我们又加了限定条件选取 href 属性为 link1.html 的 a 节点。

第五次选择我们调用了 descendant 轴，可以获取所有子孙节点，这里我们又加了限定条件获取 span 节点，所以返回的就是只包含 span 节点而没有 a 节点。

第六次选择我们调用了 following 轴，可以获取当前节点之后的所有节点，这里我们虽然使用的是 * 匹配，但又加了索引选择，所以只获取了第二个后续节点。

第七次选择我们调用了 following-sibling 轴，可以获取当前节点之后的所有同级节点，这里我们使用的是 * 匹配，所以获取了所有后续同级节点。